// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:cloud_firestore_web/cloud_firestore_web.dart';
import 'package:firebase_auth_web/firebase_auth_web.dart';
import 'package:firebase_core_web/firebase_core_web.dart';
import 'package:image_picker_for_web/image_picker_for_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  FirebaseFirestoreWeb.registerWith(registrar);
  FirebaseAuthWeb.registerWith(registrar);
  FirebaseCoreWeb.registerWith(registrar);
  ImagePickerPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}
//
// Generated file. Do not edit.
// This file is generated from template in file `flutter_tools/lib/src/flutter_plugins.dart`.
//

// @dart = 3.0

import 'dart:io'; // flutter_ignore: dart_io_import.
import 'package:image_picker_android/image_picker_android.dart';
import 'package:image_picker_ios/image_picker_ios.dart';
import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:image_picker_linux/image_picker_linux.dart';
import 'package:file_selector_macos/file_selector_macos.dart';
import 'package:image_picker_macos/image_picker_macos.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:image_picker_windows/image_picker_windows.dart';

@pragma('vm:entry-point')
class _PluginRegistrant {

  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        ImagePickerAndroid.registerWith();
      } catch (err) {
        print(
          '`image_picker_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isIOS) {
      try {
        ImagePickerIOS.registerWith();
      } catch (err) {
        print(
          '`image_picker_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isLinux) {
      try {
        FileSelectorLinux.registerWith();
      } catch (err) {
        print(
          '`file_selector_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerLinux.registerWith();
      } catch (err) {
        print(
          '`image_picker_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isMacOS) {
      try {
        FileSelectorMacOS.registerWith();
      } catch (err) {
        print(
          '`file_selector_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerMacOS.registerWith();
      } catch (err) {
        print(
          '`image_picker_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isWindows) {
      try {
        FileSelectorWindows.registerWith();
      } catch (err) {
        print(
          '`file_selector_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerWindows.registerWith();
      } catch (err) {
        print(
          '`image_picker_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    }
  }
}
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyDOJfsG7_lTgtmBNPdJVB4b-vPdahG4LxU',
    appId: '1:1040892024883:web:11750f6de0d0ee077c6b46',
    messagingSenderId: '1040892024883',
    projectId: 'padel-trax-killwd',
    authDomain: 'padel-trax-killwd.firebaseapp.com',
    storageBucket:
        'padel-trax-killwd.appspot.com', // Ensure correct bucket format for web
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBMpwBZbDi6AFOQEheg1TOzG0aNwg2dfHc',
    appId: '1:1040892024883:android:a8c559db42d7c1f07c6b46',
    messagingSenderId: '1040892024883',
    projectId: 'padel-trax-killwd',
    storageBucket: 'padel-trax-killwd.appspot.com', // Unified bucket format
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyAN1KqJizZOmsWPZ1x8_zcTyfVP6Ps6F1U',
    appId: '1:1040892024883:ios:0c6605a1d3d04f0b7c6b46',
    messagingSenderId: '1040892024883',
    projectId: 'padel-trax-killwd',
    storageBucket: 'padel-trax-killwd.appspot.com',
    androidClientId:
        '1040892024883-0vck8qpbqa0b4dod3nbs0ehiisiunaog.apps.googleusercontent.com',
    iosBundleId:
        'com.mycompany.padeltrax', // Match iOS bundle ID to Firebase console
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyAN1KqJizZOmsWPZ1x8_zcTyfVP6Ps6F1U',
    appId: '1:1040892024883:ios:0c6605a1d3d04f0b7c6b46',
    messagingSenderId: '1040892024883',
    projectId: 'padel-trax-killwd',
    storageBucket: 'padel-trax-killwd.appspot.com',
    androidClientId:
        '1040892024883-0vck8qpbqa0b4dod3nbs0ehiisiunaog.apps.googleusercontent.com',
    iosBundleId: 'com.mycompany.padeltrax', // Match macOS bundle ID
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyDOJfsG7_lTgtmBNPdJVB4b-vPdahG4LxU',
    appId: '1:1040892024883:web:a61c692fc69991667c6b46',
    messagingSenderId: '1040892024883',
    projectId: 'padel-trax-killwd',
    authDomain: 'padel-trax-killwd.firebaseapp.com',
    storageBucket: 'padel-trax-killwd.appspot.com',
  );
}
import 'package:flutter/material.dart';
import '../../models/player.dart';
import 'widgets/stats_overview_tab.dart';
import 'widgets/stats_achievements_tab.dart';
import 'widgets/stats_partnerships_tab.dart';

class PlayerStatisticsScreen extends StatelessWidget {
  final List<Player> players;

  const PlayerStatisticsScreen({
    super.key,
    required this.players,
  });

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 3,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Player Statistics'),
          bottom: const TabBar(
            tabs: [
              Tab(text: 'Overview'),
              Tab(text: 'Achievements'),
              Tab(text: 'Partnerships'),
            ],
          ),
        ),
        body: TabBarView(
          children: [
            StatsOverviewTab(players: players),
            StatsAchievementsTab(players: players),
            StatsPartnershipsTab(players: players),
          ],
        ),
      ),
    );
  }
}
// lib/screens/statistics/widgets/stats_partnerships_tab.dart

import 'package:flutter/material.dart';
import 'package:padeltrax_app/models/player.dart';
import 'package:fl_chart/fl_chart.dart';

class StatsPartnershipsTab extends StatelessWidget {
  final List<Player> players;

  const StatsPartnershipsTab({
    super.key,
    required this.players,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: players.length,
      itemBuilder: (context, playerIndex) {
        final player = players[playerIndex];
        final partnershipStats = player.statistics.partnershipMatches;

        return Card(
          margin: const EdgeInsets.only(bottom: 16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Player Header
              ListTile(
                leading: player.avatar(size: 48),
                title: Text(
                  player.name,
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
                subtitle: Text(
                  '${partnershipStats.length} Partners',
                  style: TextStyle(color: Colors.grey[600]),
                ),
              ),

              // Partnership List
              ListView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: partnershipStats.length,
                itemBuilder: (context, index) {
                  final partnerName = partnershipStats.keys.elementAt(index);
                  final matches = partnershipStats[partnerName] ?? 0;
                  final winRate =
                      player.statistics.partnershipWinRate[partnerName] ?? 0.0;

                  return _buildPartnershipCard(
                    partnerName: partnerName,
                    matches: matches,
                    winRate: winRate,
                  );
                },
              ),

              if (partnershipStats.isNotEmpty)
                _buildPartnershipChart(player, partnershipStats),
            ],
          ),
        );
      },
    );
  }

  Widget _buildPartnershipChart(
      Player player, Map<String, int> partnershipStats) {
    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16),
          child: Text(
            'Partnership Win Rates',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: Colors.grey[800],
            ),
          ),
        ),
        SizedBox(
          height: 200,
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: BarChart(
              BarChartData(
                alignment: BarChartAlignment.spaceAround,
                maxY: 100,
                barTouchData: BarTouchData(enabled: true),
                titlesData: FlTitlesData(
                  show: true,
                  bottomTitles: AxisTitles(
                    sideTitles: SideTitles(
                      showTitles: true,
                      getTitlesWidget: (value, meta) {
                        if (value.toInt() >= partnershipStats.length) {
                          return const Text('');
                        }
                        return RotatedBox(
                          quarterTurns: 1,
                          child: Text(
                            partnershipStats.keys
                                .elementAt(value.toInt())
                                .split(' ')[0],
                            style: const TextStyle(fontSize: 10),
                          ),
                        );
                      },
                    ),
                  ),
                ),
                barGroups: partnershipStats.entries
                    .map((entry) => BarChartGroupData(
                          x: partnershipStats.keys.toList().indexOf(entry.key),
                          barRods: [
                            BarChartRodData(
                              toY: (player.statistics
                                          .partnershipWinRate[entry.key] ??
                                      0) *
                                  100,
                              color: Colors.blue,
                              width: 20,
                              borderRadius: const BorderRadius.vertical(
                                top: Radius.circular(4),
                              ),
                            ),
                          ],
                        ))
                    .toList(),
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildPartnershipCard({
    required String partnerName,
    required int matches,
    required double winRate,
  }) {
    return ListTile(
      leading: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: Colors.blue.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
        ),
        child: const Icon(Icons.people, color: Colors.blue),
      ),
      title: Text(partnerName),
      subtitle: Text('$matches matches played'),
      trailing: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          color: _getWinRateColor(winRate).withOpacity(0.1),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(
          '${(winRate * 100).toStringAsFixed(1)}%',
          style: TextStyle(
            color: _getWinRateColor(winRate),
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  Color _getWinRateColor(double winRate) {
    if (winRate >= 0.7) return Colors.green;
    if (winRate >= 0.5) return Colors.blue;
    if (winRate >= 0.3) return Colors.orange;
    return Colors.red;
  }
}
// lib/screens/statistics/widgets/stats_overview_tab.dart

import 'package:flutter/material.dart';
import 'package:padeltrax_app/models/player.dart';
import 'stats_card.dart';
import 'recent_form_display.dart';
import 'rating_chart.dart';

class StatsOverviewTab extends StatelessWidget {
  final List<Player> players;

  const StatsOverviewTab({
    super.key,
    required this.players,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: players.length,
      itemBuilder: (context, index) {
        final player = players[index];
        final winRate = player.statistics.wins /
            (player.statistics.totalMatches == 0
                ? 1
                : player.statistics.totalMatches) *
            100;

        return Card(
          margin: const EdgeInsets.only(bottom: 16),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Player Header
                ListTile(
                  leading: player.avatar(size: 48),
                  title: Text(player.name,
                      style: const TextStyle(fontWeight: FontWeight.bold)),
                  subtitle: Text('Rating: ${player.rating}'),
                ),

                const SizedBox(height: 16),

                // Stats Grid
                Row(
                  children: [
                    Expanded(
                      child: StatsCard(
                        title: 'Win Rate',
                        value: '${winRate.toStringAsFixed(1)}%',
                        trend: 5,
                        isPositive: true,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: StatsCard(
                        title: 'Total Matches',
                        value: player.statistics.totalMatches.toString(),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: StatsCard(
                        title: 'Current Streak',
                        value: player.statistics.currentStreak.toString(),
                        trend: player.statistics.currentStreak,
                        isPositive: player.statistics.currentStreak > 0,
                      ),
                    ),
                  ],
                ),

                const SizedBox(height: 16),

                // Recent Form
                RecentFormDisplay(
                  recentResults: player.statistics.recentResults,
                ),

                const SizedBox(height: 16),

                // Rating Chart
                SizedBox(
                  height: 200,
                  child: RatingChart(
                    ratingHistory: player.statistics.last10MatchesRating,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}
// lib/screens/statistics/widgets/recent_form_display.dart

import 'package:flutter/material.dart';
import 'package:padeltrax_app/models/match/match_result.dart';

class RecentFormDisplay extends StatelessWidget {
  final List<MatchResult> recentResults;

  const RecentFormDisplay({
    super.key,
    required this.recentResults,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Recent Form',
          style: TextStyle(
            color: Colors.grey[600],
            fontSize: 14,
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 8),
        Row(
          children: recentResults.take(5).map((result) {
            return Padding(
              padding: const EdgeInsets.only(right: 4),
              child: Container(
                width: 32,
                height: 32,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: result.isWin
                      ? Colors.green
                      : result.isDraw
                          ? Colors.orange
                          : Colors.red,
                ),
                child: Center(
                  child: Text(
                    result.isWin
                        ? 'W'
                        : result.isDraw
                            ? 'D'
                            : 'L',
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }
}
// lib/screens/statistics/widgets/stats_card.dart

import 'package:flutter/material.dart';

class StatsCard extends StatelessWidget {
  final String title;
  final String value;
  final int? trend;
  final bool isPositive;

  const StatsCard({
    super.key,
    required this.title,
    required this.value,
    this.trend,
    this.isPositive = true,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 2,
            offset: const Offset(0, 1),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: TextStyle(
              color: Colors.grey[600],
              fontSize: 12,
            ),
          ),
          const SizedBox(height: 4),
          Row(
            children: [
              Text(
                value,
                style: const TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              if (trend != null) ...[
                const SizedBox(width: 4),
                Icon(
                  isPositive ? Icons.trending_up : Icons.trending_down,
                  size: 16,
                  color: isPositive ? Colors.green : Colors.red,
                ),
                Text(
                  trend.toString(),
                  style: TextStyle(
                    fontSize: 12,
                    color: isPositive ? Colors.green : Colors.red,
                  ),
                ),
              ],
            ],
          ),
        ],
      ),
    );
  }
}
// lib/screens/statistics/widgets/rating_chart.dart

import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';

class RatingChart extends StatelessWidget {
  final List<double> ratingHistory;

  const RatingChart({
    super.key,
    required this.ratingHistory,
  });

  @override
  Widget build(BuildContext context) {
    return LineChart(
      LineChartData(
        gridData: const FlGridData(show: true),
        titlesData: const FlTitlesData(show: true),
        borderData: FlBorderData(show: true),
        lineBarsData: [
          LineChartBarData(
            spots: ratingHistory.asMap().entries.map((entry) {
              return FlSpot(entry.key.toDouble(), entry.value);
            }).toList(),
            isCurved: true,
            color: Colors.blue,
            barWidth: 3,
            dotData: const FlDotData(show: false),
          ),
        ],
      ),
    );
  }
}
// lib/screens/statistics/widgets/stats_achievements_tab.dart

import 'package:flutter/material.dart';
import 'package:padeltrax_app/models/player.dart';
import 'package:padeltrax_app/models/match/achievement.dart';

class StatsAchievementsTab extends StatelessWidget {
  final List<Player> players;

  const StatsAchievementsTab({
    super.key,
    required this.players,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: players.length,
      itemBuilder: (context, playerIndex) {
        final player = players[playerIndex];
        return Card(
          margin: const EdgeInsets.only(bottom: 16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Player Header
              ListTile(
                leading: player.avatar(size: 48),
                title: Text(
                  player.name,
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
              ),

              // Achievements Grid
              GridView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                padding: const EdgeInsets.all(16),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 2,
                  childAspectRatio: 1.5,
                  crossAxisSpacing: 12,
                  mainAxisSpacing: 12,
                ),
                itemCount: player.statistics.achievements.length,
                itemBuilder: (context, index) {
                  final achievement = player.statistics.achievements[index];
                  return _buildAchievementCard(achievement);
                },
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildAchievementCard(Achievement achievement) {
    return Card(
      elevation: 2,
      child: InkWell(
        onTap: () {}, // Could show achievement details
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: achievement.rarity.color.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Icon(
                      _getAchievementIcon(achievement.type),
                      color: achievement.rarity.color,
                      size: 20,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      achievement.title,
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 14,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                achievement.description,
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[600],
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              const Spacer(),
              Text(
                'Earned ${_formatDate(achievement.dateEarned)}',
                style: TextStyle(
                  fontSize: 10,
                  color: Colors.grey[500],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  IconData _getAchievementIcon(AchievementType type) {
    switch (type) {
      case AchievementType.winStreak:
        return Icons.bolt;
      case AchievementType.perfectSet:
        return Icons.star;
      case AchievementType.comeback:
        return Icons.trending_up;
      case AchievementType.tournament:
        return Icons.emoji_events;
      default:
        return Icons.emoji_events;
    }
  }

  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }
}
import 'package:flutter/material.dart';
import '../../../models/player.dart';

class PlayerStatisticsView extends StatelessWidget {
  final List<Player> players;

  const PlayerStatisticsView({
    super.key,
    required this.players,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: players.length,
      itemBuilder: (context, index) {
        final player = players[index];
        return Card(
          margin: const EdgeInsets.only(bottom: 16),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                ListTile(
                  contentPadding: EdgeInsets.zero,
                  leading: player.avatar(size: 50),
                  title: Text(
                    player.name,
                    style: const TextStyle(
                        fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  subtitle: Text(
                    'Rating: ${player.statistics.rating.toStringAsFixed(1)}',
                  ),
                ),
                const Divider(),
                _buildStatsRow(
                  'Matches',
                  '${player.statistics.totalMatches}',
                  'Win Rate',
                  '${player.statistics.winRate.toStringAsFixed(1)}%',
                ),
                _buildStatsRow(
                  'Wins',
                  player.statistics.wins.toString(),
                  'Losses',
                  player.statistics.losses.toString(),
                ),
                _buildStatsRow(
                  'Sets Won',
                  player.statistics.setsWon.toString(),
                  'Sets Lost',
                  player.statistics.setsLost.toString(),
                ),
                _buildStatsRow(
                  'Games Won',
                  player.statistics.gamesWon.toString(),
                  'Games Lost',
                  player.statistics.gamesLost.toString(),
                ),
                const SizedBox(height: 8),
                const Text(
                  'Recent Form:',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                Row(
                  children: player.statistics.recentMatches.map((result) {
                    return Container(
                      width: 30,
                      height: 30,
                      margin: const EdgeInsets.only(right: 8),
                      decoration: BoxDecoration(
                        color: _getResultColor(result),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Center(
                        child: Text(
                          result,
                          style: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildStatsRow(
      String label1, String value1, String label2, String value2) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Expanded(
            child: _buildStatItem(label1, value1),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: _buildStatItem(label2, value2),
          ),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey[600],
          ),
        ),
        const SizedBox(height: 2),
        Text(
          value,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }

  Color _getResultColor(String result) {
    switch (result) {
      case 'W':
        return Colors.green;
      case 'D':
        return Colors.orange;
      case 'L':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }
}
import 'package:flutter/material.dart';
import '../../../models/match/achievement.dart';

class AchievementDisplay extends StatelessWidget {
  final List<Achievement> achievements;
  final bool showProgress;

  const AchievementDisplay({
    super.key,
    required this.achievements,
    this.showProgress = true,
  });

  @override
  Widget build(BuildContext context) {
    if (achievements.isEmpty) {
      return _buildEmptyState();
    }

    return GridView.builder(
      padding: const EdgeInsets.all(16),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        childAspectRatio: 1.5,
        crossAxisSpacing: 12,
        mainAxisSpacing: 12,
      ),
      itemCount: achievements.length,
      itemBuilder: (context, index) => _AchievementCard(
        achievement: achievements[index],
        showProgress: showProgress,
        onTap: () => _showAchievementDetails(context, achievements[index]),
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.emoji_events_outlined,
            size: 64,
            color: Colors.grey[400],
          ),
          const SizedBox(height: 16),
          Text(
            'No achievements yet',
            style: TextStyle(
              fontSize: 18,
              color: Colors.grey[600],
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Keep playing to unlock achievements!',
            style: TextStyle(
              color: Colors.grey[500],
            ),
          ),
        ],
      ),
    );
  }

  void _showAchievementDetails(BuildContext context, Achievement achievement) {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (context) => _AchievementDetailsSheet(achievement: achievement),
    );
  }
}

class _AchievementCard extends StatelessWidget {
  final Achievement achievement;
  final bool showProgress;
  final VoidCallback onTap;

  const _AchievementCard({
    required this.achievement,
    required this.showProgress,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                achievement.rarity.color.withOpacity(0.1),
                achievement.rarity.color.withOpacity(0.05),
              ],
            ),
          ),
          child: Stack(
            children: [
              if (achievement.isRecent)
                Positioned(
                  right: -20,
                  top: -20,
                  child: Container(
                    padding: const EdgeInsets.all(30),
                    decoration: BoxDecoration(
                      color: Colors.green.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(30),
                    ),
                    child: const Text(
                      'NEW',
                      style: TextStyle(
                        color: Colors.green,
                        fontWeight: FontWeight.bold,
                        fontSize: 10,
                      ),
                    ),
                  ),
                ),
              Padding(
                padding: const EdgeInsets.all(12),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(
                          achievement.getIconData(),
                          color: achievement.rarity.color,
                          size: 24,
                        ),
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 2,
                          ),
                          decoration: BoxDecoration(
                            color: achievement.rarity.color.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(
                              color: achievement.rarity.color.withOpacity(0.5),
                            ),
                          ),
                          child: Text(
                            achievement.rarity.label,
                            style: TextStyle(
                              color: achievement.rarity.color,
                              fontSize: 10,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 8),
                    Text(
                      achievement.title,
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 14,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      achievement.description,
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey[600],
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    if (showProgress &&
                        achievement.progress != null &&
                        achievement.target != null)
                      Expanded(
                        child: Align(
                          alignment: Alignment.bottomCenter,
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              LinearProgressIndicator(
                                value: achievement.progressPercentage,
                                backgroundColor: Colors.grey[200],
                                valueColor: AlwaysStoppedAnimation<Color>(
                                  achievement.rarity.color,
                                ),
                              ),
                              const SizedBox(height: 4),
                              Text(
                                '${achievement.progress}/${achievement.target}',
                                style: TextStyle(
                                  fontSize: 10,
                                  color: Colors.grey[600],
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _AchievementDetailsSheet extends StatelessWidget {
  final Achievement achievement;

  const _AchievementDetailsSheet({
    required this.achievement,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.all(16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 40,
            height: 4,
            margin: const EdgeInsets.only(bottom: 16),
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          Row(
            children: [
              CircleAvatar(
                backgroundColor: achievement.rarity.color.withOpacity(0.1),
                child: Icon(
                  achievement.getIconData(),
                  color: achievement.rarity.color,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      achievement.title,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 2,
                      ),
                      decoration: BoxDecoration(
                        color: achievement.rarity.color.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        achievement.rarity.label,
                        style: TextStyle(
                          color: achievement.rarity.color,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          const Divider(),
          const SizedBox(height: 16),
          Text(
            achievement.description,
            style: TextStyle(
              fontSize: 16,
              color: Colors.grey[700],
            ),
          ),
          if (achievement.progress != null && achievement.target != null) ...[
            const SizedBox(height: 24),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Progress: ${achievement.progress}/${achievement.target}',
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                LinearProgressIndicator(
                  value: achievement.progressPercentage,
                  backgroundColor: Colors.grey[200],
                  valueColor: AlwaysStoppedAnimation<Color>(
                    achievement.rarity.color,
                  ),
                ),
              ],
            ),
          ],
          const SizedBox(height: 24),
          Row(
            children: [
              Icon(Icons.calendar_today, size: 16, color: Colors.grey[600]),
              const SizedBox(width: 8),
              Text(
                'Earned on ${achievement.formattedDate}',
                style: TextStyle(
                  color: Colors.grey[600],
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import '../../../models/match.dart';

class MatchHeader extends StatelessWidget {
  final MatchStatus status;
  final String time;

  const MatchHeader({
    super.key,
    required this.status,
    required this.time,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Row(
          children: [
            Container(
              width: 8,
              height: 8,
              decoration: BoxDecoration(
                color: _getStatusColor(status),
                shape: BoxShape.circle,
              ),
            ),
            const SizedBox(width: 8),
            Text(
              _getStatusText(status),
              style: TextStyle(
                color: _getStatusColor(status),
                fontWeight: FontWeight.w600,
                fontSize: 14,
              ),
            ),
          ],
        ),
        Text(
          time,
          style: const TextStyle(
            color: Colors.grey,
            fontSize: 14,
          ),
        ),
      ],
    );
  }

  Color _getStatusColor(MatchStatus status) {
    switch (status) {
      case MatchStatus.scheduled:
        return Colors.blue;
      case MatchStatus.inProgress:
        return Colors.orange;
      case MatchStatus.completed:
        return Colors.green;
      case MatchStatus.cancelled:
        return Colors.red;
      case MatchStatus.waitingPlayers:
        return Colors.purple;
    }
  }

  String _getStatusText(MatchStatus status) {
    switch (status) {
      case MatchStatus.scheduled:
        return 'Scheduled';
      case MatchStatus.inProgress:
        return 'In Progress';
      case MatchStatus.completed:
        return 'Completed';
      case MatchStatus.cancelled:
        return 'Cancelled';
      case MatchStatus.waitingPlayers:
        return 'Waiting Players';
    }
  }
}
import 'package:flutter/material.dart';
import '../../../models/match_scoring.dart';

class ScoreBoard extends StatelessWidget {
  final MatchScoring scoring;
  final Function(String team, int gameIndex) onScoreUpdate;
  final bool isMatchComplete;

  const ScoreBoard({
    super.key,
    required this.scoring,
    required this.onScoreUpdate,
    this.isMatchComplete = false,
  });

  Widget _buildScoreBox(int score, Color color, {VoidCallback? onTap}) {
    return ConstrainedBox(
      constraints: const BoxConstraints(
        minWidth: 20,
        maxWidth: 24,
        minHeight: 20,
        maxHeight: 24,
      ),
      child: GestureDetector(
        onTap: onTap,
        child: Container(
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color: color,
            borderRadius: BorderRadius.circular(4),
          ),
          child: FittedBox(
            fit: BoxFit.scaleDown,
            child: Padding(
              padding: const EdgeInsets.all(2.0),
              child: Text(
                score.toString(),
                style: TextStyle(
                  color: color == Colors.grey.shade300
                      ? Colors.black
                      : Colors.white,
                  fontWeight: FontWeight.bold,
                  fontSize: 12,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildTeamScore(String team) {
    return Flexible(
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        mainAxisSize: MainAxisSize.min,
        children: [
          // Sets score
          _buildScoreBox(
            scoring.teamScores[team]!.sets,
            Colors.blue.shade700,
          ),
          const SizedBox(width: 4),
          // Games scores
          Flexible(
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: List.generate(
                3,
                (index) => Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 1),
                  child: _buildScoreBox(
                    index < scoring.teamScores[team]!.games.length
                        ? scoring.teamScores[team]!.games[index]
                        : 0,
                    Colors.grey.shade300,
                    onTap: isMatchComplete
                        ? null
                        : () => onScoreUpdate(team, index),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        return Container(
          constraints: BoxConstraints(
            maxWidth: constraints.maxWidth,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildTeamScore('team1'),
              const SizedBox(height: 4),
              _buildTeamScore('team2'),
            ],
          ),
        );
      },
    );
  }
}
// lib/screens/match/components/match_status.dart

import 'package:flutter/material.dart';

class MatchStatus extends StatelessWidget {
  final bool isComplete;
  final String? winner;
  final String? matchTime;

  const MatchStatus({
    super.key,
    required this.isComplete,
    this.winner,
    this.matchTime,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        if (matchTime != null) _buildTimeRow(),
        if (isComplete) _buildWinnerStatus(),
      ],
    );
  }

  Widget _buildTimeRow() {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          const Icon(
            Icons.access_time,
            size: 16,
            color: Colors.grey,
          ),
          const SizedBox(width: 4),
          Text(
            matchTime!,
            style: const TextStyle(
              color: Colors.grey,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildWinnerStatus() {
    return Container(
      margin: const EdgeInsets.only(top: 16),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.green.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.green),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(
            Icons.emoji_events,
            color: Colors.green,
            size: 20,
          ),
          const SizedBox(width: 8),
          Text(
            '${winner ?? "Team"} Wins!',
            style: const TextStyle(
              color: Colors.green,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }

  // Static method to determine winner display name
  static String getWinnerDisplay(String winner) {
    return winner == 'team1' ? 'Team 1' : 'Team 2';
  }
}

// Optional: enum for match states
enum MatchState {
  scheduled,
  inProgress,
  completed,
  cancelled;

  Color get color {
    switch (this) {
      case MatchState.scheduled:
        return Colors.blue;
      case MatchState.inProgress:
        return Colors.orange;
      case MatchState.completed:
        return Colors.green;
      case MatchState.cancelled:
        return Colors.red;
    }
  }

  String get label {
    switch (this) {
      case MatchState.scheduled:
        return 'Scheduled';
      case MatchState.inProgress:
        return 'In Progress';
      case MatchState.completed:
        return 'Completed';
      case MatchState.cancelled:
        return 'Cancelled';
    }
  }
}
// lib/screens/match/components/save_indicator.dart

import 'package:flutter/material.dart';

class SaveIndicator extends StatelessWidget {
  final bool isVisible;
  final String? message;
  final Color? color;

  const SaveIndicator({
    super.key,
    required this.isVisible,
    this.message = 'Saving...',
    this.color = Colors.orange,
  });

  @override
  Widget build(BuildContext context) {
    return AnimatedOpacity(
      opacity: isVisible ? 1.0 : 0.0,
      duration: const Duration(milliseconds: 200),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: color!.withOpacity(0.1),
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: color!),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: 12,
              height: 12,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(color!),
              ),
            ),
            const SizedBox(width: 8),
            Text(
              message!,
              style: TextStyle(
                color: color,
                fontSize: 12,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Optional: SaveState enum for different saving states
enum SaveState {
  idle,
  saving,
  success,
  error;

  Color get color {
    switch (this) {
      case SaveState.saving:
        return Colors.orange;
      case SaveState.success:
        return Colors.green;
      case SaveState.error:
        return Colors.red;
      case SaveState.idle:
        return Colors.grey;
    }
  }

  String get message {
    switch (this) {
      case SaveState.saving:
        return 'Saving...';
      case SaveState.success:
        return 'Saved!';
      case SaveState.error:
        return 'Error saving';
      case SaveState.idle:
        return '';
    }
  }
}

// Optional: Extended version with more features
class SaveIndicatorExtended extends StatelessWidget {
  final SaveState state;
  final String? customMessage;
  final VoidCallback? onRetry;

  const SaveIndicatorExtended({
    super.key,
    required this.state,
    this.customMessage,
    this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    return AnimatedOpacity(
      opacity: state == SaveState.idle ? 0.0 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: state.color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: state.color),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (state == SaveState.saving)
              SizedBox(
                width: 12,
                height: 12,
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                  valueColor: AlwaysStoppedAnimation<Color>(state.color),
                ),
              )
            else
              Icon(
                _getStateIcon(),
                size: 12,
                color: state.color,
              ),
            const SizedBox(width: 8),
            Text(
              customMessage ?? state.message,
              style: TextStyle(
                color: state.color,
                fontSize: 12,
              ),
            ),
            if (state == SaveState.error && onRetry != null) ...[
              const SizedBox(width: 8),
              GestureDetector(
                onTap: onRetry,
                child: Icon(
                  Icons.refresh,
                  size: 14,
                  color: state.color,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  IconData _getStateIcon() {
    switch (state) {
      case SaveState.success:
        return Icons.check_circle_outline;
      case SaveState.error:
        return Icons.error_outline;
      default:
        return Icons.info_outline;
    }
  }
}
import 'package:flutter/material.dart';

class ErrorView extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;

  const ErrorView({
    super.key,
    required this.message,
    this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              color: Colors.red[300],
              size: 60,
            ),
            const SizedBox(height: 16),
            Text(
              message,
              textAlign: TextAlign.center,
              style: const TextStyle(
                fontSize: 16,
                color: Colors.grey,
              ),
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: const Text('Try Again'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 24,
                    vertical: 12,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
// lib/screens/match/components/undo_redo_buttons.dart

import 'package:flutter/services.dart';
import 'package:flutter/material.dart';

class UndoRedoButtons extends StatelessWidget {
  final bool canUndo;
  final bool canRedo;
  final VoidCallback? onUndo;
  final VoidCallback? onRedo;
  final bool showTooltips;
  final Color? activeColor;
  final Color? inactiveColor;

  const UndoRedoButtons({
    super.key,
    required this.canUndo,
    required this.canRedo,
    this.onUndo,
    this.onRedo,
    this.showTooltips = true,
    this.activeColor = Colors.blue,
    this.inactiveColor = Colors.grey,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        _buildActionButton(
          icon: Icons.undo,
          enabled: canUndo,
          onPressed: onUndo,
          tooltip: 'Undo last action',
        ),
        _buildActionButton(
          icon: Icons.redo,
          enabled: canRedo,
          onPressed: onRedo,
          tooltip: 'Redo last action',
        ),
      ],
    );
  }

  Widget _buildActionButton({
    required IconData icon,
    required bool enabled,
    VoidCallback? onPressed,
    required String tooltip,
  }) {
    final button = IconButton(
      icon: Icon(
        icon,
        color: enabled ? activeColor : inactiveColor,
        size: 20,
      ),
      onPressed: enabled ? onPressed : null,
      padding: const EdgeInsets.all(8),
      constraints: const BoxConstraints(
        minWidth: 32,
        minHeight: 32,
      ),
      splashRadius: 20,
    );

    return showTooltips
        ? Tooltip(
            message: tooltip,
            child: button,
          )
        : button;
  }
}

// Optional: Extended version with animations and badges
class UndoRedoButtonsExtended extends StatelessWidget {
  final bool canUndo;
  final bool canRedo;
  final VoidCallback? onUndo;
  final VoidCallback? onRedo;
  final int undoCount;
  final int redoCount;
  final bool showCounts;
  final Color? activeColor;
  final Color? inactiveColor;

  const UndoRedoButtonsExtended({
    super.key,
    required this.canUndo,
    required this.canRedo,
    this.onUndo,
    this.onRedo,
    this.undoCount = 0,
    this.redoCount = 0,
    this.showCounts = false,
    this.activeColor = Colors.blue,
    this.inactiveColor = Colors.grey,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        _buildAnimatedButton(
          icon: Icons.undo,
          enabled: canUndo,
          onPressed: onUndo,
          tooltip: 'Undo last action',
          count: undoCount,
        ),
        _buildAnimatedButton(
          icon: Icons.redo,
          enabled: canRedo,
          onPressed: onRedo,
          tooltip: 'Redo last action',
          count: redoCount,
        ),
      ],
    );
  }

  Widget _buildAnimatedButton({
    required IconData icon,
    required bool enabled,
    VoidCallback? onPressed,
    required String tooltip,
    required int count,
  }) {
    return Stack(
      clipBehavior: Clip.none,
      children: [
        Tooltip(
          message: tooltip,
          child: Material(
            color: Colors.transparent,
            child: InkWell(
              onTap: enabled ? onPressed : null,
              borderRadius: BorderRadius.circular(20),
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 200),
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: enabled
                      ? activeColor?.withOpacity(0.1)
                      : Colors.transparent,
                  borderRadius: BorderRadius.circular(20),
                ),
                child: Icon(
                  icon,
                  color: enabled ? activeColor : inactiveColor,
                  size: 20,
                ),
              ),
            ),
          ),
        ),
        if (showCounts && count > 0)
          Positioned(
            right: -4,
            top: -4,
            child: Container(
              padding: const EdgeInsets.all(4),
              decoration: BoxDecoration(
                color: activeColor,
                shape: BoxShape.circle,
              ),
              constraints: const BoxConstraints(
                minWidth: 16,
                minHeight: 16,
              ),
              child: Text(
                count.toString(),
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ),
      ],
    );
  }
}

// Optional: Keyboard shortcuts handler
class UndoRedoShortcuts extends StatelessWidget {
  final Widget child;
  final VoidCallback? onUndo;
  final VoidCallback? onRedo;
  final bool enabled;

  const UndoRedoShortcuts({
    super.key,
    required this.child,
    this.onUndo,
    this.onRedo,
    this.enabled = true,
  });

  @override
  Widget build(BuildContext context) {
    return Shortcuts(
      shortcuts: enabled
          ? <ShortcutActivator, Intent>{
              LogicalKeySet(
                LogicalKeyboardKey.control,
                LogicalKeyboardKey.keyZ,
              ): const UndoIntent(),
              LogicalKeySet(
                LogicalKeyboardKey.control,
                LogicalKeyboardKey.keyY,
              ): const RedoIntent(),
              LogicalKeySet(
                LogicalKeyboardKey.control,
                LogicalKeyboardKey.shift,
                LogicalKeyboardKey.keyZ,
              ): const RedoIntent(),
            }
          : {},
      child: Actions(
        actions: <Type, Action<Intent>>{
          UndoIntent: CallbackAction<UndoIntent>(
            onInvoke: (UndoIntent intent) => onUndo?.call(),
          ),
          RedoIntent: CallbackAction<RedoIntent>(
            onInvoke: (RedoIntent intent) => onRedo?.call(),
          ),
        },
        child: child,
      ),
    );
  }
}

// Intents for keyboard shortcuts
class UndoIntent extends Intent {
  const UndoIntent();
}

class RedoIntent extends Intent {
  const RedoIntent();
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'dart:async';

import '../../../models/match.dart' as match_model;
import '../../../models/match_scoring.dart';
import '../../../models/player.dart';
import '../../../providers/app_state.dart';

import './score_board.dart';

class MatchCard extends StatefulWidget {
  final match_model.Match match;
  final bool isHistory;
  final VoidCallback? onScoreUpdated; // Callback for score updates
  final VoidCallback? onViewDetails; // Callback to view match details

  const MatchCard({
    super.key,
    required this.match,
    this.isHistory = false,
    this.onScoreUpdated,
    this.onViewDetails,
  });

  @override
  State<MatchCard> createState() => _MatchCardState();
}

class _MatchCardState extends State<MatchCard> {
  late MatchScoring _scoring;
  bool _hasUnsavedChanges = false;
  Timer? _saveTimer;

  // Store AppState reference at class level
  late final AppState _appState;

  @override
  void initState() {
    super.initState();
    _scoring = MatchScoring();
    _initializeScores();
    // Initialize AppState reference
    _appState = context.read<AppState>();
  }

  @override
  void dispose() {
    _saveTimer?.cancel();
    super.dispose();
  }

  void _initializeScores() {
    final team1Score = widget.match.score['team1'];
    final team2Score = widget.match.score['team2'];

    if (team1Score != null) {
      _scoring.teamScores['team1']!.games = List<int>.from(team1Score.games);
      _scoring.teamScores['team1']!.sets = team1Score.sets;
    }

    if (team2Score != null) {
      _scoring.teamScores['team2']!.games = List<int>.from(team2Score.games);
      _scoring.teamScores['team2']!.sets = team2Score.sets;
    }
  }

  Future<void> _saveMatchScore() async {
    if (!_hasUnsavedChanges) return;

    try {
      // Store ScaffoldMessenger before async operation
      final messenger = ScaffoldMessenger.of(context);

      // Update team1 score
      await _appState.updateMatchScore(
        widget.match.id,
        'team1',
        'sets',
        _scoring.teamScores['team1']!.sets,
      );
      await _appState.updateMatchScore(
        widget.match.id,
        'team1',
        'games',
        _scoring.teamScores['team1']!.games,
      );

      // Update team2 score
      await _appState.updateMatchScore(
        widget.match.id,
        'team2',
        'sets',
        _scoring.teamScores['team2']!.sets,
      );
      await _appState.updateMatchScore(
        widget.match.id,
        'team2',
        'games',
        _scoring.teamScores['team2']!.games,
      );

      // Mark the match as completed if necessary
      if (_scoring.isMatchComplete) {
        await _appState.updateMatchStatus(
          widget.match.id,
          match_model.MatchStatus.completed,
        );
      }

      // Trigger the callback if defined
      widget.onScoreUpdated?.call();

      if (!mounted) return;

      setState(() => _hasUnsavedChanges = false);

      messenger.showSnackBar(
        const SnackBar(
          content: Text('Match score saved successfully'),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      if (!mounted) return;

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error saving match score: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _updateScore(String team, int gameIndex) {
    if (_scoring.isMatchComplete) return;

    setState(() {
      final currentTeam = _scoring.teamScores[team]!;
      final opposingTeam =
          _scoring.teamScores[team == 'team1' ? 'team2' : 'team1']!;

      while (currentTeam.games.length <= gameIndex) {
        currentTeam.games.add(0);
        opposingTeam.games.add(0);
      }

      currentTeam.games[gameIndex]++;

      if (_isSetWon(
          currentTeam.games[gameIndex], opposingTeam.games[gameIndex])) {
        currentTeam.sets++;
        if (currentTeam.sets == 2) {
          _scoring.isMatchComplete = true;
          _scoring.winner = team;
        }
      } else if (!_isValidGameScore(
          currentTeam.games[gameIndex], opposingTeam.games[gameIndex])) {
        currentTeam.games[gameIndex]--;
      }

      _hasUnsavedChanges = true;
    });

    // Save the updated score
    _saveMatchScore();
  }

  bool _isSetWon(int currentTeamGames, int opposingTeamGames) {
    return (currentTeamGames == 6 && opposingTeamGames <= 4) ||
        (currentTeamGames == 7 &&
            (opposingTeamGames == 5 || opposingTeamGames == 6));
  }

  bool _isValidGameScore(int currentTeamGames, int opposingTeamGames) {
    if (currentTeamGames > 7) return false;
    if (currentTeamGames == 7 && opposingTeamGames < 5) return false;
    if (currentTeamGames == 6 && opposingTeamGames > 6) return false;
    return true;
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
      ),
      child: InkWell(
        onTap: widget.isHistory && widget.onViewDetails != null
            ? widget.onViewDetails
            : null,
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              // Left Column (Team 1)
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  _buildPlayerProfile(widget.match.players['team1_player1'],
                      Alignment.centerLeft),
                  const SizedBox(height: 16),
                  _buildPlayerProfile(widget.match.players['team1_player2'],
                      Alignment.centerLeft),
                ],
              ),

              // Central Scoreboard
              Expanded(
                child: ScoreBoard(
                  scoring: _scoring,
                  onScoreUpdate: _updateScore,
                  isMatchComplete: _scoring.isMatchComplete,
                ),
              ),

              // Right Column (Team 2)
              Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  _buildPlayerProfile(widget.match.players['team2_player1'],
                      Alignment.centerRight),
                  const SizedBox(height: 16),
                  _buildPlayerProfile(widget.match.players['team2_player2'],
                      Alignment.centerRight),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPlayerProfile(Player? player, Alignment alignment) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      textDirection: alignment == Alignment.centerRight
          ? TextDirection.rtl
          : TextDirection.ltr,
      children: [
        CircleAvatar(
          radius: 16,
          backgroundColor: Colors.grey[200],
          backgroundImage: player?.profileImage != null
              ? AssetImage(player!.profileImage)
              : null,
          child: player?.profileImage == null
              ? const Icon(Icons.person, color: Colors.grey, size: 16)
              : null,
        ),
        const SizedBox(width: 8),
        Flexible(
          child: Text(
            player?.name ?? 'Available Slot',
            style: const TextStyle(fontSize: 12),
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import '../../../models/player.dart';

class PlayerInfo extends StatelessWidget {
  final Player player;
  final bool showRating; // Optional: Display player rating if needed
  final Alignment alignment; // Controls alignment of the display
  final double avatarSize; // Size of the avatar
  final TextStyle? nameStyle; // Customizable name text style

  const PlayerInfo({
    super.key,
    required this.player,
    this.showRating = false,
    this.alignment = Alignment.centerLeft,
    this.avatarSize = 24, // Reduced avatar size
    this.nameStyle,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      textDirection: alignment == Alignment.centerRight
          ? TextDirection.rtl
          : TextDirection.ltr,
      children: [
        // Player Avatar
        CircleAvatar(
          radius: avatarSize / 2, // Smaller avatar
          backgroundImage: player.profileImage.isNotEmpty
              ? NetworkImage(player.profileImage) // Display player image
              : const AssetImage('assets/images/default_avatar.png')
                  as ImageProvider, // Fallback image
          backgroundColor: Colors.grey[200],
          child: player.profileImage.isEmpty
              ? Text(
                  player.name.isNotEmpty
                      ? player.name[0].toUpperCase() // Show initials
                      : '',
                  style: TextStyle(
                    fontSize: avatarSize * 0.5,
                    fontWeight: FontWeight.bold,
                    color: Colors.grey[800],
                  ),
                )
              : null,
        ),

        const SizedBox(width: 6), // Reduced spacing

        // Player Name
        Flexible(
          child: Text(
            player.name,
            style: nameStyle ??
                const TextStyle(
                  fontSize: 12, // Reduced font size for compactness
                  fontWeight: FontWeight.w500,
                  color: Colors.black87,
                ),
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/app_state.dart';
import '../../services/match_maker.dart';
import '../../models/match.dart';
import '../../constants/app_constants.dart';
import 'components/match_card.dart';

class MatchView extends StatelessWidget {
  const MatchView({super.key});

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 5, // Monday to Friday
      child: Scaffold(
        backgroundColor: Colors.white,
        appBar: PreferredSize(
          preferredSize: const Size.fromHeight(48.0),
          child: AppBar(
            elevation: 0,
            backgroundColor: Colors.white,
            bottom: const TabBar(
              labelColor: Colors.blue,
              unselectedLabelColor: Colors.grey,
              indicatorColor: Colors.blue,
              tabs: [
                Tab(text: 'Monday'),
                Tab(text: 'Tuesday'),
                Tab(text: 'Wednesday'),
                Tab(text: 'Thursday'),
                Tab(text: 'Friday'),
              ],
            ),
          ),
        ),
        body: Stack(
          children: [
            const TabBarView(
              children: [
                DayMatchesView(day: 'Monday'),
                DayMatchesView(day: 'Tuesday'),
                DayMatchesView(day: 'Wednesday'),
                DayMatchesView(day: 'Thursday'),
                DayMatchesView(day: 'Friday'),
              ],
            ),
            Positioned(
              bottom: 16,
              right: 16,
              child: FloatingActionButton(
                onPressed: () => _createAutomaticMatches(context),
                backgroundColor: const Color(0xFF1A237E),
                child: const Icon(Icons.add, color: Colors.white),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _createAutomaticMatches(BuildContext context) async {
    final appState = context.read<AppState>();
    final weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
    final today = weekdays[DateTime.now().weekday - 1];

    try {
      debugPrint('Creating automatic matches for $today');

      // Create Early and Later matches
      final earlyMatches = await MatchMaker.createMatchesFromBookings(
        appState.bookings[today] ?? [],
        appState.players,
        TimeslotConstants.earlyTimeslot,
        today,
      );

      final laterMatches = await MatchMaker.createMatchesFromBookings(
        appState.bookings[today] ?? [],
        appState.players,
        TimeslotConstants.laterTimeslot,
        today,
      );

      // Refresh matches in AppState
      await appState.refreshMatches();

      if (!context.mounted) return;

      // Handle empty matches
      if (earlyMatches.isEmpty && laterMatches.isEmpty) {
        debugPrint('No matches created, showing insufficient players dialog');
        MatchMaker.showInsufficientPlayersDialog(context);
        return;
      }

      // Show success message
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
              'Created ${earlyMatches.length + laterMatches.length} matches successfully'),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      debugPrint('Error creating automatic matches: $e');
      if (!context.mounted) return;

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error creating matches: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }
}

class DayMatchesView extends StatelessWidget {
  final String day;

  const DayMatchesView({super.key, required this.day});

  @override
  Widget build(BuildContext context) {
    return Consumer<AppState>(
      builder: (context, appState, child) {
        final allMatches = appState.matches;
        final dayMatches = allMatches.where((match) {
          return match.id.toLowerCase().contains(day.toLowerCase());
        }).toList();

        return SingleChildScrollView(
          padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Early Timeslot Section
              _buildTimeslotSection(
                context,
                TimeslotConstants.earlyTimeslot,
                dayMatches
                    .where((m) => m.time == TimeslotConstants.earlyTimeslot)
                    .toList(),
                appState.bookings[day] ?? [],
              ),
              const SizedBox(height: 16),
              // Later Timeslot Section
              _buildTimeslotSection(
                context,
                TimeslotConstants.laterTimeslot,
                dayMatches
                    .where((m) => m.time == TimeslotConstants.laterTimeslot)
                    .toList(),
                appState.bookings[day] ?? [],
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildTimeslotSection(
    BuildContext context,
    String timeslot,
    List<Match> matches,
    List<Map<String, dynamic>> bookings,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header
        Text(
          timeslot,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
            color: Colors.blue,
          ),
        ),
        const SizedBox(height: 12),

        // Matches or Empty State
        if (matches.isEmpty)
          _buildEmptyState(context, timeslot, bookings)
        else
          ...matches.map((match) => Padding(
                padding: const EdgeInsets.only(bottom: 12),
                child: MatchCard(match: match),
              )),
      ],
    );
  }

  Widget _buildEmptyState(
    BuildContext context,
    String timeslot,
    List<Map<String, dynamic>> bookings,
  ) {
    final bookedPlayers = bookings
        .where((b) =>
            b['timeslot'] == timeslot ||
            b['timeslot'] == TimeslotConstants.playEither)
        .length;

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: Colors.grey.shade200),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 16),
        child: Column(
          children: [
            const Text(
              'No matches scheduled yet',
              style: TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.w500,
                color: Colors.grey,
              ),
            ),
            if (bookedPlayers > 0) ...[
              const SizedBox(height: 8),
              Text(
                '$bookedPlayers player(s) signed up',
                style: TextStyle(
                  color: Colors.grey[600],
                  fontSize: 12,
                ),
              ),
              Text(
                'Waiting for ${4 - bookedPlayers} more player(s)',
                style: const TextStyle(
                  color: Colors.blue,
                  fontSize: 12,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../models/match.dart';
import '../../../models/player.dart'; // Added Player import
import '../../../providers/app_state.dart';
import '../../../constants/app_constants.dart';
import '../components/match_card.dart'; // Added MatchCard import

class CurrentMatchesTab extends StatelessWidget {
  const CurrentMatchesTab({super.key});

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 5,
      child: Scaffold(
        appBar: PreferredSize(
          preferredSize: const Size.fromHeight(45),
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white,
              boxShadow: [
                BoxShadow(
                  color: Colors.grey.withOpacity(0.05),
                  spreadRadius: 1,
                  blurRadius: 1,
                ),
              ],
            ),
            child: const TabBar(
              labelColor: Colors.blue,
              unselectedLabelColor: Colors.grey,
              indicatorColor: Colors.blue,
              indicatorWeight: 2,
              labelStyle: TextStyle(
                fontWeight: FontWeight.w500,
                fontSize: 14,
              ),
              tabs: [
                Tab(text: 'Monday'),
                Tab(text: 'Tuesday'),
                Tab(text: 'Wednesday'),
                Tab(text: 'Thursday'),
                Tab(text: 'Friday'),
              ],
            ),
          ),
        ),
        body: const TabBarView(
          children: [
            DayMatchesView(day: 'Monday'),
            DayMatchesView(day: 'Tuesday'),
            DayMatchesView(day: 'Wednesday'),
            DayMatchesView(day: 'Thursday'),
            DayMatchesView(day: 'Friday'),
          ],
        ),
      ),
    );
  }
}

class DayMatchesView extends StatelessWidget {
  final String day;

  const DayMatchesView({super.key, required this.day});

  @override
  Widget build(BuildContext context) {
    return Consumer<AppState>(
      builder: (context, appState, child) {
        final allMatches = appState.matches;
        final dayMatches = allMatches.where((match) {
          return match.date.weekday == _getWeekdayNumber(day);
        }).toList();

        return SingleChildScrollView(
          padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Early Timeslot Section
              _buildTimeslotSection(
                context,
                TimeslotConstants.earlyTimeslot,
                dayMatches
                    .where((m) => m.time == TimeslotConstants.earlyTimeslot)
                    .toList(),
                appState.bookings[day] ?? [],
                appState.players,
              ),
              const SizedBox(height: 16),
              // Later Timeslot Section
              _buildTimeslotSection(
                context,
                TimeslotConstants.laterTimeslot,
                dayMatches
                    .where((m) => m.time == TimeslotConstants.laterTimeslot)
                    .toList(),
                appState.bookings[day] ?? [],
                appState.players,
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildTimeslotSection(
    BuildContext context,
    String timeslot,
    List<Match> matches,
    List<Map<String, dynamic>> bookings,
    List<Player> allPlayers,
  ) {
    // Get players booked for this timeslot
    final bookedPlayers = bookings
        .where((booking) =>
            booking['timeslot'] == timeslot ||
            booking['timeslot'] == TimeslotConstants.playEither)
        .toList();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Timeslot Header
        Container(
          margin: const EdgeInsets.only(bottom: 12),
          child: Text(
            timeslot,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w600,
              color: Colors.blue,
            ),
          ),
        ),

        // Show either matches or booking info
        if (matches.isNotEmpty)
          ...matches.map((match) => Padding(
                padding: const EdgeInsets.only(bottom: 12),
                child: MatchCard(match: match),
              )),

        if (matches.isEmpty)
          Card(
            elevation: 0,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
              side: BorderSide(color: Colors.grey.shade200),
            ),
            child: Padding(
              padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 16),
              child: Column(
                children: [
                  Text(
                    'No matches scheduled yet',
                    style: TextStyle(
                      color: Colors.grey[600],
                      fontSize: 14,
                    ),
                  ),
                  if (bookedPlayers.isNotEmpty) ...[
                    const SizedBox(height: 8),
                    Text(
                      '${bookedPlayers.length} player(s) signed up',
                      style: TextStyle(
                        color: Colors.grey[600],
                        fontSize: 12,
                      ),
                    ),
                    Text(
                      'Waiting for ${4 - bookedPlayers.length} more player(s)',
                      style: const TextStyle(
                        color: Colors.blue,
                        fontSize: 12,
                      ),
                    ),
                  ],
                ],
              ),
            ),
          ),
      ],
    );
  }

  int _getWeekdayNumber(String day) {
    final days = {
      'Monday': 1,
      'Tuesday': 2,
      'Wednesday': 3,
      'Thursday': 4,
      'Friday': 5,
    };
    return days[day] ?? 1;
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../providers/app_state.dart';
import '../../../models/match.dart';
import '../components/match_card.dart';

class MatchHistoryTab extends StatelessWidget {
  const MatchHistoryTab({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<AppState>(
      builder: (context, appState, child) {
        // Fetch completed matches from AppState
        final completedMatches = appState.matches
            .where((match) => match.status == MatchStatus.completed)
            .toList();

        if (completedMatches.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.history, size: 64, color: Colors.grey[400]),
                const SizedBox(height: 16),
                Text(
                  'No completed matches yet',
                  style: TextStyle(
                    color: Colors.grey[600],
                    fontSize: 16,
                  ),
                ),
              ],
            ),
          );
        }

        return ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: completedMatches.length,
          itemBuilder: (context, index) {
            final match = completedMatches[index];
            return Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: MatchCard(
                match: match,
                isHistory: true,
                onViewDetails: () => _viewMatchDetails(context, match),
              ),
            );
          },
        );
      },
    );
  }

  void _viewMatchDetails(BuildContext context, Match match) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Match Details'),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('Match ID: ${match.id}'),
                Text('Date: ${match.date}'),
                Text('Status: ${match.status.name}'),
                const SizedBox(height: 8),
                const Text(
                  'Team 1',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                Text('Sets Won: ${match.score['team1']?.sets ?? 0}'),
                Text(
                  'Games: ${match.score['team1']?.games.join(", ") ?? "N/A"}',
                ),
                const SizedBox(height: 8),
                const Text(
                  'Team 2',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                Text('Sets Won: ${match.score['team2']?.sets ?? 0}'),
                Text(
                  'Games: ${match.score['team2']?.games.join(", ") ?? "N/A"}',
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Close'),
            ),
          ],
        );
      },
    );
  }
}
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../main_dashboard/main_dashboard.dart';
import 'registration_screen.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => LoginScreenState();
}

class LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final FirebaseAuth _auth = FirebaseAuth.instance;

  bool _isLoading = false;
  String? _error;

  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final userCredential = await _auth.signInWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text.trim(),
      );

      if (!mounted) return;

      if (userCredential.user != null) {
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => const MainDashboard()),
        );
      }
    } catch (e) {
      setState(() {
        _error = 'Login failed. Please check your credentials.';
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF4285F4), Color(0xFF922790)],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
        ),
        child: Center(
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 24.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  // Logo
                  Image.asset(
                    'assets/images/padeltrax_logo.png',
                    height: 120,
                  ),
                  const SizedBox(height: 32),

                  // Welcome Text
                  const Text(
                    'Welcome Back',
                    style: TextStyle(
                      fontSize: 26,
                      fontWeight: FontWeight.bold,
                      color: Colors.white,
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Login Form
                  Form(
                    key: _formKey,
                    child: Column(
                      children: [
                        _buildTextField(
                          controller: _emailController,
                          label: 'Email',
                          icon: Icons.email,
                          validator: (value) =>
                              value == null || !value.contains('@')
                                  ? 'Enter a valid email'
                                  : null,
                        ),
                        const SizedBox(height: 16),
                        _buildTextField(
                          controller: _passwordController,
                          label: 'Password',
                          icon: Icons.lock,
                          obscureText: true,
                          validator: (value) => value == null || value.isEmpty
                              ? 'Enter your password'
                              : null,
                        ),
                        const SizedBox(height: 16),
                        if (_error != null)
                          Text(
                            _error!,
                            style: const TextStyle(
                              color: Colors.red,
                              fontSize: 14,
                            ),
                          ),
                        const SizedBox(height: 24),
                        SizedBox(
                          width: double.infinity,
                          height: 50,
                          child: ElevatedButton(
                            onPressed: _isLoading ? null : _handleLogin,
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.white,
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                            ),
                            child: _isLoading
                                ? const CircularProgressIndicator()
                                : const Text(
                                    'Login',
                                    style: TextStyle(
                                      color: Color(0xFF4285F4),
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 24),

                  // Register Text
                  TextButton(
                    onPressed: () => Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => const RegistrationScreen(),
                      ),
                    ),
                    child: const Text(
                      'Need an account? Register',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 14,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildTextField({
    required TextEditingController controller,
    required String label,
    required IconData icon,
    bool obscureText = false,
    String? Function(String?)? validator,
  }) {
    return TextFormField(
      controller: controller,
      obscureText: obscureText,
      validator: validator,
      style: const TextStyle(color: Colors.white),
      decoration: InputDecoration(
        labelText: label,
        labelStyle: const TextStyle(color: Colors.white),
        prefixIcon: Icon(icon, color: Colors.white),
        filled: true,
        fillColor: Colors.white.withOpacity(0.1),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Colors.white54),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }
}
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:typed_data';
import 'registration_form.dart';
import '../main_dashboard/main_dashboard.dart';

class RegistrationScreen extends StatefulWidget {
  const RegistrationScreen({super.key});

  @override
  State<RegistrationScreen> createState() => _RegistrationScreenState();
}

class _RegistrationScreenState extends State<RegistrationScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _nameController = TextEditingController();
  final _levelController = TextEditingController();
  final _nationalityController = TextEditingController();
  final ImagePicker _imagePicker = ImagePicker();

  String _preferredSide = 'Left';
  Uint8List? _selectedImageBytes;
  String? _error;
  final bool _isLoading = false;
  bool _isRegistering = false; // Added this variable

  Future<void> _pickImage() async {
    try {
      final XFile? result =
          await _imagePicker.pickImage(source: ImageSource.gallery);
      if (result != null) {
        final bytes = await result.readAsBytes();
        setState(() {
          _selectedImageBytes = bytes;
        });
      }
    } catch (e) {
      debugPrint('Error picking image: $e');
    }
  }

  Future<void> _handleRegistration() async {
    if (!_formKey.currentState!.validate() || _isRegistering) return;

    setState(() {
      _isRegistering = true;
      _error = null;
    });

    try {
      // Store context before async gap
      final contextBeforeAsync = context;

      // Simulate successful registration
      await Future.delayed(const Duration(seconds: 2));

      if (!mounted) return;

      Navigator.pushReplacement(
        contextBeforeAsync,
        MaterialPageRoute(builder: (context) => const MainDashboard()),
      );
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _error = 'Registration failed. Please try again.';
      });
    } finally {
      if (mounted) {
        setState(() {
          _isRegistering = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Create Account'),
        backgroundColor: const Color(0xFF4285F4),
        elevation: 0,
      ),
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF4285F4), Color(0xFF922790)],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
        ),
        child: SafeArea(
          child: Column(
            children: [
              Expanded(
                child: SingleChildScrollView(
                  padding: const EdgeInsets.all(16.0),
                  child: RegistrationForm(
                    formKey: _formKey,
                    emailController: _emailController,
                    passwordController: _passwordController,
                    nameController: _nameController,
                    levelController: _levelController,
                    nationalityController: _nationalityController,
                    preferredSide: _preferredSide,
                    onSideChanged: (value) {
                      setState(() {
                        _preferredSide = value!;
                      });
                    },
                    onImagePick: _pickImage,
                    selectedImageBytes: _selectedImageBytes,
                    error: _error,
                  ),
                ),
              ),
              Padding(
                padding:
                    const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                child: ElevatedButton.icon(
                  onPressed: _isLoading ? null : _handleRegistration,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.blue[800],
                    minimumSize: const Size(double.infinity, 50),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  icon: _isLoading
                      ? const CircularProgressIndicator(
                          color: Colors.white,
                          strokeWidth: 2,
                        )
                      : const Icon(Icons.app_registration, color: Colors.white),
                  label: Text(
                    _isLoading ? 'Registering...' : 'Register',
                    style: const TextStyle(fontSize: 16, color: Colors.white),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _nameController.dispose();
    _levelController.dispose();
    _nationalityController.dispose();
    super.dispose();
  }
}
import 'package:flutter/material.dart';
import 'dart:typed_data';

class RegistrationForm extends StatelessWidget {
  final GlobalKey<FormState> formKey;
  final TextEditingController emailController;
  final TextEditingController passwordController;
  final TextEditingController nameController;
  final TextEditingController levelController;
  final TextEditingController nationalityController;
  final String preferredSide;
  final Function(String?) onSideChanged;
  final VoidCallback onImagePick;
  final Uint8List? selectedImageBytes;
  final String? error;

  const RegistrationForm({
    super.key,
    required this.formKey,
    required this.emailController,
    required this.passwordController,
    required this.nameController,
    required this.levelController,
    required this.nationalityController,
    required this.preferredSide,
    required this.onSideChanged,
    required this.onImagePick,
    this.selectedImageBytes,
    this.error,
  });

  @override
  Widget build(BuildContext context) {
    return Form(
      key: formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          GestureDetector(
            onTap: onImagePick,
            child: CircleAvatar(
              radius: 50,
              backgroundColor: Colors.grey[300],
              backgroundImage: selectedImageBytes != null
                  ? MemoryImage(selectedImageBytes!)
                  : null,
              child: selectedImageBytes == null
                  ? const Icon(Icons.camera_alt, size: 40, color: Colors.grey)
                  : null,
            ),
          ),
          const SizedBox(height: 24),
          _buildInputField(
            controller: nameController,
            label: 'Full Name',
            icon: Icons.person,
            validator: (value) => value == null || value.isEmpty
                ? 'Please enter your name'
                : null,
          ),
          const SizedBox(height: 16),
          _buildInputField(
            controller: emailController,
            label: 'Email',
            icon: Icons.email,
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter your email';
              }
              if (!value.contains('@')) return 'Please enter a valid email';
              return null;
            },
          ),
          const SizedBox(height: 16),
          _buildInputField(
            controller: passwordController,
            label: 'Password',
            icon: Icons.lock,
            obscureText: true,
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter a password';
              }
              if (value.length < 6) {
                return 'Password must be at least 6 characters';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          _buildInputField(
            controller: levelController,
            label: 'Current Level (1-5)',
            icon: Icons.stars,
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter your current level';
              }
              final level = double.tryParse(value);
              if (level == null || level < 1 || level > 5) {
                return 'Enter a valid level between 1 and 5';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          _buildInputField(
            controller: nationalityController,
            label: 'Nationality',
            icon: Icons.flag,
            validator: (value) => value == null || value.isEmpty
                ? 'Please enter your nationality'
                : null,
          ),
          const SizedBox(height: 16),
          DropdownButtonFormField<String>(
            value: preferredSide,
            decoration: InputDecoration(
              labelText: 'Preferred Side',
              labelStyle: const TextStyle(color: Colors.white),
              filled: true,
              fillColor: Colors.white.withOpacity(0.1),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
                borderSide:
                    const BorderSide(color: Colors.white), // Updated to white
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
                borderSide:
                    const BorderSide(color: Colors.white), // Updated to white
              ),
              prefixIcon: const Icon(Icons.sports_tennis, color: Colors.white),
            ),
            items: const [
              DropdownMenuItem(value: 'Left', child: Text('Left')),
              DropdownMenuItem(value: 'Right', child: Text('Right')),
              DropdownMenuItem(value: 'Both', child: Text('Both')),
            ],
            onChanged: onSideChanged,
          ),
          if (error != null) ...[
            const SizedBox(height: 24),
            Text(
              error!,
              style: const TextStyle(color: Colors.red),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInputField({
    required TextEditingController controller,
    required String label,
    required IconData icon,
    String? Function(String?)? validator,
    bool obscureText = false,
  }) {
    return TextFormField(
      controller: controller,
      obscureText: obscureText,
      style: const TextStyle(color: Colors.white),
      validator: validator,
      decoration: InputDecoration(
        labelText: label,
        labelStyle: const TextStyle(color: Colors.white),
        prefixIcon: Icon(icon, color: Colors.white),
        filled: true,
        fillColor: Colors.white.withOpacity(0.1),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Colors.white), // Updated to white
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Colors.white), // Updated to white
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Colors.white), // Updated to white
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/app_state.dart';
import '../../models/player.dart';

class TableTabs extends StatelessWidget {
  const TableTabs({super.key});

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 2,
      child: Scaffold(
        appBar: AppBar(
          flexibleSpace: const _CustomTabBar(),
          backgroundColor: Colors.transparent,
          elevation: 0,
        ),
        body: Consumer<AppState>(
          builder: (context, appState, child) {
            return TabBarView(
              children: [
                StandingsView(players: appState.players),
                MatchStatisticsView(players: appState.players),
              ],
            );
          },
        ),
      ),
    );
  }
}

class _CustomTabBar extends StatelessWidget {
  const _CustomTabBar();

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        border: Border(
          bottom: BorderSide(color: Colors.grey.shade200),
        ),
      ),
      child: TabBar(
        indicatorWeight: 3,
        indicatorSize: TabBarIndicatorSize.tab,
        indicatorColor: Theme.of(context).primaryColor,
        labelColor: Theme.of(context).primaryColor,
        unselectedLabelColor: Colors.grey.shade600,
        labelStyle: const TextStyle(
          fontSize: 15,
          fontWeight: FontWeight.w600,
        ),
        tabs: const [
          Tab(text: 'Standings'),
          Tab(text: 'Statistics'),
        ],
      ),
    );
  }
}

class StandingsView extends StatelessWidget {
  final List<Player> players;

  const StandingsView({super.key, required this.players});

  Color _getRankColor(int rank) {
    if (rank <= 15) return const Color(0xFF1A237E);
    if (rank <= 30) return const Color(0xFF1E88E5);
    if (rank <= 50) return const Color(0xFFFFA000);
    if (rank <= 70) return const Color(0xFF43A047);
    if (rank <= 90) return const Color(0xFFF57C00);
    return const Color(0xFFD32F2F);
  }

  @override
  Widget build(BuildContext context) {
    final sortedPlayers = List<Player>.from(players)
      ..sort((a, b) => b.statistics.rating.compareTo(a.statistics.rating));

    return Column(
      children: [
        _buildHeader(),
        Expanded(
          child: ListView.separated(
            padding: const EdgeInsets.only(top: 2, bottom: 8),
            itemCount: sortedPlayers.length,
            separatorBuilder: (context, index) => const SizedBox(height: 2),
            itemBuilder: (context, index) {
              final player = sortedPlayers[index];
              final rank = index + 1;
              return _buildPlayerRow(rank, player);
            },
          ),
        ),
      ],
    );
  }

  Widget _buildHeader() {
    return Container(
      color: Colors.grey.shade100,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Row(
        children: [
          const SizedBox(width: 36), // Space for rank
          const Expanded(
            flex: 3,
            child: Text(
              'PLAYER',
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w600,
                letterSpacing: 1,
              ),
            ),
          ),
          ..._buildHeaderItem('PTS'),
          ..._buildHeaderItem('PLY'),
          ..._buildHeaderItem('W'),
          ..._buildHeaderItem('D'),
          ..._buildHeaderItem('L'),
          ..._buildHeaderItem('SW'),
          ..._buildHeaderItem('SL'),
        ],
      ),
    );
  }

  List<Widget> _buildHeaderItem(String text) {
    return [
      const SizedBox(width: 8),
      SizedBox(
        width: 32,
        child: Text(
          text,
          textAlign: TextAlign.center,
          style: const TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.w600,
            letterSpacing: 1,
          ),
        ),
      ),
      const SizedBox(width: 8),
    ];
  }

  Widget _buildPlayerRow(int rank, Player player) {
    return Material(
      color: Colors.white,
      child: InkWell(
        onTap: () {}, // Handle player selection
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            children: [
              _buildRankBadge(rank),
              const SizedBox(width: 12),
              Expanded(
                flex: 3,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      player.name,
                      style: const TextStyle(
                        fontWeight: FontWeight.w500,
                        fontSize: 14,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),
                    _buildFormIndicators(player),
                  ],
                ),
              ),
              ..._buildStatItem(player.statistics.rating.toStringAsFixed(0)),
              ..._buildStatItem(player.statistics.totalMatches.toString(),
                  isBold: true),
              ..._buildStatItem(player.statistics.wins.toString()),
              ..._buildStatItem(player.statistics.draws.toString()),
              ..._buildStatItem(player.statistics.losses.toString()),
              ..._buildStatItem(player.statistics.setsWon.toString()),
              ..._buildStatItem(player.statistics.setsLost.toString()),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildFormIndicators(Player player) {
    // Only show results if player has played matches
    if (player.statistics.totalMatches == 0) {
      return const SizedBox(height: 12); // Maintain consistent row height
    }

    // This should come from player match history data
    List<String> recentResults = [];

    // Here we should actually check the match results
    if (player.statistics.wins > 0) {
      recentResults.add('W');
    } else if (player.statistics.draws > 0) {
      recentResults.add('D');
    } else if (player.statistics.losses > 0) {
      recentResults.add('L');
    }

    return Row(
      children: recentResults
          .map((result) => Container(
                width: 16,
                height: 16,
                margin: const EdgeInsets.only(right: 4),
                decoration: BoxDecoration(
                  color: _getResultColor(result),
                  borderRadius: BorderRadius.circular(2),
                ),
                child: Center(
                  child: Text(
                    result,
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ))
          .toList(),
    );
  }

  Color _getResultColor(String result) {
    switch (result) {
      case 'W':
        return const Color(0xFF4CAF50); // Green
      case 'D':
        return const Color(0xFFFF9800); // Orange
      case 'L':
        return const Color(0xFFF44336); // Red
      default:
        return Colors.grey;
    }
  }

  List<Widget> _buildStatItem(String value, {bool isBold = false}) {
    return [
      const SizedBox(width: 8),
      SizedBox(
        width: 32,
        child: Text(
          value,
          textAlign: TextAlign.center,
          style: TextStyle(
            fontSize: 14,
            fontWeight: isBold ? FontWeight.w600 : null,
          ),
        ),
      ),
      const SizedBox(width: 8),
    ];
  }

  Widget _buildRankBadge(int rank) {
    final color = _getRankColor(rank);
    return Container(
      width: 24,
      height: 24,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: color,
      ),
      child: Center(
        child: Text(
          rank.toString(),
          style: const TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.bold,
            fontSize: 12,
          ),
        ),
      ),
    );
  }
}

class MatchStatisticsView extends StatelessWidget {
  final List<Player> players;

  const MatchStatisticsView({super.key, required this.players});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Text(
        'Match Statistics Coming Soon',
        style: TextStyle(
          color: Colors.grey.shade600,
          fontSize: 16,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import '../../models/player.dart';

class FormView extends StatelessWidget {
  final List<Player> players;

  const FormView({super.key, required this.players});

  Color getRankColor(int rank) {
    if (rank >= 1 && rank <= 15) return Colors.blue.shade900;
    if (rank >= 16 && rank <= 30) return Colors.blue.shade300;
    if (rank >= 31 && rank <= 50) return Colors.amber;
    if (rank >= 51 && rank <= 70) return Colors.green;
    if (rank >= 71 && rank <= 90) return Colors.orange;
    return Colors.red;
  }

  @override
  Widget build(BuildContext context) {
    final sortedPlayers = List<Player>.from(players)
      ..sort((a, b) => a.statistics.rating.compareTo(b.statistics.rating));

    return Column(
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          color: Colors.grey.shade100,
          child: const Row(
            children: [
              Expanded(
                child: Text(
                  'Padeltrax S League',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
              ),
              SizedBox(
                  width: 80,
                  child: Text('Rating',
                      style: TextStyle(fontWeight: FontWeight.bold))),
              SizedBox(
                  width: 120,
                  child: Text('Form',
                      style: TextStyle(fontWeight: FontWeight.bold))),
            ],
          ),
        ),
        Expanded(
          child: ListView.builder(
            itemCount: sortedPlayers.length,
            itemBuilder: (context, index) {
              final player = sortedPlayers[index];
              return InkWell(
                onTap: () => _showPlayerStats(context, player),
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    border:
                        Border(bottom: BorderSide(color: Colors.grey.shade200)),
                  ),
                  child: Row(
                    children: [
                      _buildRankBadge(index + 1),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Row(
                          children: [
                            player.avatar(size: 32),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    player.name,
                                    style: const TextStyle(
                                        fontWeight: FontWeight.bold),
                                  ),
                                  Text(
                                    '${player.statistics.wins}W ${player.statistics.draws}D ${player.statistics.losses}L',
                                    style: TextStyle(
                                      fontSize: 12,
                                      color: Colors.grey.shade600,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                      SizedBox(
                        width: 80,
                        child: Text(
                          player.statistics.rating.toStringAsFixed(2),
                          style: const TextStyle(fontWeight: FontWeight.bold),
                        ),
                      ),
                      SizedBox(
                        width: 120,
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children:
                              player.statistics.recentMatches.map((result) {
                            return Container(
                              width: 22,
                              height: 22,
                              margin: const EdgeInsets.only(left: 2),
                              alignment: Alignment.center,
                              decoration: BoxDecoration(
                                color: _getResultColor(result),
                                borderRadius: BorderRadius.circular(4),
                              ),
                              child: Text(
                                result,
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontWeight: FontWeight.bold,
                                  fontSize: 12,
                                ),
                              ),
                            );
                          }).toList(),
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildRankBadge(int rank) {
    return Container(
      width: 32,
      height: 32,
      alignment: Alignment.center,
      decoration: BoxDecoration(
        color: getRankColor(rank),
        shape: BoxShape.circle,
      ),
      child: Text(
        rank.toString(),
        style: const TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  Color _getResultColor(String result) {
    switch (result) {
      case 'W':
        return Colors.green;
      case 'D':
        return Colors.orange;
      case 'L':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }

  void _showPlayerStats(BuildContext context, Player player) {
    showModalBottomSheet(
      context: context,
      builder: (context) => _PlayerStatsSheet(player: player),
    );
  }
}

class _PlayerStatsSheet extends StatelessWidget {
  final Player player;

  const _PlayerStatsSheet({required this.player});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              player.avatar(size: 48),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(player.name,
                        style: const TextStyle(
                            fontSize: 18, fontWeight: FontWeight.bold)),
                    Text(
                        'Rating: ${player.statistics.rating.toStringAsFixed(2)}',
                        style: TextStyle(color: Colors.blue.shade700)),
                  ],
                ),
              ),
            ],
          ),
          const Divider(height: 32),
          Wrap(
            spacing: 16,
            runSpacing: 16,
            children: [
              _buildStatItem(
                  'Matches', player.statistics.totalMatches.toString()),
              _buildStatItem('Wins', player.statistics.wins.toString()),
              _buildStatItem('Win Rate',
                  '${player.statistics.winRate.toStringAsFixed(1)}%'),
              _buildStatItem('Current Streak',
                  _formatStreak(player.statistics.currentStreak)),
              _buildStatItem('Sets Won', player.statistics.setsWon.toString()),
              _buildStatItem(
                  'Games Won', player.statistics.gamesWon.toString()),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(label,
              style: TextStyle(color: Colors.grey.shade600, fontSize: 12)),
          const SizedBox(height: 4),
          Text(value, style: const TextStyle(fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }

  String _formatStreak(int streak) {
    if (streak == 0) return '0';
    if (streak > 0) return '+$streak';
    return streak.toString();
  }
}
import 'package:flutter/material.dart';
import '../../models/player.dart';

class StandingsView extends StatelessWidget {
  final List<Player> players;

  const StandingsView({super.key, required this.players});

  @override
  Widget build(BuildContext context) {
    final sortedPlayers = List<Player>.from(players)
      ..sort((a, b) => b.statistics.rating.compareTo(a.statistics.rating));

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            // Top Navigation Bar with Back Button
            Padding(
              padding:
                  const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
              child: Row(
                children: [
                  IconButton(
                    icon: const Icon(Icons.arrow_back, color: Colors.blue),
                    onPressed: () => Navigator.pop(context),
                  ),
                  const Text(
                    'Standings',
                    style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                      color: Colors.blue,
                    ),
                  ),
                ],
              ),
            ),

            // Stats Header
            _StatsHeader(),

            // Player List
            Expanded(
              child: ListView.builder(
                itemCount: sortedPlayers.length,
                itemBuilder: (context, index) {
                  final player = sortedPlayers[index];
                  return _PlayerRow(
                    player: player,
                    rank: index + 1,
                    isEven: index.isEven,
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _PlayerRow extends StatelessWidget {
  final Player player;
  final int rank;
  final bool isEven;

  const _PlayerRow({
    required this.player,
    required this.rank,
    required this.isEven,
  });

  Color _getRankColor() {
    if (rank <= 3) return Colors.blue.shade700;
    if (rank <= 10) return Colors.green.shade700;
    return Colors.grey.shade600;
  }

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;

    return Container(
      decoration: BoxDecoration(
        color: isEven ? Colors.grey.shade50 : Colors.white,
        border: Border(
          bottom: BorderSide(color: Colors.grey.shade200),
        ),
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () {
            // Future placeholder for player details if needed
          },
          child: Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            child: Row(
              children: [
                // Rank Circle and Player Info
                SizedBox(
                  width: screenWidth * 0.4,
                  child: Row(
                    children: [
                      // Rank Circle
                      Container(
                        width: 24,
                        height: 24,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: _getRankColor(),
                        ),
                        child: Center(
                          child: Text(
                            rank.toString(),
                            style: const TextStyle(
                              color: Colors.white,
                              fontWeight: FontWeight.bold,
                              fontSize: 12,
                            ),
                          ),
                        ),
                      ),
                      const SizedBox(width: 8),
                      // Player Avatar and Name
                      CircleAvatar(
                        radius: 12,
                        backgroundImage: player.profileImage.isNotEmpty
                            ? NetworkImage(player.profileImage)
                            : null,
                        child: player.profileImage.isEmpty
                            ? const Icon(Icons.person, size: 12)
                            : null,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          player.name,
                          style: const TextStyle(
                            fontWeight: FontWeight.w500,
                            fontSize: 12,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                    ],
                  ),
                ),

                // Player Stats
                Expanded(
                  child: Row(
                    children: [
                      _buildStatColumn(
                          'PTS', player.statistics.rating.toStringAsFixed(0)),
                      _buildVerticalDivider(),
                      _buildStatColumn(
                          'PLY', player.statistics.totalMatches.toString()),
                      _buildVerticalDivider(),
                      _buildStatColumn('W', player.statistics.wins.toString(),
                          textColor:
                              player.statistics.wins > 0 ? Colors.green : null),
                      _buildVerticalDivider(),
                      _buildStatColumn('L', player.statistics.losses.toString(),
                          textColor:
                              player.statistics.losses > 0 ? Colors.red : null),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildVerticalDivider() {
    return Container(
      width: 1,
      height: double.infinity,
      color: Colors.grey.shade300,
    );
  }

  Widget _buildStatColumn(String label, String value, {Color? textColor}) {
    return Expanded(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            value,
            style: TextStyle(
              fontSize: 13,
              fontWeight: FontWeight.bold,
              color: textColor ?? Colors.grey.shade800,
            ),
          ),
          Text(
            label,
            style: const TextStyle(
              fontSize: 10,
              color: Colors.grey,
            ),
          ),
        ],
      ),
    );
  }
}

class _StatsHeader extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;

    return Container(
      height: 40,
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        border: Border(
          bottom: BorderSide(color: Colors.grey.shade300),
        ),
      ),
      child: Row(
        children: [
          // Player header
          SizedBox(
            width: screenWidth * 0.4,
            child: const Padding(
              padding: EdgeInsets.only(left: 8.0),
              child: Text(
                'Player',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 13,
                ),
              ),
            ),
          ),

          // Stats headers
          Expanded(
            child: Row(
              children: [
                _buildHeaderColumn('PTS'),
                _buildVerticalDivider(),
                _buildHeaderColumn('PLY'),
                _buildVerticalDivider(),
                _buildHeaderColumn('W'),
                _buildVerticalDivider(),
                _buildHeaderColumn('L'),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHeaderColumn(String label) {
    return Expanded(
      child: Center(
        child: Text(
          label,
          style: const TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 12,
          ),
        ),
      ),
    );
  }

  Widget _buildVerticalDivider() {
    return Container(
      width: 1,
      height: double.infinity,
      color: Colors.grey.shade300,
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/app_state.dart';
import '../../models/player.dart';
import '../../theme/theme.dart';
import 'booking_details_page.dart';

class BookingsPage extends StatefulWidget {
  const BookingsPage({super.key});

  @override
  State<BookingsPage> createState() => _BookingsPageState();
}

class _BookingsPageState extends State<BookingsPage> {
  String _sortOrder = 'Alphabetical'; // Default sorting order

  @override
  Widget build(BuildContext context) {
    return Consumer<AppState>(
      builder: (context, appState, child) {
        if (appState.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }

        if (appState.players.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.person_off, size: 64, color: Colors.grey),
                const SizedBox(height: 16),
                const Text(
                  'No players available',
                  style: TextStyle(color: Colors.grey),
                ),
                const SizedBox(height: 24),
                ElevatedButton.icon(
                  onPressed: appState.initializeStreams,
                  icon: const Icon(Icons.refresh),
                  label: const Text('Refresh'),
                ),
              ],
            ),
          );
        }

        // Sort players based on the selected order
        List<Player> sortedPlayers = List.from(appState.players);
        if (_sortOrder == 'Alphabetical') {
          sortedPlayers.sort((a, b) => a.name.compareTo(b.name));
        } else if (_sortOrder == 'Position') {
          sortedPlayers.sort((a, b) => a.rank.compareTo(b.rank));
        }

        return Scaffold(
          appBar: AppBar(
            backgroundColor: Colors.transparent,
            elevation: 0,
            flexibleSpace: Container(
              decoration: const BoxDecoration(
                gradient: LinearGradient(
                  colors: [AppTheme.primaryColor, AppTheme.secondaryColor],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
              ),
            ),
            title: Row(
              children: [
                Padding(
                  padding: const EdgeInsets.only(right: 8.0),
                  child: Image.asset(
                    'assets/images/padeltrax_logo.png',
                    height: 36, // Adjust the logo height
                    fit:
                        BoxFit.contain, // Ensure the logo scales proportionally
                  ),
                ),
                const Text(
                  'Bookings',
                  style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
              ],
            ),
            actions: [
              DropdownButton<String>(
                value: _sortOrder,
                dropdownColor: AppTheme.secondaryColor,
                style: const TextStyle(color: Colors.white),
                underline: const SizedBox(),
                onChanged: (value) {
                  setState(() {
                    _sortOrder = value!;
                  });
                },
                items: const [
                  DropdownMenuItem(
                    value: 'Alphabetical',
                    child: Text('Alphabetical'),
                  ),
                  DropdownMenuItem(
                    value: 'Position',
                    child: Text('Position'),
                  ),
                ],
              ),
            ],
          ),
          body: Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
                colors: [AppTheme.primaryColor, AppTheme.secondaryColor],
              ),
            ),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: RefreshIndicator(
                onRefresh: () async {
                  appState.initializeStreams();
                },
                child: GridView.builder(
                  gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                    crossAxisCount: 2, // Number of columns
                    childAspectRatio: 3.5, // Adjust for compact cards
                    crossAxisSpacing: 16,
                    mainAxisSpacing: 16,
                  ),
                  itemCount: sortedPlayers.length,
                  itemBuilder: (context, index) {
                    return buildPlayerCard(context, sortedPlayers[index]);
                  },
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget buildPlayerCard(BuildContext context, Player player) {
    return GestureDetector(
      onTap: () => _navigateToBookingDetails(context, player),
      child: Container(
        decoration: BoxDecoration(
          color: Colors.white.withOpacity(0.9),
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Row(
          children: [
            const SizedBox(width: 8),
            CircleAvatar(
              radius: 20,
              backgroundColor: Colors.grey[300],
              backgroundImage: player.profileImage.isNotEmpty
                  ? NetworkImage(player.profileImage)
                  : const AssetImage('assets/images/profile.png')
                      as ImageProvider<Object>?,
              onBackgroundImageError: (_, __) {
                debugPrint('Error loading profile image for ${player.name}');
              },
              child: player.profileImage.isEmpty
                  ? const Icon(Icons.person, color: Colors.grey)
                  : null,
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Text(
                player.name,
                style: const TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.bold,
                  color: Colors.black,
                ),
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _navigateToBookingDetails(
      BuildContext context, Player player) async {
    try {
      final updatedPlayer = await Navigator.push<Player?>(
        context,
        MaterialPageRoute(
          builder: (context) => BookingDetailsPage(player: player),
        ),
      );

      if (updatedPlayer != null && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Bookings updated successfully'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating bookings: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/player.dart';
import '../../providers/app_state.dart';
import '../../theme/theme.dart';
import '../../constants/app_constants.dart';

class BookingDetailsPage extends StatefulWidget {
  final Player player;

  const BookingDetailsPage({
    super.key,
    required this.player,
  });

  @override
  State<BookingDetailsPage> createState() => _BookingDetailsPageState();
}

class _BookingDetailsPageState extends State<BookingDetailsPage> {
  final Map<String, String> _selectedTimeslots = {};
  bool _isSaving = false;
  bool _hasChanges = false;
  late final AppState _appState;

  @override
  void initState() {
    super.initState();
    _initializeTimeslots();
    _appState = context.read<AppState>();
  }

  void _initializeTimeslots() {
    setState(() {
      _selectedTimeslots.clear();
      _selectedTimeslots.addAll(widget.player.signedTimeslots);
    });
  }

  void _updateTimeslot(String day, String? newTimeslot) {
    setState(() {
      if (newTimeslot == null || newTimeslot.isEmpty) {
        _selectedTimeslots.remove(day);
      } else {
        _selectedTimeslots[day] = newTimeslot;
      }
      _hasChanges = true;
    });
  }

  Future<void> _handleSave() async {
    if (_isSaving) return;

    setState(() {
      _isSaving = true;
    });

    try {
      final messenger = ScaffoldMessenger.of(context);
      final navigator = Navigator.of(context);

      // Delete existing bookings
      await _appState.deletePlayerBookings(widget.player.id);

      // Create new bookings
      for (final entry in _selectedTimeslots.entries) {
        await _appState.createBooking(
          widget.player.id,
          entry.key,
          entry.value,
        );
      }

      // Sync all data
      await _appState.syncAllData();

      // Update local player state
      widget.player.signedTimeslots.clear();
      widget.player.signedTimeslots.addAll(_selectedTimeslots);

      if (!mounted) return;

      messenger.showSnackBar(
        const SnackBar(
          content: Text('Bookings saved successfully'),
          backgroundColor: Colors.green,
        ),
      );

      setState(() {
        _hasChanges = false;
      });

      navigator.pop(widget.player);
    } catch (e) {
      debugPrint('Error saving bookings: $e');
      if (!mounted) return;

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error saving bookings: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSaving = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      onWillPop: () async {
        if (_hasChanges) {
          final shouldPop = await showDialog<bool>(
            context: context,
            builder: (context) => AlertDialog(
              title: const Text('Discard Changes?'),
              content: const Text(
                  'You have unsaved changes. Do you want to discard them?'),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(false),
                  child: const Text('CANCEL'),
                ),
                TextButton(
                  onPressed: () => Navigator.of(context).pop(true),
                  child: const Text('DISCARD'),
                ),
              ],
            ),
          );

          return shouldPop ?? false;
        }

        return true;
      },
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Manage Bookings'),
          actions: [
            if (_hasChanges)
              IconButton(
                icon: const Icon(Icons.restore),
                onPressed: _initializeTimeslots,
                tooltip: 'Reset Changes',
              ),
          ],
        ),
        body: Stack(
          children: [
            Column(
              children: [
                // Player Info Card
                Card(
                  margin: const EdgeInsets.all(16),
                  child: ListTile(
                    leading: CircleAvatar(
                      backgroundImage: widget.player.profileImage.isNotEmpty
                          ? NetworkImage(widget.player.profileImage)
                          : null,
                      child: widget.player.profileImage.isEmpty
                          ? Text(widget.player.name[0].toUpperCase())
                          : null,
                    ),
                    title: Text(
                      widget.player.name,
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 18,
                      ),
                    ),
                    subtitle: Text(
                      'Rating: ${widget.player.rating.toStringAsFixed(1)}',
                      style: TextStyle(
                        color: Theme.of(context).primaryColor,
                      ),
                    ),
                  ),
                ),

                // Bookings Section
                Expanded(
                  child: ListView(
                    padding: const EdgeInsets.all(16),
                    children: [
                      const Text(
                        'Select your available timeslots:',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 16),
                      ..._buildDaySelections(),
                    ],
                  ),
                ),

                // Save Button
                Container(
                  padding: const EdgeInsets.all(16),
                  child: Row(
                    children: [
                      Expanded(
                        child: ElevatedButton(
                          onPressed:
                              (_hasChanges && !_isSaving) ? _handleSave : null,
                          style: ElevatedButton.styleFrom(
                            padding: const EdgeInsets.symmetric(vertical: 16),
                            backgroundColor: AppTheme.primaryColor,
                            foregroundColor: Colors.white,
                          ),
                          child: _isSaving
                              ? const SizedBox(
                                  height: 20,
                                  width: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                    valueColor: AlwaysStoppedAnimation<Color>(
                                        Colors.white),
                                  ),
                                )
                              : const Text(
                                  'SAVE BOOKINGS',
                                  style: TextStyle(
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            if (_isSaving)
              Container(
                color: Colors.black.withOpacity(0.3),
                child: const Center(
                  child: CircularProgressIndicator(),
                ),
              ),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildDaySelections() {
    final days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
    return days.map((day) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(day),
          const SizedBox(height: 8),
          Row(
            children: [
              _buildTimeSlotButton(
                day,
                TimeslotConstants.earlyTimeslot,
                _selectedTimeslots[day] == TimeslotConstants.earlyTimeslot,
              ),
              const SizedBox(width: 8),
              _buildTimeSlotButton(
                day,
                TimeslotConstants.laterTimeslot,
                _selectedTimeslots[day] == TimeslotConstants.laterTimeslot,
              ),
              const SizedBox(width: 8),
              _buildTimeSlotButton(
                day,
                TimeslotConstants.playEither,
                _selectedTimeslots[day] == TimeslotConstants.playEither,
              ),
            ],
          ),
          const SizedBox(height: 16),
        ],
      );
    }).toList();
  }

  Widget _buildTimeSlotButton(String day, String timeslot, bool isSelected) {
    return Expanded(
      child: GestureDetector(
        onTap: () {
          _updateTimeslot(day, isSelected ? null : timeslot);
        },
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 12),
          decoration: BoxDecoration(
            color: isSelected ? AppTheme.primaryColor : Colors.grey[200],
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: isSelected ? AppTheme.primaryColor : Colors.grey[400]!,
            ),
          ),
          child: Text(
            timeslot,
            textAlign: TextAlign.center,
            style: TextStyle(
              color: isSelected ? Colors.white : Colors.black87,
              fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
            ),
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'main_dashboard/main_dashboard.dart';

class StartingPage extends StatelessWidget {
  const StartingPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Theme.of(context)
          .scaffoldBackgroundColor, // Use theme background color
      body: SafeArea(
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Logo
              Image.asset(
                'assets/images/padeltrax_logo.png',
                width: 200,
                height: 200,
              ),
              const SizedBox(height: 20),
              Text(
                'Welcome to Padeltrax',
                style:
                    Theme.of(context).textTheme.displayLarge, // Use theme style
              ),
              const SizedBox(height: 40),
              ElevatedButton(
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => const MainDashboard(),
                    ),
                  );
                },
                child: Text(
                  'Start Playing',
                  style: Theme.of(context)
                      .textTheme
                      .labelLarge, // Use labelLarge from theme
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/app_state.dart';
import '../../models/player.dart';

class SchedulePage extends StatefulWidget {
  const SchedulePage({super.key});

  @override
  SchedulePageState createState() => SchedulePageState();
}

class SchedulePageState extends State<SchedulePage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final List<String> _days = [
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday'
  ];

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: _days.length, vsync: this);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadAllBookings();
    });
    _tabController.addListener(() {
      if (_tabController.indexIsChanging) {
        _loadBookingsForCurrentDay();
      }
    });
  }

  void _loadAllBookings() {
    if (!mounted) return;
    final appState = context.read<AppState>();
    for (final day in _days) {
      appState.loadBookingsForDay(day);
    }
  }

  void _loadBookingsForCurrentDay() {
    if (!mounted) return;
    final currentDay = _days[_tabController.index];
    context.read<AppState>().loadBookingsForDay(currentDay);
  }

  Widget buildTimeSlotColumn(
    String title,
    List<Map<String, dynamic>> bookings,
    List<Player> players,
    String timeslot,
  ) {
    final timeSlotBookings = bookings.where((b) {
      final bookingTimeslot = b['timeslot'] as String?;
      return bookingTimeslot == timeslot || bookingTimeslot == 'Play Either';
    }).toList();

    return Expanded(
      child: Card(
        elevation: 2,
        margin: const EdgeInsets.all(8),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.blue.shade700,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(4),
                  topRight: Radius.circular(4),
                ),
              ),
              child: Text(
                title,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
            ),
            if (timeSlotBookings.isEmpty)
              const Padding(
                padding: EdgeInsets.all(16),
                child: Text(
                  'No players signed up for this timeslot.',
                  style: TextStyle(
                    color: Colors.grey,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              )
            else
              Expanded(
                child: ListView.builder(
                  itemCount: timeSlotBookings.length,
                  itemBuilder: (context, index) {
                    final booking = timeSlotBookings[index];
                    final player = players.firstWhere(
                      (p) => p.id == booking['playerId'],
                      orElse: () => Player(
                        id: 'unknown',
                        name: 'Unknown Player',
                        rating: 0,
                        rank: 0,
                        profileImage: 'assets/images/profile.png',
                        createdAt: DateTime.now(),
                      ),
                    );

                    return ListTile(
                      leading: player.avatar(size: 40),
                      title: Text(player.name),
                      subtitle: Text(
                        booking['timeslot'] == 'Play Either'
                            ? 'Available for both timeslots'
                            : 'Rating: ${player.rating}',
                      ),
                    );
                  },
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget buildDaySchedule(String day, AppState appState) {
    final dayBookings = appState.bookings[day] ?? [];

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                buildTimeSlotColumn(
                  'Early Timeslot',
                  dayBookings,
                  appState.players,
                  'Early Timeslot',
                ),
                buildTimeSlotColumn(
                  'Later Timeslot',
                  dayBookings,
                  appState.players,
                  'Later Timeslot',
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Schedule'),
        bottom: TabBar(
          controller: _tabController,
          tabs: _days.map((day) => Tab(text: day)).toList(),
          isScrollable: true,
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadAllBookings,
          ),
        ],
      ),
      body: Consumer<AppState>(
        builder: (context, appState, child) {
          if (appState.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }

          return TabBarView(
            controller: _tabController,
            children: _days.map((day) {
              return buildDaySchedule(day, appState);
            }).toList(),
          );
        },
      ),
    );
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../booking/bookings_page.dart';
import '../table/table_tabs.dart';
import '../schedule/schedule_page.dart';
import '../match/match_view.dart';
import '../../services/auth_service.dart';
import '../auth/login_screen.dart';
import '../../providers/app_state.dart';

class MainDashboard extends StatefulWidget {
  const MainDashboard({super.key});

  @override
  State<MainDashboard> createState() => _MainDashboardState();
}

class _MainDashboardState extends State<MainDashboard> {
  int _selectedIndex = 0;
  final AuthService _authService = AuthService();
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    // Initialize AppState streams when dashboard is created
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<AppState>().initializeStreams();
    });
  }

  @override
  Widget build(BuildContext context) {
    final appState = context.watch<AppState>();

    // Define the main screens
    final List<Widget> screens = [
      const BookingsPage(),
      const TableTabs(),
      const SchedulePage(),
      const MatchView(),
    ];

    return Scaffold(
      body: Stack(
        children: [
          screens[_selectedIndex], // Display the selected screen
          if (appState.isLoading || _isLoading)
            Container(
              color: Colors.black54,
              child: const Center(
                child: CircularProgressIndicator(),
              ),
            ),
        ],
      ),
      bottomNavigationBar: BottomNavigationBar(
        items: const <BottomNavigationBarItem>[
          BottomNavigationBarItem(
            icon: Icon(Icons.calendar_today),
            label: 'Bookings',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.table_chart),
            label: 'Table',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.schedule),
            label: 'Schedule',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.sports_tennis),
            label: 'Match Day',
          ),
        ],
        currentIndex: _selectedIndex,
        selectedItemColor: Colors.blue,
        unselectedItemColor: Colors.grey,
        showUnselectedLabels: true,
        type: BottomNavigationBarType.fixed,
        onTap: _handleNavigation,
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: appState.initializeStreams,
        tooltip: 'Refresh',
        child: const Icon(Icons.refresh),
      ),
    );
  }

  void _handleNavigation(int index) {
    setState(() {
      _selectedIndex = index;
    });

    final appState = context.read<AppState>();
    switch (index) {
      case 0: // Bookings
        appState.initializeStreams();
        break;
      case 1: // Table
        appState.initializeStreams();
        break;
      case 2: // Schedule
        final weekdays = [
          'Monday',
          'Tuesday',
          'Wednesday',
          'Thursday',
          'Friday'
        ];
        for (var day in weekdays) {
          appState.loadBookingsForDay(day);
        }
        break;
      case 3: // Match Day
        appState.refreshMatches();
        break;
    }
  }

  Future<void> _handleLogout() async {
    try {
      setState(() => _isLoading = true);

      await FirebaseAuth.instance.signOut();
      await _authService.signOut();

      if (!mounted) return;

      Navigator.of(context).pushAndRemoveUntil(
        MaterialPageRoute(builder: (context) => const LoginScreen()),
        (Route<dynamic> route) => false,
      );
    } catch (e) {
      if (!mounted) return;

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error logging out: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';

class UserModel {
  final String id;
  final String email;
  final String name;
  final double level;
  final String nationality;
  final String preferredSide;
  final String? profileImageUrl;
  final bool isAdmin;
  final bool isLevelVerified;
  final DateTime createdAt;
  final DateTime? lastLoginAt;

  UserModel({
    required this.id,
    required this.email,
    required this.name,
    required this.level,
    required this.nationality,
    required this.preferredSide,
    this.profileImageUrl,
    this.isAdmin = false,
    this.isLevelVerified = false,
    required this.createdAt,
    this.lastLoginAt,
  });

  factory UserModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;

    return UserModel(
      id: doc.id,
      email: data['email'] as String? ?? '',
      name: data['name'] as String? ?? '',
      level: (data['level'] as num?)?.toDouble() ?? 0.0,
      nationality: data['nationality'] as String? ?? '',
      preferredSide: data['preferredSide'] as String? ?? 'Right',
      profileImageUrl: data['profileImageUrl'] as String?,
      isAdmin: data['isAdmin'] as bool? ?? false,
      isLevelVerified: data['isLevelVerified'] as bool? ?? false,
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      lastLoginAt: (data['lastLoginAt'] as Timestamp?)?.toDate(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'email': email,
      'name': name,
      'level': level,
      'nationality': nationality,
      'preferredSide': preferredSide,
      'profileImageUrl': profileImageUrl,
      'isAdmin': isAdmin,
      'isLevelVerified': isLevelVerified,
      'createdAt': Timestamp.fromDate(createdAt),
      'lastLoginAt':
          lastLoginAt != null ? Timestamp.fromDate(lastLoginAt!) : null,
    };
  }

  UserModel copyWith({
    String? email,
    String? name,
    double? level,
    String? nationality,
    String? preferredSide,
    String? profileImageUrl,
    bool? isAdmin,
    bool? isLevelVerified,
    DateTime? lastLoginAt,
  }) {
    return UserModel(
      id: id,
      email: email ?? this.email,
      name: name ?? this.name,
      level: level ?? this.level,
      nationality: nationality ?? this.nationality,
      preferredSide: preferredSide ?? this.preferredSide,
      profileImageUrl: profileImageUrl ?? this.profileImageUrl,
      isAdmin: isAdmin ?? this.isAdmin,
      isLevelVerified: isLevelVerified ?? this.isLevelVerified,
      createdAt: createdAt,
      lastLoginAt: lastLoginAt ?? this.lastLoginAt,
    );
  }
}
import '../match/match_result.dart';
import '../match/achievement.dart';

class PlayerStatistics {
  int wins;
  int losses;
  int draws;
  int setsWon;
  int setsLost;
  int gamesWon;
  int gamesLost;
  List<String> recentMatches;
  List<MatchResult> recentResults;
  double winRate;
  double rating;
  int currentStreak;
  List<double> last10MatchesRating;
  Map<String, int> partnershipMatches;
  Map<String, double> partnershipWinRate;
  List<Achievement> achievements;
  DateTime? lastMatchDate;

  PlayerStatistics({
    this.wins = 0,
    this.losses = 0,
    this.draws = 0,
    this.setsWon = 0,
    this.setsLost = 0,
    this.gamesWon = 0,
    this.gamesLost = 0,
    List<String>? recentMatches,
    List<MatchResult>? recentResults,
    this.winRate = 0.0,
    this.rating = 0.0,
    this.currentStreak = 0,
    List<double>? last10MatchesRating,
    Map<String, int>? partnershipMatches,
    Map<String, double>? partnershipWinRate,
    List<Achievement>? achievements,
    this.lastMatchDate,
  })  : recentMatches = recentMatches ?? [],
        recentResults = recentResults ?? [],
        last10MatchesRating = last10MatchesRating ?? [],
        partnershipMatches = partnershipMatches ?? {},
        partnershipWinRate = partnershipWinRate ?? {},
        achievements = achievements ?? [];

  factory PlayerStatistics.fromMap(Map<String, dynamic>? map) {
    if (map == null) return PlayerStatistics();

    return PlayerStatistics(
      wins: (map['wins'] as num?)?.toInt() ?? 0,
      losses: (map['losses'] as num?)?.toInt() ?? 0,
      draws: (map['draws'] as num?)?.toInt() ?? 0,
      setsWon: (map['setsWon'] as num?)?.toInt() ?? 0,
      setsLost: (map['setsLost'] as num?)?.toInt() ?? 0,
      gamesWon: (map['gamesWon'] as num?)?.toInt() ?? 0,
      gamesLost: (map['gamesLost'] as num?)?.toInt() ?? 0,
      recentMatches: (map['recentMatches'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          [],
      recentResults: (map['recentResults'] as List<dynamic>?)
              ?.map((e) => MatchResult.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      winRate: (map['winRate'] as num?)?.toDouble() ?? 0.0,
      rating: (map['rating'] as num?)?.toDouble() ?? 0.0,
      currentStreak: (map['currentStreak'] as num?)?.toInt() ?? 0,
      last10MatchesRating: (map['last10MatchesRating'] as List<dynamic>?)
              ?.map((e) => (e as num).toDouble())
              .toList() ??
          [],
      partnershipMatches: (map['partnershipMatches'] as Map<String, dynamic>?)
              ?.map((key, value) => MapEntry(key, (value as num).toInt())) ??
          {},
      partnershipWinRate: (map['partnershipWinRate'] as Map<String, dynamic>?)
              ?.map((key, value) => MapEntry(key, (value as num).toDouble())) ??
          {},
      achievements: (map['achievements'] as List<dynamic>?)
              ?.map((e) => Achievement.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      lastMatchDate: map['lastMatchDate'] != null
          ? DateTime.parse(map['lastMatchDate'] as String)
          : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'wins': wins,
      'losses': losses,
      'draws': draws,
      'setsWon': setsWon,
      'setsLost': setsLost,
      'gamesWon': gamesWon,
      'gamesLost': gamesLost,
      'recentMatches': recentMatches,
      'recentResults': recentResults.map((r) => r.toMap()).toList(),
      'winRate': winRate,
      'rating': rating,
      'currentStreak': currentStreak,
      'last10MatchesRating': last10MatchesRating,
      'partnershipMatches': partnershipMatches,
      'partnershipWinRate': partnershipWinRate,
      'achievements': achievements.map((a) => a.toMap()).toList(),
      'lastMatchDate': lastMatchDate?.toIso8601String(),
    };
  }

  void updateStats(MatchResult result) {
    if (result.isWin) {
      wins++;
      currentStreak = currentStreak > 0 ? currentStreak + 1 : 1;
    } else if (result.isDraw) {
      draws++;
      currentStreak = 0;
    } else {
      losses++;
      currentStreak = currentStreak < 0 ? currentStreak - 1 : -1;
    }

    setsWon += result.setsWon;
    setsLost += result.setsLost;
    gamesWon += result.gamesWon;
    gamesLost += result.gamesLost;

    winRate = totalMatches > 0 ? (wins / totalMatches) * 100 : 0;
    rating += result.ratingChange;

    recentResults.insert(0, result);
    if (recentResults.length > 10) {
      recentResults = recentResults.sublist(0, 10);
    }

    recentMatches.insert(0, result.isWin ? 'W' : (result.isDraw ? 'D' : 'L'));
    if (recentMatches.length > 10) {
      recentMatches = recentMatches.sublist(0, 10);
    }

    last10MatchesRating.insert(0, rating);
    if (last10MatchesRating.length > 10) {
      last10MatchesRating = last10MatchesRating.sublist(0, 10);
    }

    lastMatchDate = DateTime.now();
    _checkAchievements(result);
  }

  void _checkAchievements(MatchResult result) {
    if (currentStreak >= 5) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.winStreak,
        value: currentStreak,
      ));
    }

    if (wins == 1) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.firstWin,
      ));
    }

    if (result.hasPerfectSet) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.perfectSet,
      ));
    }
  }

  void updatePartnershipStats(String partnerName, bool isWin) {
    partnershipMatches.update(
      partnerName,
      (value) => value + 1,
      ifAbsent: () => 1,
    );

    final currentWins = partnershipWinRate[partnerName] ?? 0;
    final totalMatches = partnershipMatches[partnerName] ?? 0;

    if (isWin) {
      partnershipWinRate[partnerName] =
          ((currentWins * totalMatches) + 100) / (totalMatches + 1);
    } else {
      partnershipWinRate[partnerName] =
          (currentWins * totalMatches) / (totalMatches + 1);
    }
  }

  int get totalMatches => wins + losses + draws;
}
import 'package:cloud_firestore/cloud_firestore.dart';

enum MatchOutcome {
  win,
  loss,
  draw;

  bool get isWin => this == MatchOutcome.win;
  bool get isLoss => this == MatchOutcome.loss;
  bool get isDraw => this == MatchOutcome.draw;

  String toDisplayString() {
    switch (this) {
      case MatchOutcome.win:
        return 'Win';
      case MatchOutcome.loss:
        return 'Loss';
      case MatchOutcome.draw:
        return 'Draw';
    }
  }
}

class MatchResult {
  final String matchId;
  final DateTime date;
  final MatchOutcome outcome;
  final int setsWon;
  final int setsLost;
  final int gamesWon;
  final int gamesLost;
  final bool hasPerfectSet;
  final String opponent;
  final double ratingChange;

  const MatchResult({
    required this.matchId,
    required this.date,
    required this.outcome,
    required this.setsWon,
    required this.setsLost,
    required this.gamesWon,
    required this.gamesLost,
    this.hasPerfectSet = false,
    required this.opponent,
    this.ratingChange = 0.0,
  });

  bool get isWin => outcome == MatchOutcome.win;
  bool get isLoss => outcome == MatchOutcome.loss;
  bool get isDraw => outcome == MatchOutcome.draw;

  int get totalGames => gamesWon + gamesLost;
  int get gamesDifference => gamesWon - gamesLost;
  int get setsDifference => setsWon - setsLost;

  double get winPercentage {
    if (totalGames == 0) return 0;
    return (gamesWon / totalGames) * 100;
  }

  Map<String, dynamic> toMap() {
    return {
      'matchId': matchId,
      'date': Timestamp.fromDate(date),
      'outcome': outcome.toString(),
      'setsWon': setsWon,
      'setsLost': setsLost,
      'gamesWon': gamesWon,
      'gamesLost': gamesLost,
      'hasPerfectSet': hasPerfectSet,
      'opponent': opponent,
      'ratingChange': ratingChange,
    };
  }

  factory MatchResult.fromMap(Map<String, dynamic> map) {
    return MatchResult(
      matchId: map['matchId'] as String,
      date: (map['date'] as Timestamp).toDate(),
      outcome: MatchOutcome.values.firstWhere(
        (e) => e.toString() == map['outcome'],
        orElse: () => MatchOutcome.loss,
      ),
      setsWon: (map['setsWon'] as num).toInt(),
      setsLost: (map['setsLost'] as num).toInt(),
      gamesWon: (map['gamesWon'] as num).toInt(),
      gamesLost: (map['gamesLost'] as num).toInt(),
      hasPerfectSet: map['hasPerfectSet'] as bool? ?? false,
      opponent: map['opponent'] as String,
      ratingChange: (map['ratingChange'] as num?)?.toDouble() ?? 0.0,
    );
  }

  static MatchResult createFromScore({
    required String matchId,
    required int team1Sets,
    required int team2Sets,
    required List<int> team1Games,
    required List<int> team2Games,
    required String opponent,
    double ratingChange = 0.0,
  }) {
    final now = DateTime.now();
    final setsWon = team1Sets;
    final setsLost = team2Sets;
    final gamesWon = team1Games.fold<int>(0, (total, game) => total + game);
    final gamesLost = team2Games.fold<int>(0, (total, game) => total + game);

    MatchOutcome outcome;
    if (team1Sets > team2Sets) {
      outcome = MatchOutcome.win;
    } else if (team1Sets < team2Sets) {
      outcome = MatchOutcome.loss;
    } else {
      outcome = MatchOutcome.draw;
    }

    final hasPerfectSet = team1Games.contains(6) && team2Games.contains(0);

    return MatchResult(
      matchId: matchId,
      date: now,
      outcome: outcome,
      setsWon: setsWon,
      setsLost: setsLost,
      gamesWon: gamesWon,
      gamesLost: gamesLost,
      hasPerfectSet: hasPerfectSet,
      opponent: opponent,
      ratingChange: ratingChange,
    );
  }
}
import 'package:flutter/material.dart';

enum AchievementType {
  winStreak, // Win streak achievement
  firstWin, // First victory
  perfectSet, // Won a set 6-0
  comeback, // Won after losing first set
  tournament, // Tournament victory
  undefeatedStreak, // Maintained undefeated streak
  cleanSweep, // Won all matches in tournament
  giantKiller, // Beat a higher ranked player
  rapidRiser, // Quick improvement in ranking
  ironMan, // Many matches in short time
  popularPlayer, // Played with different partners
  clutchPlayer, // Won close matches
  dominantDisplay, // Big score differences
  seasonChampion, // Top of the league
  monthlyMVP, // Best player of the month
  rookieOfTheYear, // Best new player
  improvedRating, // Rating milestone
  consistentPlayer // Regular player
}

enum AchievementRarity {
  common,
  uncommon,
  rare,
  epic,
  legendary;

  Color get color {
    switch (this) {
      case AchievementRarity.common:
        return Colors.grey;
      case AchievementRarity.uncommon:
        return Colors.green;
      case AchievementRarity.rare:
        return Colors.blue;
      case AchievementRarity.epic:
        return Colors.purple;
      case AchievementRarity.legendary:
        return Colors.orange;
    }
  }

  String get label {
    switch (this) {
      case AchievementRarity.common:
        return 'Common';
      case AchievementRarity.uncommon:
        return 'Uncommon';
      case AchievementRarity.rare:
        return 'Rare';
      case AchievementRarity.epic:
        return 'Epic';
      case AchievementRarity.legendary:
        return 'Legendary';
    }
  }
}

class Achievement {
  final String id;
  final String title;
  final String description;
  final AchievementType type;
  final AchievementRarity rarity;
  final DateTime dateEarned;
  final int? progress;
  final int? target;
  final String? icon;

  const Achievement({
    required this.id,
    required this.title,
    required this.description,
    required this.type,
    required this.rarity,
    required this.dateEarned,
    this.progress,
    this.target,
    this.icon,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'type': type.toString(),
      'rarity': rarity.toString(),
      'dateEarned': dateEarned.toIso8601String(),
      'progress': progress,
      'target': target,
      'icon': icon,
    };
  }

  factory Achievement.fromMap(Map<String, dynamic> map) {
    return Achievement(
      id: map['id'] as String,
      title: map['title'] as String,
      description: map['description'] as String,
      type: AchievementType.values.firstWhere(
        (e) => e.toString() == map['type'],
        orElse: () => AchievementType.firstWin,
      ),
      rarity: AchievementRarity.values.firstWhere(
        (e) => e.toString() == map['rarity'],
        orElse: () => AchievementRarity.common,
      ),
      dateEarned: DateTime.parse(map['dateEarned'] as String),
      progress: map['progress'] as int?,
      target: map['target'] as int?,
      icon: map['icon'] as String?,
    );
  }

  static Achievement createAchievement({
    required AchievementType type,
    int? value,
    int? target,
  }) {
    final achievementData = _getAchievementData(type, value, target);
    return Achievement(
      id: '${type.toString()}_${DateTime.now().millisecondsSinceEpoch}',
      title: achievementData.title,
      description: achievementData.description,
      type: type,
      rarity: achievementData.rarity,
      dateEarned: DateTime.now(),
      progress: value,
      target: target,
      icon: achievementData.icon,
    );
  }

  static AchievementData _getAchievementData(
    AchievementType type,
    int? value,
    int? target,
  ) {
    switch (type) {
      case AchievementType.winStreak:
        return AchievementData(
          title: '${value ?? 5} Win Streak!',
          description: 'Won ${value ?? 5} matches in a row',
          rarity: value != null && value >= 10
              ? AchievementRarity.legendary
              : AchievementRarity.rare,
          icon: 'trophy',
        );

      case AchievementType.firstWin:
        return const AchievementData(
          title: 'First Victory',
          description: 'Won your first match',
          rarity: AchievementRarity.common,
          icon: 'star',
        );

      case AchievementType.perfectSet:
        return const AchievementData(
          title: 'Perfect Set',
          description: 'Won a set 6-0',
          rarity: AchievementRarity.rare,
          icon: 'crown',
        );

      case AchievementType.tournament:
        return const AchievementData(
          title: 'Tournament Champion',
          description: 'Won a tournament',
          rarity: AchievementRarity.legendary,
          icon: 'trophy',
        );

      case AchievementType.consistentPlayer:
        return AchievementData(
          title: 'Consistent Player',
          description: 'Played ${value ?? 10} matches in a month',
          rarity: AchievementRarity.uncommon,
          icon: 'calendar',
        );

      case AchievementType.monthlyMVP:
        return const AchievementData(
          title: 'Monthly MVP',
          description: 'Best performing player of the month',
          rarity: AchievementRarity.epic,
          icon: 'medal',
        );

      default:
        return AchievementData(
          title: type.toString().split('.').last,
          description: 'Achievement unlocked!',
          rarity: AchievementRarity.common,
          icon: 'star',
        );
    }
  }

  bool get isCompleted =>
      progress != null && target != null && progress! >= target!;

  double get progressPercentage {
    if (progress == null || target == null) return 1.0;
    return progress! / target!;
  }

  String get formattedDate {
    return '${dateEarned.day}/${dateEarned.month}/${dateEarned.year}';
  }

  bool get isRecent {
    final now = DateTime.now();
    return dateEarned.isAfter(now.subtract(const Duration(days: 7)));
  }

  IconData getIconData() {
    switch (icon) {
      case 'trophy':
        return Icons.emoji_events;
      case 'star':
        return Icons.star;
      case 'crown':
        return Icons.workspace_premium;
      case 'medal':
        return Icons.military_tech;
      case 'calendar':
        return Icons.calendar_today;
      default:
        return Icons.emoji_events;
    }
  }
}

class AchievementData {
  final String title;
  final String description;
  final AchievementRarity rarity;
  final String icon;

  const AchievementData({
    required this.title,
    required this.description,
    required this.rarity,
    required this.icon,
  });
}

// Example usage:
class AchievementService {
  static bool checkForAchievements(
    int wins,
    int streak,
    int matchesThisMonth,
    double rating,
    bool wonTournament,
  ) {
    List<Achievement> newAchievements = [];

    // Check win streak
    if (streak >= 5) {
      newAchievements.add(Achievement.createAchievement(
        type: AchievementType.winStreak,
        value: streak,
      ));
    }

    // Check first win
    if (wins == 1) {
      newAchievements.add(Achievement.createAchievement(
        type: AchievementType.firstWin,
      ));
    }

    // Check consistent player
    if (matchesThisMonth >= 10) {
      newAchievements.add(Achievement.createAchievement(
        type: AchievementType.consistentPlayer,
        value: matchesThisMonth,
      ));
    }

    // Check tournament win
    if (wonTournament) {
      newAchievements.add(Achievement.createAchievement(
        type: AchievementType.tournament,
      ));
    }

    return newAchievements.isNotEmpty;
  }
}
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'statistics/player_statistics.dart';
import 'player_avatar.dart';
import 'match/match_result.dart';

class Player {
  final String id;
  final String name;
  final double rating;
  final int rank;
  final String profileImage;
  final DateTime createdAt;
  Map<String, String> signedTimeslots;
  final PlayerStatistics statistics;

  Player({
    required this.id,
    required this.name,
    required this.rating,
    required this.rank,
    required this.profileImage,
    required this.createdAt,
    Map<String, String>? signedTimeslots,
    PlayerStatistics? statistics,
  })  : signedTimeslots = signedTimeslots ?? {},
        statistics = statistics ?? PlayerStatistics();

  // Add the unknown factory constructor
  factory Player.unknown() {
    return Player(
      id: 'unknown',
      name: 'Unknown Player',
      rating: 0,
      rank: 0,
      profileImage: 'assets/images/profile.png',
      createdAt: DateTime.now(),
      signedTimeslots: {},
      statistics: PlayerStatistics(),
    );
  }

  factory Player.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;

    // Safely extract Timestamp
    DateTime createdAtDate;
    try {
      createdAtDate =
          (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now();
    } catch (e) {
      debugPrint('Error converting timestamp: $e');
      createdAtDate = DateTime.now();
    }

    // Safely extract signedTimeslots
    Map<String, String> timeslots = {};
    try {
      if (data['signedTimeslots'] != null) {
        final slots = data['signedTimeslots'] as Map<dynamic, dynamic>;
        timeslots = Map<String, String>.from(slots.map(
          (key, value) => MapEntry(key.toString(), value.toString()),
        ));
      }
    } catch (e) {
      debugPrint('Error converting signedTimeslots: $e');
    }

    // Extract statistics
    PlayerStatistics stats;
    try {
      stats =
          PlayerStatistics.fromMap(data['statistics'] as Map<String, dynamic>?);
    } catch (e) {
      debugPrint('Error converting statistics: $e');
      stats = PlayerStatistics();
    }

    return Player(
      id: doc.id,
      name: data['name']?.toString() ?? 'Unknown Player',
      rating: (data['rating'] as num?)?.toDouble() ?? 0.0,
      rank: (data['rank'] as num?)?.toInt() ?? 0,
      profileImage:
          data['profileImage']?.toString() ?? 'assets/images/profile.png',
      createdAt: createdAtDate,
      signedTimeslots: timeslots,
      statistics: stats,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'rating': rating,
      'rank': rank,
      'profileImage': profileImage,
      'createdAt': Timestamp.fromDate(createdAt),
      'signedTimeslots': signedTimeslots,
      'statistics': statistics.toMap(),
    };
  }

  void updateMatchStats(MatchResult result) {
    statistics.updateStats(result);
  }

  void signForTimeslot(String day, String timeslot) {
    debugPrint('Signing $name for $timeslot on $day');
    signedTimeslots[day] = timeslot;
  }

  bool isPlayEither(String day) {
    return signedTimeslots[day] == 'Play Either';
  }

  Widget avatar({double size = 60}) {
    return PlayerAvatar(player: this, size: size);
  }
}
import 'package:flutter/foundation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'player.dart';
import '../services/firebase_service.dart';

enum MatchStatus { scheduled, inProgress, completed, cancelled, waitingPlayers }

class Score {
  int sets;
  List<int> games;

  Score({
    this.sets = 0,
    List<int>? games,
  }) : games = games ?? [];

  Map<String, dynamic> toMap() {
    return {
      'sets': sets,
      'games': games,
    };
  }

  factory Score.fromMap(Map<String, dynamic> map) {
    return Score(
      sets: (map['sets'] as num?)?.toInt() ?? 0,
      games: (map['games'] as List<dynamic>?)
              ?.map((e) => (e as num).toInt())
              .toList() ??
          [],
    );
  }

  Score copyWith({
    int? sets,
    List<int>? games,
  }) {
    return Score(
      sets: sets ?? this.sets,
      games: games != null ? List<int>.from(games) : List<int>.from(this.games),
    );
  }
}

class Match {
  final String id;
  final DateTime date;
  final String time;
  final MatchStatus status;
  final Map<String, Player?> players;
  final Map<String, Score> score;
  final DateTime createdAt;
  final int availableSlots;

  Match({
    required this.id,
    required this.date,
    required this.time,
    required this.status,
    required this.players,
    required this.score,
    required this.createdAt,
    this.availableSlots = 0,
  });

  Player? get team1Player1 => players['team1_player1'];
  Player? get team1Player2 => players['team1_player2'];
  Player? get team2Player1 => players['team2_player1'];
  Player? get team2Player2 => players['team2_player2'];

  Score? get team1Score => score['team1'];
  Score? get team2Score => score['team2'];

  bool get isComplete => status == MatchStatus.completed;
  bool get needsPlayers => availableSlots > 0;

  String? get winner {
    if (!isComplete) return null;
    final team1Sets = team1Score?.sets ?? 0;
    final team2Sets = team2Score?.sets ?? 0;
    if (team1Sets > team2Sets) return 'team1';
    if (team2Sets > team1Sets) return 'team2';
    return null;
  }

  factory Match.fromFirestore(DocumentSnapshot doc, List<Player> allPlayers) {
    final data = doc.data() as Map<String, dynamic>;
    Map<String, Player?> matchPlayers = {};

    try {
      final playersData = data['players'] as Map<String, dynamic>? ?? {};

      // Process team1
      final team1Data = playersData['team1'] as Map<String, dynamic>? ?? {};
      final player1Ref = team1Data['player1'] as DocumentReference?;
      final player2Ref = team1Data['player2'] as DocumentReference?;

      // Process team2
      final team2Data = playersData['team2'] as Map<String, dynamic>? ?? {};
      final player3Ref = team2Data['player1'] as DocumentReference?;
      final player4Ref = team2Data['player2'] as DocumentReference?;

      // Safely find players
      if (player1Ref != null) {
        matchPlayers['team1_player1'] = allPlayers.firstWhere(
          (p) => p.id == player1Ref.id,
          orElse: () => Player.unknown(),
        );
      }

      if (player2Ref != null) {
        matchPlayers['team1_player2'] = allPlayers.firstWhere(
          (p) => p.id == player2Ref.id,
          orElse: () => Player.unknown(),
        );
      }

      if (player3Ref != null) {
        matchPlayers['team2_player1'] = allPlayers.firstWhere(
          (p) => p.id == player3Ref.id,
          orElse: () => Player.unknown(),
        );
      }

      if (player4Ref != null) {
        matchPlayers['team2_player2'] = allPlayers.firstWhere(
          (p) => p.id == player4Ref.id,
          orElse: () => Player.unknown(),
        );
      }
    } catch (e) {
      debugPrint('Error processing players in Match.fromFirestore: $e');
    }

    return Match(
      id: data['id'] as String? ?? doc.id,
      date: (data['date'] as Timestamp?)?.toDate() ?? DateTime.now(),
      time: data['time'] as String? ?? 'Later Timeslot',
      status: MatchStatus.values.firstWhere(
        (e) => e.toString().split('.').last == (data['status'] as String?),
        orElse: () => MatchStatus.scheduled,
      ),
      players: matchPlayers,
      score: {
        'team1': Score.fromMap(
            data['score']?['team1'] as Map<String, dynamic>? ??
                {'sets': 0, 'games': []}),
        'team2': Score.fromMap(
            data['score']?['team2'] as Map<String, dynamic>? ??
                {'sets': 0, 'games': []}),
      },
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      availableSlots: (data['availableSlots'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, dynamic> toMap() {
    // Updated to use FirebaseService
    final firestore = FirebaseService.instance.firestore;
    return {
      'id': id,
      'date': Timestamp.fromDate(date),
      'time': time,
      'status': status.toString().split('.').last,
      'players': {
        'team1': {
          'player1': team1Player1 != null
              ? firestore.doc('players/${team1Player1!.id}')
              : null,
          'player2': team1Player2 != null
              ? firestore.doc('players/${team1Player2!.id}')
              : null,
        },
        'team2': {
          'player1': team2Player1 != null
              ? firestore.doc('players/${team2Player1!.id}')
              : null,
          'player2': team2Player2 != null
              ? firestore.doc('players/${team2Player2!.id}')
              : null,
        },
      },
      'score': {
        'team1': score['team1']!.toMap(),
        'team2': score['team2']!.toMap(),
      },
      'createdAt': Timestamp.fromDate(createdAt),
      'availableSlots': availableSlots,
    };
  }

  Match copyWith({
    String? id,
    DateTime? date,
    String? time,
    MatchStatus? status,
    Map<String, Player?>? players,
    Map<String, Score>? score,
    DateTime? createdAt,
    int? availableSlots,
  }) {
    return Match(
      id: id ?? this.id,
      date: date ?? this.date,
      time: time ?? this.time,
      status: status ?? this.status,
      players: players ?? Map<String, Player?>.from(this.players),
      score: score ?? Map<String, Score>.from(this.score),
      createdAt: createdAt ?? this.createdAt,
      availableSlots: availableSlots ?? this.availableSlots,
    );
  }
}
// lib/models/game_state.dart

import 'package:flutter/foundation.dart';
import 'player.dart';
import 'match/match_result.dart';

class GameState extends ChangeNotifier {
  List<Player> players = [];
  List<Map<String, dynamic>> matches = [];

  // Update match score
  void updateMatchScore(
    String matchId,
    String playerKey,
    String scoreType,
    int value,
  ) {
    final matchIndex = int.tryParse(matchId);
    if (matchIndex == null || matchIndex >= matches.length) return;

    var match = matches[matchIndex];
    var scores = match['score'] as Map<String, dynamic>?;
    if (scores == null) return;

    var playerScore = scores[playerKey] as Map<String, dynamic>?;
    if (playerScore == null) return;

    if (playerScore[scoreType] != null) {
      playerScore[scoreType] = value;
      _updatePlayerStats(match, playerKey);
      notifyListeners();
    }
  }

  // Update player stats after a match
  void _updatePlayerStats(Map<String, dynamic> match, String playerKey) {
    try {
      // Safely get player data
      final playerData = match[playerKey] as Map<String, dynamic>?;
      final playerName = playerData?['name'] as String?;
      if (playerName == null) return;

      // Find player
      final player = players.firstWhere(
        (p) => p.name == playerName,
        orElse: () => throw Exception('Player not found'),
      );

      // Safely extract scores
      final scores = match['score'] as Map<String, dynamic>?;
      final playerScore = scores?[playerKey] as Map<String, dynamic>?;
      final opponentKey = playerKey == 'team1' ? 'team2' : 'team1';
      final opponentScore = scores?[opponentKey] as Map<String, dynamic>?;

      if (playerScore == null || opponentScore == null) return;

      // Calculate stats
      final setsWon = playerScore['sets'] as int? ?? 0;
      final setsLost = opponentScore['sets'] as int? ?? 0;
      final playerGames = playerScore['games'] as List<dynamic>? ?? [];
      final opponentGames = opponentScore['games'] as List<dynamic>? ?? [];
      final totalGamesWon =
          playerGames.fold<int>(0, (sum, game) => sum + (game as int? ?? 0));
      final totalGamesLost =
          opponentGames.fold<int>(0, (sum, game) => sum + (game as int? ?? 0));

      // Determine match outcome
      final outcome = setsWon > setsLost
          ? MatchOutcome.win
          : setsWon < setsLost
              ? MatchOutcome.loss
              : MatchOutcome.draw;

      // Check for perfect set
      final hasPerfectSet =
          playerGames.contains(6) && opponentGames.contains(0);

      // Get opponent name
      final opponentData = match[opponentKey] as Map<String, dynamic>?;
      final opponentName = opponentData?['name'] as String? ?? 'Unknown';

      // Create match result
      final result = MatchResult(
        matchId: match['id']?.toString() ?? DateTime.now().toString(),
        date: DateTime.now(),
        outcome: outcome,
        setsWon: setsWon,
        setsLost: setsLost,
        gamesWon: totalGamesWon,
        gamesLost: totalGamesLost,
        hasPerfectSet: hasPerfectSet,
        opponent: opponentName,
      );

      // Update player stats
      player.updateMatchStats(result);
      notifyListeners();
    } catch (e) {
      debugPrint('Error updating player stats: $e');
    }
  }

  // Get matches for a specific player
  List<Map<String, dynamic>> getMatchesForPlayer(String playerId) {
    return matches.where((match) {
      // Safely convert team1Players and team2Players to List<String>
      final team1Players = (match['team1Players'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          [];
      final team2Players = (match['team2Players'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          [];
      return team1Players.contains(playerId) || team2Players.contains(playerId);
    }).toList();
  }

  // Get player's team key in a match
  String? _getPlayerTeamKey(Map<String, dynamic> match, String playerId) {
    final team1Players = (match['team1Players'] as List<dynamic>?)
            ?.map((e) => e.toString())
            .toList() ??
        [];
    if (team1Players.contains(playerId)) return 'team1';

    final team2Players = (match['team2Players'] as List<dynamic>?)
            ?.map((e) => e.toString())
            .toList() ??
        [];
    if (team2Players.contains(playerId)) return 'team2';

    return null;
  }

  // Get recent matches for a player
  List<Map<String, dynamic>> getRecentMatches(String playerId,
      {int limit = 5}) {
    final playerMatches = getMatchesForPlayer(playerId);
    playerMatches.sort((a, b) {
      final dateA =
          DateTime.tryParse(a['date']?.toString() ?? '') ?? DateTime.now();
      final dateB =
          DateTime.tryParse(b['date']?.toString() ?? '') ?? DateTime.now();
      return dateB.compareTo(dateA);
    });
    return playerMatches.take(limit).toList();
  }

  // Additional utility methods
  void addMatch(Map<String, dynamic> match) {
    matches.add(match);
    notifyListeners();
  }

  Map<String, dynamic>? getMatch(int index) {
    if (index >= 0 && index < matches.length) {
      return matches[index];
    }
    return null;
  }

  void clearMatches() {
    matches.clear();
    notifyListeners();
  }

  void addPlayer(Player player) {
    if (!players.any((p) => p.id == player.id)) {
      players.add(player);
      notifyListeners();
    }
  }

  void removePlayer(String playerId) {
    players.removeWhere((p) => p.id == playerId);
    notifyListeners();
  }

  Player? getPlayerById(String id) {
    try {
      return players.firstWhere((p) => p.id == id);
    } catch (_) {
      return null;
    }
  }

  void updatePlayer(Player updatedPlayer) {
    final index = players.indexWhere((p) => p.id == updatedPlayer.id);
    if (index != -1) {
      players[index] = updatedPlayer;
      notifyListeners();
    }
  }

  List<Player> getPlayersByRank() {
    final sortedPlayers = List<Player>.from(players);
    sortedPlayers.sort((a, b) => b.rating.compareTo(a.rating));
    return sortedPlayers;
  }

  double getPlayerWinRate(String playerId) {
    final playerMatches = getMatchesForPlayer(playerId);
    if (playerMatches.isEmpty) return 0.0;

    final wins = playerMatches.where((match) {
      final playerKey = _getPlayerTeamKey(match, playerId);
      if (playerKey == null) return false;

      final scores = match['score'] as Map<String, dynamic>?;
      if (scores == null) return false;

      final playerScore = scores[playerKey]['sets'] as int? ?? 0;
      final opponentScore =
          scores[playerKey == 'team1' ? 'team2' : 'team1']['sets'] as int? ?? 0;
      return playerScore > opponentScore;
    }).length;

    return (wins / playerMatches.length) * 100;
  }
}
import 'package:flutter/material.dart';
import 'player.dart';

class PlayerAvatar extends StatelessWidget {
  final Player player;
  final double size;

  const PlayerAvatar({
    super.key,
    required this.player,
    this.size = 60,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(
          color: _getBorderColor(),
          width: size / 30,
        ),
      ),
      child: ClipOval(
        child: Image.asset(
          player.profileImage,
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) {
            debugPrint('Error loading player image: $error');
            return Container(
              color: Colors.grey[200],
              child: Icon(
                Icons.person,
                size: size * 0.6,
                color: Colors.grey[400],
              ),
            );
          },
        ),
      ),
    );
  }

  Color _getBorderColor() {
    if (player.rank >= 0 && player.rank < 15) {
      return Colors.blue[900]!;
    } else if (player.rank >= 15 && player.rank < 30) {
      return Colors.blue[300]!;
    } else if (player.rank >= 30 && player.rank < 50) {
      return Colors.yellow;
    } else if (player.rank >= 50 && player.rank < 70) {
      return Colors.green;
    } else if (player.rank >= 70 && player.rank < 90) {
      return Colors.orange;
    } else {
      return Colors.red;
    }
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'match/match_result.dart';
import 'match/achievement.dart';

class MatchStatistics {
  int wins;
  int losses;
  int draws;
  int setsWon;
  int setsLost;
  int gamesWon;
  int gamesLost;
  List<String> recentMatches;
  List<MatchResult> recentResults;
  double winRate;
  double rating;
  int currentStreak;
  List<double> last10MatchesRating;
  Map<String, int> partnershipMatches;
  Map<String, double> partnershipWinRate;
  List<Achievement> achievements;
  DateTime lastMatchDate;

  // Getters
  int get totalMatches => wins + losses + draws;
  double get gamesWinRate => gamesWon + gamesLost > 0
      ? (gamesWon / (gamesWon + gamesLost)) * 100
      : 0.0;
  double get setsWinRate =>
      setsWon + setsLost > 0 ? (setsWon / (setsWon + setsLost)) * 100 : 0.0;
  bool get hasPlayed => totalMatches > 0;

  MatchStatistics({
    this.wins = 0,
    this.losses = 0,
    this.draws = 0,
    this.setsWon = 0,
    this.setsLost = 0,
    this.gamesWon = 0,
    this.gamesLost = 0,
    List<String>? recentMatches,
    List<MatchResult>? recentResults,
    this.winRate = 0.0,
    this.rating = 0.0,
    this.currentStreak = 0,
    List<double>? last10MatchesRating,
    Map<String, int>? partnershipMatches,
    Map<String, double>? partnershipWinRate,
    List<Achievement>? achievements,
    DateTime? lastMatchDate,
  })  : recentMatches = recentMatches ?? [],
        recentResults = recentResults ?? [],
        last10MatchesRating = last10MatchesRating ?? [],
        partnershipMatches = partnershipMatches ?? {},
        partnershipWinRate = partnershipWinRate ?? {},
        achievements = achievements ?? [],
        lastMatchDate = lastMatchDate ?? DateTime.now();

  Map<String, dynamic> toMap() {
    try {
      return {
        'wins': wins,
        'losses': losses,
        'draws': draws,
        'setsWon': setsWon,
        'setsLost': setsLost,
        'gamesWon': gamesWon,
        'gamesLost': gamesLost,
        'recentMatches': recentMatches,
        'recentResults': recentResults.map((r) => r.toMap()).toList(),
        'winRate': winRate,
        'rating': rating,
        'currentStreak': currentStreak,
        'last10MatchesRating': last10MatchesRating,
        'partnershipMatches': partnershipMatches,
        'partnershipWinRate': partnershipWinRate,
        'achievements': achievements.map((a) => a.toMap()).toList(),
        'lastMatchDate': Timestamp.fromDate(lastMatchDate),
      };
    } catch (e) {
      debugPrint('Error converting MatchStatistics to map: $e');
      rethrow;
    }
  }

  factory MatchStatistics.fromMap(Map<String, dynamic>? map) {
    if (map == null) return MatchStatistics();

    try {
      // Handle recent matches
      List<String> recentMatchesList = [];
      if (map['recentMatches'] != null) {
        recentMatchesList =
            List<String>.from(map['recentMatches'] as List<dynamic>);
      }

      // Handle recent results
      List<MatchResult> recentResultsList = [];
      if (map['recentResults'] != null) {
        recentResultsList = (map['recentResults'] as List<dynamic>)
            .map((e) => MatchResult.fromMap(e as Map<String, dynamic>))
            .toList();
      }

      // Handle ratings history
      List<double> ratingHistory = [];
      if (map['last10MatchesRating'] != null) {
        ratingHistory = (map['last10MatchesRating'] as List<dynamic>)
            .map((e) => (e as num).toDouble())
            .toList();
      }

      // Handle partnership matches
      Map<String, int> partnershipMatchesMap = {};
      if (map['partnershipMatches'] != null) {
        partnershipMatchesMap =
            (map['partnershipMatches'] as Map<String, dynamic>).map(
          (key, value) => MapEntry(key, (value as num).toInt()),
        );
      }

      // Handle partnership win rates
      Map<String, double> partnershipWinRateMap = {};
      if (map['partnershipWinRate'] != null) {
        partnershipWinRateMap =
            (map['partnershipWinRate'] as Map<String, dynamic>).map(
          (key, value) => MapEntry(key, (value as num).toDouble()),
        );
      }

      // Handle achievements
      List<Achievement> achievementsList = [];
      if (map['achievements'] != null) {
        achievementsList = (map['achievements'] as List<dynamic>)
            .map((e) => Achievement.fromMap(e as Map<String, dynamic>))
            .toList();
      }

      return MatchStatistics(
        wins: (map['wins'] as num?)?.toInt() ?? 0,
        losses: (map['losses'] as num?)?.toInt() ?? 0,
        draws: (map['draws'] as num?)?.toInt() ?? 0,
        setsWon: (map['setsWon'] as num?)?.toInt() ?? 0,
        setsLost: (map['setsLost'] as num?)?.toInt() ?? 0,
        gamesWon: (map['gamesWon'] as num?)?.toInt() ?? 0,
        gamesLost: (map['gamesLost'] as num?)?.toInt() ?? 0,
        recentMatches: recentMatchesList,
        recentResults: recentResultsList,
        winRate: (map['winRate'] as num?)?.toDouble() ?? 0.0,
        rating: (map['rating'] as num?)?.toDouble() ?? 0.0,
        currentStreak: (map['currentStreak'] as num?)?.toInt() ?? 0,
        last10MatchesRating: ratingHistory,
        partnershipMatches: partnershipMatchesMap,
        partnershipWinRate: partnershipWinRateMap,
        achievements: achievementsList,
        lastMatchDate:
            (map['lastMatchDate'] as Timestamp?)?.toDate() ?? DateTime.now(),
      );
    } catch (e) {
      debugPrint('Error creating MatchStatistics from map: $e');
      return MatchStatistics(); // Return default statistics on error
    }
  }

  void updateStats(MatchResult result) {
    try {
      // Update wins/losses/draws
      if (result.isWin) {
        wins++;
        currentStreak = currentStreak > 0 ? currentStreak + 1 : 1;
        recentMatches.insert(0, 'W');
      } else if (result.isDraw) {
        draws++;
        currentStreak = 0;
        recentMatches.insert(0, 'D');
      } else {
        losses++;
        currentStreak = currentStreak < 0 ? currentStreak - 1 : -1;
        recentMatches.insert(0, 'L');
      }

      // Keep only last 5 recent matches
      if (recentMatches.length > 5) {
        recentMatches = recentMatches.sublist(0, 5);
      }

      // Update match stats
      setsWon += result.setsWon;
      setsLost += result.setsLost;
      gamesWon += result.gamesWon;
      gamesLost += result.gamesLost;

      // Update win rate
      winRate = totalMatches > 0 ? (wins / totalMatches) * 100 : 0;

      // Update rating with change
      rating += result.ratingChange;

      // Add to recent results
      recentResults.insert(0, result);
      if (recentResults.length > 10) {
        recentResults = recentResults.sublist(0, 10);
      }

      // Update last match date
      lastMatchDate = DateTime.now();

      // Track rating history
      last10MatchesRating.insert(0, rating);
      if (last10MatchesRating.length > 10) {
        last10MatchesRating = last10MatchesRating.sublist(0, 10);
      }

      // Check for achievements
      _checkForAchievements(result);
    } catch (e) {
      debugPrint('Error updating statistics: $e');
      rethrow;
    }
  }

  void updatePartnershipStats(String partnerName, bool isWin) {
    try {
      partnershipMatches.update(
        partnerName,
        (value) => value + 1,
        ifAbsent: () => 1,
      );

      final wins = partnershipWinRate[partnerName] ?? 0;
      final total = partnershipMatches[partnerName] ?? 0;

      if (isWin) {
        partnershipWinRate[partnerName] = ((wins * total) + 100) / (total + 1);
      } else {
        partnershipWinRate[partnerName] = (wins * total) / (total + 1);
      }

      // Check for partnership achievements
      _checkPartnershipAchievements(partnerName);
    } catch (e) {
      debugPrint('Error updating partnership stats: $e');
      rethrow;
    }
  }

  void _checkForAchievements(MatchResult result) {
    // Win streak achievements
    if (currentStreak >= 5) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.winStreak,
        value: currentStreak,
      ));
    }

    // First win achievement
    if (wins == 1) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.firstWin,
      ));
    }

    // Perfect set achievement
    if (result.hasPerfectSet) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.perfectSet,
      ));
    }
  }

  void _checkPartnershipAchievements(String partnerName) {
    final matchesWithPartner = partnershipMatches[partnerName] ?? 0;
    final winRateWithPartner = partnershipWinRate[partnerName] ?? 0.0;

    // Add partnership-based achievements here
    if (matchesWithPartner >= 10 && winRateWithPartner >= 70) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.popularPlayer,
      ));
    }
  }

  // Helper method to get form string
  String getFormString() {
    return recentMatches.join('-');
  }

  // Helper method to get rating trend
  double getRatingTrend() {
    if (last10MatchesRating.length < 2) return 0;
    return last10MatchesRating.first - last10MatchesRating.last;
  }
}
// lib/models/match_scoring.dart

class MatchScoring {
  final Map<String, SetScore> teamScores = {
    'team1': SetScore(),
    'team2': SetScore(),
  };

  bool isMatchComplete = false;
  String? winner;
}

class SetScore {
  int sets;
  List<int> games;

  SetScore({
    this.sets = 0,
    this.games = const [],
  });

  bool isValidSet(int team1Games, int team2Games) {
    // One team must have at least 6 games
    if (team1Games < 6 && team2Games < 6) return false;

    // Regular set win (6-0 to 6-4)
    if (team1Games == 6 && team2Games <= 4) return true;
    if (team2Games == 6 && team1Games <= 4) return true;

    // 7-5 win
    if (team1Games == 7 && team2Games == 5) return true;
    if (team2Games == 7 && team1Games == 5) return true;

    // 7-6 tiebreak win
    if (team1Games == 7 && team2Games == 6) return true;
    if (team2Games == 7 && team1Games == 6) return true;

    return false;
  }
}
// For handling byte data
import 'package:flutter/foundation.dart'; // For kIsWeb detection
import 'package:image_picker/image_picker.dart'; // Cross-platform Image Picker

class ImagePickerService {
  final ImagePicker _picker = ImagePicker();

  /// Picks an image from the gallery
  Future<Uint8List?> pickImage() async {
    try {
      // Web-specific implementation
      if (kIsWeb) {
        final XFile? image =
            await _picker.pickImage(source: ImageSource.gallery);
        if (image != null) {
          return await image.readAsBytes(); // Returns image as bytes
        }
      } else {
        // Mobile-specific implementation
        final XFile? image = await _picker.pickImage(
          source: ImageSource.gallery,
          maxWidth: 512, // Resize to max width
          maxHeight: 512, // Resize to max height
          imageQuality: 75, // Compress image quality
        );
        if (image != null) {
          return await image.readAsBytes(); // Returns image as bytes
        }
      }
      return null; // No image selected
    } catch (e) {
      debugPrint('Error picking image: $e'); // Log the error
      return null;
    }
  }

  /// Takes a photo using the camera
  Future<Uint8List?> takePhoto() async {
    try {
      // Web-specific implementation (not supported)
      if (kIsWeb) {
        debugPrint('Camera is not supported on the web.'); // Log the message
        return null;
      } else {
        // Mobile-specific implementation
        final XFile? photo = await _picker.pickImage(
          source: ImageSource.camera,
          maxWidth: 512, // Resize to max width
          maxHeight: 512, // Resize to max height
          imageQuality: 75, // Compress image quality
        );
        if (photo != null) {
          return await photo.readAsBytes(); // Returns photo as bytes
        }
      }
      return null; // No photo taken
    } catch (e) {
      debugPrint('Error taking photo: $e'); // Log the error
      return null;
    }
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';

class FirebaseService {
  static FirebaseService? _instance;
  late final FirebaseFirestore firestore;
  late final FirebaseAuth auth;
  bool _initialized = false;

  // Private constructor
  FirebaseService._();

  static FirebaseService get instance {
    _instance ??= FirebaseService._();
    return _instance!;
  }

  Future<void> initialize() async {
    if (_initialized) return;

    try {
      // Just initialize the instances, don't initialize Firebase itself
      firestore = FirebaseFirestore.instance;
      auth = FirebaseAuth.instance;

      _initialized = true;
      debugPrint('Firebase Service initialized successfully');
    } catch (e) {
      debugPrint('Error initializing Firebase Service: $e');
      throw Exception('Failed to initialize Firebase Service: $e');
    }
  }

  bool get isInitialized => _initialized;

  // Helper method to reset instance (useful for testing)
  @visibleForTesting
  static void reset() {
    _instance = null;
  }

  // Get default instance of FirebaseFirestore
  static FirebaseFirestore get firestoreInstance {
    if (!instance._initialized) {
      throw StateError('FirebaseService must be initialized first');
    }
    return instance.firestore;
  }

  // Get default instance of FirebaseAuth
  static FirebaseAuth get authInstance {
    if (!instance._initialized) {
      throw StateError('FirebaseService must be initialized first');
    }
    return instance.auth;
  }

  // Helper method to check if user is signed in
  bool get isUserSignedIn => auth.currentUser != null;

  // Get current user
  User? get currentUser => auth.currentUser;

  // Sign out helper
  Future<void> signOut() async {
    if (!_initialized) {
      throw StateError('FirebaseService must be initialized first');
    }
    await auth.signOut();
  }

  // Get a Firestore document reference
  DocumentReference document(String path) {
    if (!_initialized) {
      throw StateError('FirebaseService must be initialized first');
    }
    return firestore.doc(path);
  }

  // Get a Firestore collection reference
  CollectionReference collection(String path) {
    if (!_initialized) {
      throw StateError('FirebaseService must be initialized first');
    }
    return firestore.collection(path);
  }

  // Handle any cleanup if needed
  Future<void> dispose() async {
    // Add any cleanup code here
    _initialized = false;
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import '../models/player.dart';
import '../models/match.dart';
import '../constants/app_constants.dart';
import 'data_service_interface.dart';
import 'firebase_service.dart'; // Importing the centralized FirebaseService

class FirestoreService implements DataServiceInterface {
  late final FirebaseFirestore _firestore;

  FirestoreService() {
    _firestore = FirebaseService.instance.firestore; // Use centralized service
  }

  // Player-related methods
  @override
  Stream<List<Player>> getPlayersStream() {
    try {
      debugPrint('Getting players stream from Firestore');
      return _firestore.collection('players').snapshots().map((snapshot) {
        final players =
            snapshot.docs.map((doc) => Player.fromFirestore(doc)).toList();
        debugPrint('Retrieved ${players.length} players');
        return players;
      });
    } catch (e) {
      debugPrint('Error getting players stream: $e');
      throw Exception('Failed to get players stream: $e');
    }
  }

  @override
  Future<List<Player>> getAllPlayers() async {
    try {
      debugPrint('Getting all players from Firestore');
      final snapshot = await _firestore.collection('players').get();
      final players =
          snapshot.docs.map((doc) => Player.fromFirestore(doc)).toList();
      debugPrint('Retrieved ${players.length} players');
      return players;
    } catch (e) {
      debugPrint('Error getting all players: $e');
      throw Exception('Failed to get all players: $e');
    }
  }

  // Booking-related methods
  @override
  Future<void> createBooking(
      String playerId, String day, String timeslot) async {
    try {
      debugPrint(
          'Creating booking for player: $playerId, day: $day, timeslot: $timeslot');

      // Delete existing booking if any
      final existingBookings = await _firestore
          .collection('bookings')
          .where('playerId', isEqualTo: playerId)
          .where('day', isEqualTo: day)
          .get();

      final batch = _firestore.batch();
      for (var doc in existingBookings.docs) {
        batch.delete(doc.reference);
      }

      // Create new booking
      final bookingRef = _firestore.collection('bookings').doc();
      final bookingData = {
        'playerId': playerId,
        'day': day,
        'timeslot': timeslot,
        'createdAt': FieldValue.serverTimestamp(),
      };

      batch.set(bookingRef, bookingData);
      await batch.commit();
      debugPrint('Successfully created booking for player: $playerId');
    } catch (e) {
      debugPrint('Error creating booking: $e');
      throw Exception('Failed to create booking: $e');
    }
  }

  @override
  Future<void> deletePlayerBookings(String playerId) async {
    try {
      debugPrint('Deleting bookings for player: $playerId');
      final snapshot = await _firestore
          .collection('bookings')
          .where('playerId', isEqualTo: playerId)
          .get();

      final batch = _firestore.batch();
      for (var doc in snapshot.docs) {
        batch.delete(doc.reference);
      }
      await batch.commit();
      debugPrint(
          'Deleted ${snapshot.docs.length} bookings for player: $playerId');
    } catch (e) {
      debugPrint('Error deleting player bookings: $e');
      throw Exception('Failed to delete player bookings: $e');
    }
  }

  @override
  Future<void> loadBookingsForDay(String day) async {
    try {
      debugPrint('Loading bookings for day: $day');
      final querySnapshot = await _firestore
          .collection('bookings')
          .where('day', isEqualTo: day)
          .get();
      debugPrint('Found ${querySnapshot.docs.length} bookings for $day');
    } catch (e) {
      debugPrint('Error loading bookings for day: $e');
      throw Exception('Failed to load bookings for day: $e');
    }
  }

  @override
  Future<void> loadBookingsForPlayer(String playerId) async {
    try {
      debugPrint('Loading bookings for player: $playerId');
      final querySnapshot = await _firestore
          .collection('bookings')
          .where('playerId', isEqualTo: playerId)
          .get();
      debugPrint(
          'Found ${querySnapshot.docs.length} bookings for player: $playerId');
    } catch (e) {
      debugPrint('Error loading bookings for player: $e');
      throw Exception('Failed to load bookings for player: $e');
    }
  }

  @override
  Stream<List<Map<String, dynamic>>> getBookingsForDay(String day) {
    try {
      debugPrint('Getting bookings stream for day: $day');
      return _firestore
          .collection('bookings')
          .where('day', isEqualTo: day)
          .snapshots()
          .map((snapshot) {
        final bookings =
            snapshot.docs.map((doc) => {'id': doc.id, ...doc.data()}).toList();
        debugPrint('Retrieved ${bookings.length} bookings for $day');
        return bookings;
      });
    } catch (e) {
      debugPrint('Error getting bookings for day: $e');
      throw Exception('Failed to get bookings for day: $e');
    }
  }

  // Match-related methods
  @override
  Future<void> createMatch({
    required DateTime date,
    required String time,
    required List<String> team1PlayerIds,
    required List<String> team2PlayerIds,
  }) async {
    try {
      debugPrint('Creating match in Firestore');

      final matchId = TimeslotConstants.formatMatchId(
          date.toIso8601String().split('T')[0], time);

      final matchData = {
        'id': matchId,
        'date': Timestamp.fromDate(date),
        'time': time,
        'status': team1PlayerIds.length + team2PlayerIds.length < 4
            ? 'waitingPlayers'
            : 'scheduled',
        'players': {
          'team1': {
            'player1': team1PlayerIds.isNotEmpty
                ? _firestore.doc('players/${team1PlayerIds[0]}')
                : null,
            'player2': team1PlayerIds.length > 1
                ? _firestore.doc('players/${team1PlayerIds[1]}')
                : null,
          },
          'team2': {
            'player1': team2PlayerIds.isNotEmpty
                ? _firestore.doc('players/${team2PlayerIds[0]}')
                : null,
            'player2': team2PlayerIds.length > 1
                ? _firestore.doc('players/${team2PlayerIds[1]}')
                : null,
          },
        },
        'score': {
          'team1': {'sets': 0, 'games': []},
          'team2': {'sets': 0, 'games': []},
        },
        'availableSlots': 4 - (team1PlayerIds.length + team2PlayerIds.length),
        'createdAt': FieldValue.serverTimestamp(),
      };

      await _firestore.collection('matches').doc(matchId).set(matchData);
      debugPrint('Successfully created match: $matchId');
    } catch (e) {
      debugPrint('Error creating match: $e');
      throw Exception('Failed to create match: $e');
    }
  }

  Future<void> deleteMatch(String matchId) async {
    try {
      debugPrint('Deleting match: $matchId');
      await _firestore.collection('matches').doc(matchId).delete();
      debugPrint('Successfully deleted match: $matchId');
    } catch (e) {
      debugPrint('Error deleting match: $e');
      throw Exception('Failed to delete match: $e');
    }
  }

  @override
  Stream<List<Match>> getMatchesStream() {
    try {
      debugPrint('Getting matches stream');
      return _firestore
          .collection('matches')
          .snapshots()
          .asyncMap((snapshot) async {
        final players = await getAllPlayers();
        final matches = snapshot.docs
            .map((doc) => Match.fromFirestore(doc, players))
            .toList();
        debugPrint('Retrieved ${matches.length} matches from stream');
        return matches;
      });
    } catch (e) {
      debugPrint('Error getting matches stream: $e');
      throw Exception('Failed to get matches stream: $e');
    }
  }

  @override
  Future<List<Match>> getAllMatches() async {
    try {
      debugPrint('Getting all matches');
      final snapshot = await _firestore.collection('matches').get();
      final players = await getAllPlayers();
      final matches = snapshot.docs
          .map((doc) => Match.fromFirestore(doc, players))
          .toList();
      debugPrint('Retrieved ${matches.length} matches');
      return matches;
    } catch (e) {
      debugPrint('Error getting all matches: $e');
      throw Exception('Failed to get all matches: $e');
    }
  }

  @override
  Future<void> updateMatchScore(
    String matchId,
    String team,
    String type,
    dynamic value,
  ) async {
    try {
      debugPrint('Updating score for match $matchId: $team.$type = $value');
      await _firestore
          .collection('matches')
          .doc(matchId)
          .update({'score.$team.$type': value});
      debugPrint('Successfully updated match score');
    } catch (e) {
      debugPrint('Error updating match score: $e');
      throw Exception('Failed to update match score: $e');
    }
  }

  @override
  Future<void> updateMatchStatus(String matchId, MatchStatus status) async {
    try {
      debugPrint('Updating status for match $matchId to ${status.toString()}');
      await _firestore.collection('matches').doc(matchId).update({
        'status': status.toString().split('.').last,
      });
      debugPrint('Successfully updated match status');
    } catch (e) {
      debugPrint('Error updating match status: $e');
      throw Exception('Failed to update match status: $e');
    }
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import '../models/match.dart';
import 'firebase_service.dart';

class StatisticsService {
  final FirebaseFirestore _firestore;

  StatisticsService() : _firestore = FirebaseService.instance.firestore;

  Future<void> updateMatchStatistics(Match match) async {
    if (match.status != MatchStatus.completed) return;

    try {
      debugPrint('Updating statistics for match: ${match.id}');
      final batch = _firestore.batch();

      await Future.wait([
        if (match.team1Player1 != null)
          _updatePlayerStatsInBatch(
              batch, match.team1Player1!.id, match, 'team1'),
        if (match.team1Player2 != null)
          _updatePlayerStatsInBatch(
              batch, match.team1Player2!.id, match, 'team1'),
        if (match.team2Player1 != null)
          _updatePlayerStatsInBatch(
              batch, match.team2Player1!.id, match, 'team2'),
        if (match.team2Player2 != null)
          _updatePlayerStatsInBatch(
              batch, match.team2Player2!.id, match, 'team2'),
      ]);

      await batch.commit();
      debugPrint('Successfully updated statistics for match: ${match.id}');
    } catch (e) {
      debugPrint('Error updating match statistics: $e');
      throw Exception('Failed to update match statistics: $e');
    }
  }

  Future<void> _updatePlayerStatsInBatch(
    WriteBatch batch,
    String playerId,
    Match match,
    String team,
  ) async {
    try {
      final playerRef = _firestore.collection('players').doc(playerId);
      final playerDoc = await playerRef.get();

      if (!playerDoc.exists) {
        debugPrint('Player document not found: $playerId');
        return;
      }

      Map<String, dynamic> data = playerDoc.data() ?? {};
      Map<String, dynamic> stats =
          (data['statistics'] as Map<String, dynamic>?) ?? {};
      final String opposingTeam = team == 'team1' ? 'team2' : 'team1';

      // Initial rating logging
      double initialRating = (stats['rating'] as num?)?.toDouble() ?? 0.0;
      debugPrint('Player $playerId - Initial Rating: $initialRating');

      // Game calculations
      List<int> playerGames = List<int>.from(match.score[team]?.games ?? []);
      List<int> opponentGames =
          List<int>.from(match.score[opposingTeam]?.games ?? []);
      int gamesWonTotal = playerGames.fold(0, (sum, game) => sum + game);
      int gamesLostTotal = opponentGames.fold(0, (sum, game) => sum + game);

      // Match outcome determination
      String? matchWinner = match.winner;
      bool isWinner = matchWinner == team;
      bool isDraw = matchWinner == null;

      // Points calculation
      double pointsEarned = 0.15; // Base points for participating
      debugPrint('Base participation points: +0.15');

      if (isWinner) {
        stats['wins'] = (stats['wins'] as int? ?? 0) + 1;
        pointsEarned += 0.9;
        debugPrint('Win bonus: +0.9');
      } else if (isDraw) {
        stats['draws'] = (stats['draws'] as int? ?? 0) + 1;
        pointsEarned += 0.2;
        debugPrint('Draw bonus: +0.2');
      } else {
        stats['losses'] = (stats['losses'] as int? ?? 0) + 1;
        pointsEarned -= 1.0;
        debugPrint('Loss penalty: -1.0');
      }

      // Update match statistics
      stats['setsWon'] =
          (stats['setsWon'] as int? ?? 0) + (match.score[team]?.sets ?? 0);
      stats['setsLost'] = (stats['setsLost'] as int? ?? 0) +
          (match.score[opposingTeam]?.sets ?? 0);
      stats['gamesWon'] = (stats['gamesWon'] as int? ?? 0) + gamesWonTotal;
      stats['gamesLost'] = (stats['gamesLost'] as int? ?? 0) + gamesLostTotal;

      // Update form
      List<String> recentMatches =
          List<String>.from(stats['recentMatches'] as List<dynamic>? ?? []);
      recentMatches.insert(0, isWinner ? 'W' : (isDraw ? 'D' : 'L'));
      if (recentMatches.length > 5) {
        recentMatches = recentMatches.sublist(0, 5);
      }
      stats['recentMatches'] = recentMatches;

      // Update streaks
      int currentStreak = stats['currentStreak'] as int? ?? 0;
      if (isWinner) {
        currentStreak = currentStreak >= 0 ? currentStreak + 1 : 1;
      } else if (isDraw) {
        currentStreak = 0;
      } else {
        currentStreak = currentStreak <= 0 ? currentStreak - 1 : -1;
      }
      stats['currentStreak'] = currentStreak;

      // Calculate win rate
      int totalMatches = (stats['wins'] as int? ?? 0) +
          (stats['losses'] as int? ?? 0) +
          (stats['draws'] as int? ?? 0);
      stats['winRate'] = totalMatches > 0
          ? ((stats['wins'] as int? ?? 0) / totalMatches) * 100
          : 0.0;

      // Update final rating
      stats['rating'] = initialRating + pointsEarned;
      debugPrint('Final Rating: ${stats['rating']} (Change: $pointsEarned)');

      // Update rating history
      List<double> ratingHistory = List<double>.from(
          stats['last10MatchesRating'] as List<dynamic>? ?? []);
      ratingHistory.insert(0, stats['rating'] as double);
      if (ratingHistory.length > 10) {
        ratingHistory = ratingHistory.sublist(0, 10);
      }
      stats['last10MatchesRating'] = ratingHistory;

      // Update partnerships
      _updatePartnershipStats(stats, match, team, playerId, isWinner);

      // Commit updates
      batch.update(playerRef, {
        'statistics': stats,
        'lastMatchDate': FieldValue.serverTimestamp(),
      });

      debugPrint('Added statistics update for player: $playerId');
    } catch (e) {
      debugPrint('Error updating stats for player $playerId: $e');
      throw Exception('Failed to update player statistics: $e');
    }
  }

  void _updatePartnershipStats(Map<String, dynamic> stats, Match match,
      String team, String playerId, bool isWin) {
    try {
      stats['partnershipMatches'] =
          (stats['partnershipMatches'] as Map<String, dynamic>?) ?? {};
      stats['partnershipWinRate'] =
          (stats['partnershipWinRate'] as Map<String, dynamic>?) ?? {};

      String? partnerName;
      if (team == 'team1') {
        partnerName = match.team1Player2?.name;
      } else {
        partnerName = match.team2Player2?.name;
      }

      if (partnerName != null) {
        stats['partnershipMatches'][partnerName] =
            (stats['partnershipMatches'][partnerName] as int? ?? 0) + 1;

        int totalMatches = stats['partnershipMatches'][partnerName] as int;
        double currentWinRate =
            stats['partnershipWinRate'][partnerName] as double? ?? 0.0;

        if (isWin) {
          stats['partnershipWinRate'][partnerName] =
              ((currentWinRate * (totalMatches - 1)) + 100) / totalMatches;
        } else {
          stats['partnershipWinRate'][partnerName] =
              (currentWinRate * (totalMatches - 1)) / totalMatches;
        }
      }
    } catch (e) {
      debugPrint('Error updating partnership stats: $e');
    }
  }
}
import '../models/player.dart';
import '../models/match.dart';
import 'data_service_interface.dart';
import 'package:flutter/foundation.dart';

class MockDataService implements DataServiceInterface {
  final List<Match> _matches = [];
  final List<Player> _players = [
    Player(
      id: "1",
      name: "John Smith",
      rating: 4.5,
      rank: 1,
      profileImage: "assets/images/profile.png",
      createdAt: DateTime.now(),
    ),
    Player(
      id: "2",
      name: "Maria Garcia",
      rating: 4.3,
      rank: 2,
      profileImage: "assets/images/profile.png",
      createdAt: DateTime.now(),
    ),
  ];
  final List<Map<String, dynamic>> _bookings = [];

  @override
  Stream<List<Player>> getPlayersStream() {
    return Stream.value(_players);
  }

  @override
  Future<List<Player>> getAllPlayers() async {
    return _players;
  }

  @override
  Future<void> createBooking(
      String playerId, String day, String timeslot) async {
    _bookings.add({
      'id': DateTime.now().millisecondsSinceEpoch.toString(),
      'playerId': playerId,
      'day': day,
      'timeslot': timeslot,
      'createdAt': DateTime.now().toIso8601String(),
    });
  }

  @override
  Stream<List<Map<String, dynamic>>> getBookingsForDay(String day) {
    return Stream.value(
      _bookings.where((booking) => booking['day'] == day).toList(),
    );
  }

  @override
  Future<void> loadBookingsForPlayer(String playerId) async {
    // In mock service, data is already in memory
    return;
  }

  @override
  Future<void> deletePlayerBookings(String playerId) async {
    _bookings.removeWhere((booking) => booking['playerId'] == playerId);
  }

  @override
  Future<void> createMatch({
    required DateTime date,
    required String time,
    required List<String> team1PlayerIds,
    required List<String> team2PlayerIds,
  }) async {
    final match = Match(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      date: date,
      time: time,
      status: MatchStatus.scheduled,
      players: {
        'team1_player1': _players.firstWhere((p) => p.id == team1PlayerIds[0]),
        'team1_player2': _players.firstWhere((p) => p.id == team1PlayerIds[1]),
        'team2_player1': _players.firstWhere((p) => p.id == team2PlayerIds[0]),
        'team2_player2': _players.firstWhere((p) => p.id == team2PlayerIds[1]),
      },
      score: {
        'team1': Score(sets: 0, games: []),
        'team2': Score(sets: 0, games: []),
      },
      createdAt: DateTime.now(),
    );
    _matches.add(match);
  }

  // Helper method to create a mock match
  Match createMockMatch({
    int availablePlayers = 0,
    String? specificDay,
    String? specificTime,
  }) {
    final playersNeeded = 4 - availablePlayers;
    final Map<String, Player?> matchPlayers = {};

    // Add available players first
    for (var i = 0; i < availablePlayers && i < _players.length; i++) {
      final position = i < 2 ? 'team1_player${i + 1}' : 'team2_player${i - 1}';
      matchPlayers[position] = _players[i];
    }

    // Fill remaining slots with null
    final positions = [
      'team1_player1',
      'team1_player2',
      'team2_player1',
      'team2_player2'
    ];
    for (var position in positions) {
      if (!matchPlayers.containsKey(position)) {
        matchPlayers[position] = null;
      }
    }

    return Match(
      id: 'mock_match_${DateTime.now().millisecondsSinceEpoch}',
      date: DateTime.now(),
      time: specificTime ?? 'Later Timeslot',
      status: playersNeeded > 0
          ? MatchStatus.waitingPlayers
          : MatchStatus.scheduled,
      players: matchPlayers,
      score: {
        'team1': Score(sets: 0, games: []),
        'team2': Score(sets: 0, games: []),
      },
      createdAt: DateTime.now(),
      availableSlots: playersNeeded,
    );
  }

  @override
  Stream<List<Match>> getMatchesStream() {
    return Stream.value(_matches);
  }

  @override
  Future<List<Match>> getAllMatches() async {
    return _matches;
  }

  @override
  Future<void> updateMatchScore(
    String matchId,
    String team,
    String type,
    dynamic value,
  ) async {
    final matchIndex = _matches.indexWhere((m) => m.id == matchId);
    if (matchIndex == -1) return;

    final match = _matches[matchIndex];
    final newScore = Map<String, Score>.from(match.score);

    if (type == 'sets') {
      newScore[team] = newScore[team]!.copyWith(sets: value as int);
    } else if (type == 'games') {
      newScore[team] = newScore[team]!.copyWith(games: value as List<int>);
    }

    _matches[matchIndex] = match.copyWith(score: newScore);

    // Update player statistics
    _updatePlayerStats(match, team);
  }

  void _updatePlayerStats(Match match, String team) {
    final isWinner = match.score[team]!.sets >
        match.score[team == 'team1' ? 'team2' : 'team1']!.sets;

    // Update stats for both players on the team
    final player1 = match.players['${team}_player1'];
    final player2 = match.players['${team}_player2'];

    if (player1 != null) {
      _updateSinglePlayerStats(player1, isWinner, match, team);
    }
    if (player2 != null) {
      _updateSinglePlayerStats(player2, isWinner, match, team);
    }
  }

  void _updateSinglePlayerStats(
      Player player, bool isWinner, Match match, String team) {
    final playerIndex = _players.indexWhere((p) => p.id == player.id);
    if (playerIndex == -1) return;

    final updatedPlayer = _players[playerIndex];
    if (isWinner) {
      updatedPlayer.statistics.wins++;
    } else {
      updatedPlayer.statistics.losses++;
    }

    // Update sets and games
    final teamScore = match.score[team]!;
    final opposingScore = match.score[team == 'team1' ? 'team2' : 'team1']!;

    updatedPlayer.statistics.setsWon += teamScore.sets;
    updatedPlayer.statistics.setsLost += opposingScore.sets;

    updatedPlayer.statistics.gamesWon +=
        teamScore.games.fold(0, (sum, game) => sum + game);
    updatedPlayer.statistics.gamesLost +=
        opposingScore.games.fold(0, (sum, game) => sum + game);

    // Update win rate
    final totalMatches =
        updatedPlayer.statistics.wins + updatedPlayer.statistics.losses;
    if (totalMatches > 0) {
      updatedPlayer.statistics.winRate =
          (updatedPlayer.statistics.wins / totalMatches) * 100;
    }

    _players[playerIndex] = updatedPlayer;
  }

  @override
  Future<void> updateMatchStatus(String matchId, MatchStatus status) async {
    final matchIndex = _matches.indexWhere((m) => m.id == matchId);
    if (matchIndex == -1) return;

    _matches[matchIndex] = _matches[matchIndex].copyWith(status: status);
  }

  @override
  Future<void> loadBookingsForDay(String day) async {
    try {
      debugPrint('Loading bookings for day: $day');
      // In mock service, data is already in memory
      // Just simulate async operation
      await Future.delayed(const Duration(milliseconds: 100));
    } catch (e) {
      debugPrint('Error loading bookings for day: $e');
      throw Exception('Failed to load bookings for day: $e');
    }
  }
}
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/player.dart';
import '../models/match.dart';
import '../constants/app_constants.dart';
import 'firebase_service.dart';

class MatchMaker {
  static Future<List<Match>> createMatchesFromBookings(
    List<Map<String, dynamic>> bookings,
    List<Player> players,
    String timeslot,
    String day,
  ) async {
    try {
      debugPrint(
          'Creating matches for $day $timeslot with ${bookings.length} bookings');

      final FirebaseFirestore firestore = FirebaseService.instance.firestore;

      // Get booked players for this timeslot
      final bookedPlayers = players.where((player) {
        return bookings.any((booking) =>
            booking['playerId'] == player.id &&
            (booking['timeslot'] == timeslot ||
                booking['timeslot'] == TimeslotConstants.playEither));
      }).toList();

      debugPrint('Found ${bookedPlayers.length} players for $timeslot');

      if (bookedPlayers.isEmpty) return [];

      // Sort players by rating for balanced teams
      bookedPlayers.sort((a, b) => b.rating.compareTo(a.rating));

      // Create a match document in Firestore
      final matchId =
          '${day.toLowerCase()}_${timeslot.replaceAll(' ', '_').toLowerCase()}_${DateTime.now().millisecondsSinceEpoch}';

      // Prepare player assignments
      Map<String, Player?> matchPlayers = {
        'team1_player1': bookedPlayers.isNotEmpty ? bookedPlayers[0] : null,
        'team1_player2': bookedPlayers.length > 2 ? bookedPlayers[2] : null,
        'team2_player1': bookedPlayers.length > 1 ? bookedPlayers[1] : null,
        'team2_player2': bookedPlayers.length > 3 ? bookedPlayers[3] : null,
      };

      final matchData = {
        'id': matchId,
        'date': Timestamp.fromDate(DateTime.now()),
        'time': timeslot,
        'status': bookedPlayers.length < 4 ? 'waitingPlayers' : 'scheduled',
        'players': {
          'team1': {
            'player1': matchPlayers['team1_player1'] != null
                ? firestore.doc('players/${matchPlayers['team1_player1']!.id}')
                : null,
            'player2': matchPlayers['team1_player2'] != null
                ? firestore.doc('players/${matchPlayers['team1_player2']!.id}')
                : null,
          },
          'team2': {
            'player1': matchPlayers['team2_player1'] != null
                ? firestore.doc('players/${matchPlayers['team2_player1']!.id}')
                : null,
            'player2': matchPlayers['team2_player2'] != null
                ? firestore.doc('players/${matchPlayers['team2_player2']!.id}')
                : null,
          },
        },
        'score': {
          'team1': {'sets': 0, 'games': []},
          'team2': {'sets': 0, 'games': []},
        },
        'availableSlots': 4 - bookedPlayers.length,
        'createdAt': FieldValue.serverTimestamp(),
      };

      // Create the match in Firestore
      await firestore.collection('matches').doc(matchId).set(matchData);
      debugPrint('Created match document with ID: $matchId');

      // Return Match object
      return [
        Match(
          id: matchId,
          date: DateTime.now(),
          time: timeslot,
          status: bookedPlayers.length < 4
              ? MatchStatus.waitingPlayers
              : MatchStatus.scheduled,
          players: matchPlayers,
          score: {
            'team1': Score(sets: 0, games: []),
            'team2': Score(sets: 0, games: []),
          },
          createdAt: DateTime.now(),
          availableSlots: 4 - bookedPlayers.length,
        )
      ];
    } catch (e) {
      debugPrint('Error creating matches: $e');
      return [];
    }
  }

  static void showInsufficientPlayersDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Creating Match'),
          content: const Text(
              'Match will be created with available players. More players can join later.'),
          actions: <Widget>[
            TextButton(
              child: const Text('OK'),
              onPressed: () => Navigator.of(context).pop(),
            ),
          ],
        );
      },
    );
  }
}
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'firebase_service.dart'; // Importing the centralized FirebaseService

class AuthService {
  late final FirebaseAuth _auth;

  AuthService() {
    _auth = FirebaseService.instance.auth; // Use centralized service
  }

  // Register with email and password
  Future<UserCredential> registerWithEmailAndPassword(
      String email, String password) async {
    final lowercaseEmail = email.trim().toLowerCase();
    try {
      debugPrint('Registering user with email: $lowercaseEmail');
      return await _auth.createUserWithEmailAndPassword(
        email: lowercaseEmail,
        password: password.trim(),
      );
    } on FirebaseAuthException catch (e) {
      debugPrint('FirebaseAuthException: ${e.code} - ${e.message}');
      throw _handleAuthException(e, action: 'Registration');
    } catch (e) {
      debugPrint('Exception during registration: $e');
      throw Exception('Registration failed: $e');
    }
  }

  // Sign in with email and password
  Future<UserCredential> signInWithEmailAndPassword(
      String email, String password) async {
    final lowercaseEmail = email.trim().toLowerCase();
    try {
      debugPrint('Attempting login for email: $lowercaseEmail');
      return await _auth.signInWithEmailAndPassword(
        email: lowercaseEmail,
        password: password.trim(),
      );
    } on FirebaseAuthException catch (e) {
      debugPrint('FirebaseAuthException: ${e.code} - ${e.message}');
      throw _handleAuthException(e, action: 'Login');
    } catch (e) {
      debugPrint('Exception during login: $e');
      throw Exception('Login failed: $e');
    }
  }

  // Sign out
  Future<void> signOut() async {
    try {
      await _auth.signOut();
      debugPrint('User signed out successfully');
    } catch (e) {
      debugPrint('Sign-out failed: $e');
      throw Exception('Sign-out failed: $e');
    }
  }

  // Get current user ID
  String? getCurrentUserId() {
    return _auth.currentUser?.uid;
  }

  // Get current user object
  User? get currentUser => _auth.currentUser;

  // Stream of authentication state changes
  Stream<User?> get authStateChanges => _auth.authStateChanges();

  // Private helper for FirebaseAuthException handling
  Exception _handleAuthException(FirebaseAuthException e,
      {required String action}) {
    switch (e.code) {
      case 'weak-password':
        return Exception('The password provided is too weak.');
      case 'email-already-in-use':
        return Exception('This email is already registered.');
      case 'invalid-email':
        return Exception('The email address is not valid.');
      case 'operation-not-allowed':
        return Exception(
            'Email/password accounts are not enabled. Please contact support.');
      case 'user-not-found':
        return Exception('No user found for that email.');
      case 'wrong-password':
        return Exception('Wrong password provided.');
      case 'user-disabled':
        return Exception('This user account has been disabled.');
      default:
        return Exception('$action failed: ${e.message}');
    }
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/user_model.dart';
import 'firebase_service.dart';

class UserService {
  final FirebaseFirestore _firestore;

  UserService() : _firestore = FirebaseService.instance.firestore;

  Future<void> createUser(UserModel user) async {
    try {
      await _firestore.collection('users').doc(user.id).set(user.toMap());
    } catch (e) {
      throw Exception('Failed to create user: $e');
    }
  }

  Future<UserModel?> getUser(String userId) async {
    try {
      final doc = await _firestore.collection('users').doc(userId).get();
      if (doc.exists) {
        return UserModel.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      throw Exception('Failed to get user: $e');
    }
  }

  Future<void> updateUser(UserModel user) async {
    try {
      await _firestore.collection('users').doc(user.id).update(user.toMap());
    } catch (e) {
      throw Exception('Failed to update user: $e');
    }
  }
}
import '../models/player.dart';
import '../models/match.dart';

abstract class DataServiceInterface {
  Stream<List<Player>> getPlayersStream();
  Future<List<Player>> getAllPlayers();
  Future<void> createBooking(String playerId, String day, String timeslot);
  Stream<List<Map<String, dynamic>>> getBookingsForDay(String day);

  Future<void> loadBookingsForDay(String day);
  Future<void> loadBookingsForPlayer(String playerId);
  Future<void> deletePlayerBookings(String playerId);
  Future<void> createMatch({
    required DateTime date,
    required String time,
    required List<String> team1PlayerIds,
    required List<String> team2PlayerIds,
  });
  Stream<List<Match>> getMatchesStream();
  Future<List<Match>> getAllMatches();
  Future<void> updateMatchScore(
      String matchId, String team, String type, dynamic value);
  Future<void> updateMatchStatus(String matchId, MatchStatus status);
}
import 'package:flutter/foundation.dart';
import '../models/player.dart';
import '../models/match.dart';
import '../services/data_service_interface.dart';
import '../services/firestore_service.dart';
import '../services/statistics_service.dart';
import '../services/match_maker.dart';
import '../constants/app_constants.dart';

class AppState extends ChangeNotifier {
  final DataServiceInterface _dataService;
  final FirestoreService _firestoreService;
  final StatisticsService _statisticsService = StatisticsService();

  List<Player> _players = [];
  List<Match> _matches = [];
  final Map<String, List<Map<String, dynamic>>> _bookings = {};
  bool _isLoading = false;
  String? _error;
  bool _isInitialized = false;
  final Set<String> _initializedDays = {};

  AppState(this._dataService, this._firestoreService) {
    initializeStreams();
  }

  // Getters
  List<Player> get players => _players;
  List<Match> get matches => _matches;
  Map<String, List<Map<String, dynamic>>> get bookings => _bookings;
  bool get isLoading => _isLoading;
  String? get error => _error;

  void initializeStreams() {
    if (_isInitialized) return;
    try {
      debugPrint('Initializing streams');
      _cleanupSubscriptions();

      // Set up player stream once
      _dataService.getPlayersStream().listen((players) {
        _players = players;
        notifyListeners();
      });

      // Set up match stream once
      _firestoreService.getMatchesStream().listen((matches) {
        _matches = matches;
        notifyListeners();
      });

      _isInitialized = true;
      _initializeBookings();
    } catch (e) {
      debugPrint('Error initializing streams: $e');
      setError('Error initializing data streams: $e');
    }
  }

  Future<void> syncAllData() async {
    try {
      setLoading(true); // Set the loading state
      final days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

      debugPrint('Starting full data sync');

      // Refresh all bookings
      await Future.wait(days.map((day) => _refreshBookingsForDay(day)));

      // Create matches for each day
      for (final day in days) {
        await _createMatchesForDay(day);
      }

      // Final refresh of matches
      await refreshMatches();

      debugPrint('Data sync completed');
    } catch (e) {
      debugPrint('Error syncing data: $e');
      setError('Error syncing data: $e');
    } finally {
      setLoading(false); // Reset the loading state
    }
  }

  Future<void> _initializeBookings() async {
    debugPrint('Initializing bookings');
    final days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
    for (final day in days) {
      if (!_initializedDays.contains(day)) {
        await loadBookingsForDay(day);
      }
    }
  }

  Future<void> loadBookingsForDay(String day) async {
    try {
      debugPrint('Loading bookings for day: $day');
      setLoading(true);

      final bookings = await _dataService.getBookingsForDay(day).first;
      _bookings[day] = bookings;
      _initializedDays.add(day);

      notifyListeners();
    } catch (e) {
      debugPrint('Error loading bookings for day: $day');
      setError('Error loading bookings for day: $e');
    } finally {
      setLoading(false);
    }
  }

  Future<void> createBooking(
      String playerId, String day, String timeslot) async {
    try {
      setLoading(true);
      debugPrint('Creating booking for player $playerId on $day at $timeslot');

      // Create the booking
      await _dataService.createBooking(playerId, day, timeslot);

      // Only refresh this day's bookings
      await _refreshBookingsForDay(day);

      // Allow time for Firestore to sync
      await Future.delayed(const Duration(milliseconds: 300));

      // Create matches only for this day
      await _createMatchesForDay(day);

      notifyListeners();
    } catch (e) {
      debugPrint('Error creating booking: $e');
      setError('Error creating booking: $e');
    } finally {
      setLoading(false);
    }
  }

  Future<void> deletePlayerBookings(String playerId) async {
    try {
      setLoading(true);
      debugPrint('Deleting bookings for player $playerId');

      await _firestoreService.deletePlayerBookings(playerId);

      // Refresh only necessary data
      final days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
      for (final day in days) {
        await _refreshBookingsForDay(day);
        await _createMatchesForDay(day);
      }

      notifyListeners();
    } catch (e) {
      debugPrint('Error deleting player bookings: $e');
      setError('Error deleting player bookings: $e');
    } finally {
      setLoading(false);
    }
  }

  Future<void> _createMatchesForDay(String day) async {
    try {
      debugPrint('Creating matches for day: $day');
      final dayBookings = _bookings[day] ?? [];

      if (dayBookings.isEmpty) {
        debugPrint('No bookings found for $day');
        return;
      }

      // Check if we need to create matches
      final hasEarlyBookings = dayBookings.any((b) =>
          b['timeslot'] == TimeslotConstants.earlyTimeslot ||
          b['timeslot'] == TimeslotConstants.playEither);

      final hasLaterBookings = dayBookings.any((b) =>
          b['timeslot'] == TimeslotConstants.laterTimeslot ||
          b['timeslot'] == TimeslotConstants.playEither);

      // Only delete if we have bookings
      if (hasEarlyBookings || hasLaterBookings) {
        await _deleteMatchesForDay(day);
      }

      if (hasEarlyBookings) {
        final earlyBookings = dayBookings
            .where((b) =>
                b['timeslot'] == TimeslotConstants.earlyTimeslot ||
                b['timeslot'] == TimeslotConstants.playEither)
            .toList();

        if (earlyBookings.length >= 2) {
          debugPrint(
              'Creating early matches with ${earlyBookings.length} players');
          await MatchMaker.createMatchesFromBookings(
            earlyBookings,
            _players,
            TimeslotConstants.earlyTimeslot,
            day,
          );
        }
      }

      if (hasLaterBookings) {
        final laterBookings = dayBookings
            .where((b) =>
                b['timeslot'] == TimeslotConstants.laterTimeslot ||
                b['timeslot'] == TimeslotConstants.playEither)
            .toList();

        if (laterBookings.length >= 2) {
          debugPrint(
              'Creating later matches with ${laterBookings.length} players');
          await MatchMaker.createMatchesFromBookings(
            laterBookings,
            _players,
            TimeslotConstants.laterTimeslot,
            day,
          );
        }
      }

      await refreshMatches();
    } catch (e) {
      debugPrint('Error creating matches for day: $e');
      setError('Error creating matches for day: $e');
    }
  }

  Future<void> _refreshBookingsForDay(String day) async {
    try {
      debugPrint('Refreshing bookings for $day');
      final bookings = await _dataService.getBookingsForDay(day).first;
      _bookings[day] = bookings;
      _initializedDays.add(day);
      notifyListeners();
    } catch (e) {
      debugPrint('Error refreshing bookings for $day: $e');
      setError('Error refreshing bookings for $day: $e');
    }
  }

  Future<void> refreshMatches() async {
    try {
      debugPrint('Refreshing matches');
      _matches = await _dataService.getAllMatches();
      notifyListeners();
    } catch (e) {
      debugPrint('Error refreshing matches: $e');
      setError('Error refreshing matches: $e');
    }
  }

  Future<void> _deleteMatchesForDay(String day) async {
    try {
      debugPrint('Deleting matches for $day');
      final matchesToDelete = _matches
          .where((match) => match.id.toLowerCase().contains(day.toLowerCase()))
          .toList();

      for (var match in matchesToDelete) {
        await _firestoreService.deleteMatch(match.id);
      }
      debugPrint('Deleted ${matchesToDelete.length} matches for $day');
    } catch (e) {
      debugPrint('Error deleting matches for $day: $e');
      setError('Error deleting matches for $day: $e');
    }
  }

  Future<void> updateMatchScore(
      String matchId, String team, String type, dynamic value) async {
    try {
      await _firestoreService.updateMatchScore(matchId, team, type, value);

      final match = _matches.firstWhere((m) => m.id == matchId);
      if (match.isComplete) {
        await _statisticsService.updateMatchStatistics(match);
      }
      await refreshMatches();
    } catch (e) {
      debugPrint('Error updating match score: $e');
      setError('Error updating match score: $e');
    }
  }

  Future<void> updateMatchStatus(String matchId, MatchStatus status) async {
    try {
      await _firestoreService.updateMatchStatus(matchId, status);

      if (status == MatchStatus.completed) {
        final match = _matches.firstWhere((m) => m.id == matchId);
        await _statisticsService.updateMatchStatistics(match);
        await refreshMatches();
      }
    } catch (e) {
      debugPrint('Error updating match status: $e');
      setError('Error updating match status: $e');
    }
  }

  void setLoading(bool value) {
    _isLoading = value;
    notifyListeners();
  }

  void setError(String? errorMessage) {
    _error = errorMessage;
    notifyListeners();
  }

  void _cleanupSubscriptions() {
    debugPrint('Cleaning up subscriptions');
    _players = [];
    _matches = [];
    _bookings.clear();
    _initializedDays.clear();
    _error = null;
    _isInitialized = false;
  }

  @override
  void dispose() {
    _cleanupSubscriptions();
    super.dispose();
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/player.dart';

class PlayersProvider extends ChangeNotifier {
  List<Player> _players = [];
  List<Player> get players => _players;

  void setPlayers(List<Player> players) {
    _players = players;
    notifyListeners();
  }

  void addPlayer(Player player) {
    _players.add(player);
    notifyListeners();
  }

  void updatePlayer(Player updatedPlayer) {
    final index = _players.indexWhere((p) => p.id == updatedPlayer.id);
    if (index != -1) {
      _players[index] = updatedPlayer;
      notifyListeners();
    }
  }

  void removePlayer(String playerId) {
    _players.removeWhere((p) => p.id == playerId);
    notifyListeners();
  }
}

// Provider configuration
List<ChangeNotifierProvider> get appProviders {
  return [
    ChangeNotifierProvider<PlayersProvider>(
      create: (_) => PlayersProvider(),
    ),
  ];
}
class TimeslotConstants {
  static const String earlyTimeslot = 'Early Timeslot';
  static const String laterTimeslot = 'Later Timeslot';
  static const String playEither = 'Play Either';

  static String formatMatchId(String day, String timeslot) {
    final formattedTimeslot = timeslot.replaceAll(' ', '_').toLowerCase();
    return 'match_${day.toLowerCase()}_${formattedTimeslot}_${DateTime.now().millisecondsSinceEpoch}';
  }

  static String formatBookingId(String playerId, String day) {
    return 'booking_${playerId}_${day.toLowerCase()}';
  }
}
import 'package:flutter/material.dart';

class ErrorView extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;

  const ErrorView({
    super.key,
    required this.message,
    this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              color: Colors.red[300],
              size: 60,
            ),
            const SizedBox(height: 16),
            Text(
              message,
              textAlign: TextAlign.center,
              style: const TextStyle(
                fontSize: 16,
                color: Colors.grey,
              ),
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: const Text('Try Again'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 24,
                    vertical: 12,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

class LoadingView extends StatelessWidget {
  final String? message;

  const LoadingView({
    super.key,
    this.message,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(),
          if (message != null) ...[
            const SizedBox(height: 16),
            Text(
              message!,
              style: const TextStyle(
                color: Colors.grey,
                fontSize: 16,
              ),
            ),
          ],
        ],
      ),
    );
  }
}

class AsyncView<T> extends StatelessWidget {
  final Future<T> future;
  final Widget Function(T data) onData;
  final Widget Function(String error)? onError;
  final Widget Function()? onLoading;

  const AsyncView({
    super.key,
    required this.future,
    required this.onData,
    this.onError,
    this.onLoading,
  });

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<T>(
      future: future,
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          return onError?.call(snapshot.error.toString()) ??
              ErrorView(
                message: snapshot.error.toString(),
                onRetry: () {
                  // Rebuild the widget to retry the future
                  (context as Element).markNeedsBuild();
                },
              );
        }

        if (snapshot.hasData) {
          return onData(snapshot.data as T);
        }

        return onLoading?.call() ?? const LoadingView();
      },
    );
  }
}
import 'package:flutter/material.dart';
import 'dart:math';

class ProfileImageWidget extends StatelessWidget {
  final String imageUrl;
  final String name;
  final double size;
  final Color? borderColor;
  final VoidCallback? onTap;
  final bool isEditable;

  const ProfileImageWidget({
    super.key,
    required this.imageUrl,
    required this.name,
    this.size = 60,
    this.borderColor,
    this.onTap,
    this.isEditable = false,
  });

  String _getInitials() {
    final nameParts = name.split(' ');
    if (nameParts.isEmpty) return '';
    if (nameParts.length == 1) {
      return nameParts[0]
          .substring(0, min(2, nameParts[0].length))
          .toUpperCase();
    }
    return (nameParts[0][0] + (nameParts.length > 1 ? nameParts[1][0] : ''))
        .toUpperCase();
  }

  @override
  Widget build(BuildContext context) {
    final bool isAssetImage = imageUrl.startsWith('assets/');

    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: borderColor != null
            ? Border.all(color: borderColor!, width: size / 30)
            : null,
      ),
      child: Stack(
        children: [
          ClipOval(
            child: isAssetImage
                ? Image.asset(
                    imageUrl,
                    fit: BoxFit.cover,
                    errorBuilder: (context, error, stackTrace) =>
                        _buildFallbackWidget(),
                  )
                : Image.network(
                    imageUrl,
                    fit: BoxFit.cover,
                    loadingBuilder: (context, child, loadingProgress) {
                      if (loadingProgress == null) return child;
                      return _buildLoadingWidget();
                    },
                    errorBuilder: (context, error, stackTrace) =>
                        _buildFallbackWidget(),
                  ),
          ),
          if (isEditable)
            Positioned(
              right: 0,
              bottom: 0,
              child: Container(
                padding: const EdgeInsets.all(4),
                decoration: BoxDecoration(
                  color: Colors.blue,
                  shape: BoxShape.circle,
                  border: Border.all(color: Colors.white, width: 2),
                ),
                child: const Icon(Icons.edit, color: Colors.white, size: 16),
              ),
            ),
          if (onTap != null)
            Positioned.fill(
              child: Material(
                color: Colors.transparent,
                child: InkWell(
                  onTap: onTap,
                  customBorder: const CircleBorder(),
                ),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildLoadingWidget() {
    return Container(
      color: Colors.grey[200],
      child: Center(
        child: SizedBox(
          width: size * 0.4,
          height: size * 0.4,
          child: const CircularProgressIndicator(strokeWidth: 2),
        ),
      ),
    );
  }

  Widget _buildFallbackWidget() {
    return Container(
      color: Colors.grey[200],
      child: Center(
        child: Text(
          _getInitials(),
          style: TextStyle(
            color: Colors.grey[800],
            fontWeight: FontWeight.bold,
            fontSize: size * 0.4,
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';

class ToastUtils {
  static void showToast(BuildContext context, String message,
      {bool isError = false}) {
    final snackBar = SnackBar(
      content: Text(
        message,
        style: const TextStyle(color: Colors.white),
      ),
      backgroundColor: isError ? Colors.red : Colors.green,
      duration: const Duration(seconds: 2),
      behavior: SnackBarBehavior.floating,
      margin: const EdgeInsets.all(16),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10),
      ),
      action: SnackBarAction(
        label: 'Dismiss',
        textColor: Colors.white,
        onPressed: () {
          ScaffoldMessenger.of(context).hideCurrentSnackBar();
        },
      ),
    );

    ScaffoldMessenger.of(context).hideCurrentSnackBar();
    ScaffoldMessenger.of(context).showSnackBar(snackBar);
  }

  static void showSuccessToast(BuildContext context, String message) {
    showToast(context, message);
  }

  static void showErrorToast(BuildContext context, String message) {
    showToast(context, message, isError: true);
  }
}
import 'package:flutter/material.dart';

class AppTheme {
  // Primary Colors
  static const Color primaryColor = Color(0xFF1A237E); // Deep Blue
  static const Color secondaryColor = Color(0xFF7E57C2); // Purple
  static const Color lightBackgroundColor = Color(0xFFF5F5F5); // Light Grey
  static const Color darkBackgroundColor = Color(0xFF121212); // Dark Grey

  // Font Family
  static const String fontFamily =
      'Poppins'; // Replace with your font if needed

  // Light Theme
  static ThemeData lightTheme = ThemeData(
    brightness: Brightness.light,
    primaryColor: primaryColor,
    scaffoldBackgroundColor: lightBackgroundColor,
    fontFamily: fontFamily,
    colorScheme: const ColorScheme.light(
      primary: primaryColor,
      secondary: secondaryColor,
      surface: Colors.white,
      error: Colors.red,
    ),
    textTheme: _lightTextTheme,
    elevatedButtonTheme: _elevatedButtonTheme,
    cardTheme: _cardTheme,
    appBarTheme: _appBarTheme,
    bottomNavigationBarTheme: _bottomNavBarTheme.copyWith(
      backgroundColor: primaryColor,
    ),
  );

  // Dark Theme
  static ThemeData darkTheme = ThemeData(
    brightness: Brightness.dark,
    primaryColor: primaryColor,
    scaffoldBackgroundColor: darkBackgroundColor,
    fontFamily: fontFamily,
    colorScheme: ColorScheme.dark(
      primary: primaryColor,
      secondary: secondaryColor,
      surface: Colors.grey.shade800, // Use runtime value instead of const
      error: Colors.red,
    ),
    textTheme: _darkTextTheme,
    elevatedButtonTheme: _elevatedButtonTheme,
    cardTheme: _cardTheme.copyWith(color: Colors.grey[900]),
    appBarTheme: _appBarTheme.copyWith(
      backgroundColor: primaryColor,
    ),
    bottomNavigationBarTheme: _bottomNavBarTheme.copyWith(
      backgroundColor: Colors.grey[900],
    ),
  );

  // Text Themes
  static const TextTheme _lightTextTheme = TextTheme(
    displayLarge: TextStyle(
      fontSize: 24,
      fontWeight: FontWeight.bold,
      color: Colors.black,
    ),
    displayMedium: TextStyle(
      fontSize: 20,
      fontWeight: FontWeight.bold,
      color: Colors.black,
    ),
    bodyLarge: TextStyle(
      fontSize: 16,
      color: Colors.black54,
    ),
    bodyMedium: TextStyle(
      fontSize: 14,
      color: Colors.black54,
    ),
    labelLarge: TextStyle(
      fontSize: 16,
      fontWeight: FontWeight.bold,
      color: Colors.white,
    ),
  );

  static const TextTheme _darkTextTheme = TextTheme(
    displayLarge: TextStyle(
      fontSize: 24,
      fontWeight: FontWeight.bold,
      color: Colors.white,
    ),
    displayMedium: TextStyle(
      fontSize: 20,
      fontWeight: FontWeight.bold,
      color: Colors.white,
    ),
    bodyLarge: TextStyle(
      fontSize: 16,
      color: Colors.grey,
    ),
    bodyMedium: TextStyle(
      fontSize: 14,
      color: Colors.grey,
    ),
    labelLarge: TextStyle(
      fontSize: 16,
      fontWeight: FontWeight.bold,
      color: Colors.white,
    ),
  );

  // Elevated Button Theme
  static final ElevatedButtonThemeData _elevatedButtonTheme =
      ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: primaryColor,
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 24),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
      ),
      textStyle: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.bold,
        color: Colors.white,
      ),
    ),
  );

  // Card Theme
  static final CardTheme _cardTheme = CardTheme(
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(12),
    ),
    elevation: 4,
    margin: const EdgeInsets.all(8),
  );

  // AppBar Theme
  static final AppBarTheme _appBarTheme = AppBarTheme(
    backgroundColor: primaryColor,
    elevation: 0,
    titleTextStyle: _lightTextTheme.displayLarge,
  );

  // Bottom Navigation Bar Theme
  static const BottomNavigationBarThemeData _bottomNavBarTheme =
      BottomNavigationBarThemeData(
    selectedItemColor: Colors.white,
    unselectedItemColor: Colors.white70,
  );
}
import 'package:flutter/material.dart';
import '../../../models/match_scoring.dart';

class ScoreBoard extends StatelessWidget {
  final MatchScoring scoring;
  final Function(String team, int gameIndex) onScoreUpdate;
  final bool isMatchComplete;

  const ScoreBoard({
    super.key,
    required this.scoring,
    required this.onScoreUpdate,
    this.isMatchComplete = false,
  });

  Widget _buildScoreBox(int score, Color color, {VoidCallback? onTap}) {
    return SizedBox(
      width: 20, // Reduced from 24
      height: 20, // Reduced from 24
      child: GestureDetector(
        onTap: onTap,
        child: Container(
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color: color,
            borderRadius: BorderRadius.circular(4),
          ),
          child: Text(
            score.toString(),
            style: TextStyle(
              color:
                  color == Colors.grey.shade300 ? Colors.black : Colors.white,
              fontWeight: FontWeight.bold,
              fontSize: 10, // Reduced from 12
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildTeamScore(String team) {
    return SizedBox(
      height: 20,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildScoreBox(
            scoring.teamScores[team]!.sets,
            Colors.blue.shade700,
          ),
          const SizedBox(width: 2), // Reduced spacing
          ...List.generate(
            3,
            (index) => Padding(
              padding: const EdgeInsets.only(left: 2), // Reduced padding
              child: _buildScoreBox(
                index < scoring.teamScores[team]!.games.length
                    ? scoring.teamScores[team]!.games[index]
                    : 0,
                Colors.grey.shade300,
                onTap:
                    isMatchComplete ? null : () => onScoreUpdate(team, index),
              ),
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 95, // Fixed width container
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildTeamScore('team1'),
          const SizedBox(height: 4),
          _buildTeamScore('team2'),
        ],
      ),
    );
  }
}
