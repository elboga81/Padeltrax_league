// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:cloud_firestore_web/cloud_firestore_web.dart';
import 'package:firebase_auth_web/firebase_auth_web.dart';
import 'package:firebase_core_web/firebase_core_web.dart';
import 'package:image_picker_for_web/image_picker_for_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  FirebaseFirestoreWeb.registerWith(registrar);
  FirebaseAuthWeb.registerWith(registrar);
  FirebaseCoreWeb.registerWith(registrar);
  ImagePickerPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}
import 'package:flutter/material.dart';
import '../../models/player.dart';
import 'widgets/stats_overview_tab.dart';
import 'widgets/stats_achievements_tab.dart';
import 'widgets/stats_partnerships_tab.dart';

class PlayerStatisticsScreen extends StatelessWidget {
  final List<Player> players;

  const PlayerStatisticsScreen({
    Key? key,
    required this.players,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 3,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Player Statistics'),
          bottom: const TabBar(
            tabs: [
              Tab(text: 'Overview'),
              Tab(text: 'Achievements'),
              Tab(text: 'Partnerships'),
            ],
          ),
        ),
        body: TabBarView(
          children: [
            StatsOverviewTab(players: players),
            StatsAchievementsTab(players: players),
            StatsPartnershipsTab(players: players),
          ],
        ),
      ),
    );
  }
}
// lib/screens/statistics/widgets/stats_partnerships_tab.dart

import 'package:flutter/material.dart';
import 'package:padeltrax_app/models/player.dart';
import 'package:fl_chart/fl_chart.dart';

class StatsPartnershipsTab extends StatelessWidget {
  final List<Player> players;

  const StatsPartnershipsTab({
    Key? key,
    required this.players,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: players.length,
      itemBuilder: (context, playerIndex) {
        final player = players[playerIndex];
        final partnershipStats = player.statistics.partnershipMatches;

        return Card(
          margin: const EdgeInsets.only(bottom: 16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Player Header
              ListTile(
                leading: player.avatar(size: 48),
                title: Text(
                  player.name,
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
                subtitle: Text(
                  '${partnershipStats.length} Partners',
                  style: TextStyle(color: Colors.grey[600]),
                ),
              ),

              // Partnership List
              ListView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: partnershipStats.length,
                itemBuilder: (context, index) {
                  final partnerName = partnershipStats.keys.elementAt(index);
                  final matches = partnershipStats[partnerName] ?? 0;
                  final winRate =
                      player.statistics.partnershipWinRate[partnerName] ?? 0.0;

                  return _buildPartnershipCard(
                    partnerName: partnerName,
                    matches: matches,
                    winRate: winRate,
                  );
                },
              ),

              if (partnershipStats.isNotEmpty)
                _buildPartnershipChart(player, partnershipStats),
            ],
          ),
        );
      },
    );
  }

  Widget _buildPartnershipChart(
      Player player, Map<String, int> partnershipStats) {
    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16),
          child: Text(
            'Partnership Win Rates',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: Colors.grey[800],
            ),
          ),
        ),
        SizedBox(
          height: 200,
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: BarChart(
              BarChartData(
                alignment: BarChartAlignment.spaceAround,
                maxY: 100,
                barTouchData: BarTouchData(enabled: true),
                titlesData: FlTitlesData(
                  show: true,
                  bottomTitles: AxisTitles(
                    sideTitles: SideTitles(
                      showTitles: true,
                      getTitlesWidget: (value, meta) {
                        if (value.toInt() >= partnershipStats.length) {
                          return const Text('');
                        }
                        return RotatedBox(
                          quarterTurns: 1,
                          child: Text(
                            partnershipStats.keys
                                .elementAt(value.toInt())
                                .split(' ')[0],
                            style: const TextStyle(fontSize: 10),
                          ),
                        );
                      },
                    ),
                  ),
                ),
                barGroups: partnershipStats.entries
                    .map((entry) => BarChartGroupData(
                          x: partnershipStats.keys.toList().indexOf(entry.key),
                          barRods: [
                            BarChartRodData(
                              toY: (player.statistics
                                          .partnershipWinRate[entry.key] ??
                                      0) *
                                  100,
                              color: Colors.blue,
                              width: 20,
                              borderRadius: const BorderRadius.vertical(
                                top: Radius.circular(4),
                              ),
                            ),
                          ],
                        ))
                    .toList(),
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildPartnershipCard({
    required String partnerName,
    required int matches,
    required double winRate,
  }) {
    return ListTile(
      leading: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: Colors.blue.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
        ),
        child: const Icon(Icons.people, color: Colors.blue),
      ),
      title: Text(partnerName),
      subtitle: Text('$matches matches played'),
      trailing: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          color: _getWinRateColor(winRate).withOpacity(0.1),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(
          '${(winRate * 100).toStringAsFixed(1)}%',
          style: TextStyle(
            color: _getWinRateColor(winRate),
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  Color _getWinRateColor(double winRate) {
    if (winRate >= 0.7) return Colors.green;
    if (winRate >= 0.5) return Colors.blue;
    if (winRate >= 0.3) return Colors.orange;
    return Colors.red;
  }
}
// lib/screens/statistics/widgets/stats_overview_tab.dart

import 'package:flutter/material.dart';
import 'package:padeltrax_app/models/player.dart';
import 'stats_card.dart';
import 'recent_form_display.dart';
import 'rating_chart.dart';

class StatsOverviewTab extends StatelessWidget {
  final List<Player> players;

  const StatsOverviewTab({
    Key? key,
    required this.players,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: players.length,
      itemBuilder: (context, index) {
        final player = players[index];
        final winRate = player.statistics.wins /
            (player.statistics.totalMatches == 0
                ? 1
                : player.statistics.totalMatches) *
            100;

        return Card(
          margin: const EdgeInsets.only(bottom: 16),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Player Header
                ListTile(
                  leading: player.avatar(size: 48),
                  title: Text(player.name,
                      style: const TextStyle(fontWeight: FontWeight.bold)),
                  subtitle: Text('Rating: ${player.rating}'),
                ),

                const SizedBox(height: 16),

                // Stats Grid
                Row(
                  children: [
                    Expanded(
                      child: StatsCard(
                        title: 'Win Rate',
                        value: '${winRate.toStringAsFixed(1)}%',
                        trend: 5,
                        isPositive: true,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: StatsCard(
                        title: 'Total Matches',
                        value: player.statistics.totalMatches.toString(),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: StatsCard(
                        title: 'Current Streak',
                        value: player.statistics.currentStreak.toString(),
                        trend: player.statistics.currentStreak,
                        isPositive: player.statistics.currentStreak > 0,
                      ),
                    ),
                  ],
                ),

                const SizedBox(height: 16),

                // Recent Form
                RecentFormDisplay(
                  recentResults: player.statistics.recentResults,
                ),

                const SizedBox(height: 16),

                // Rating Chart
                SizedBox(
                  height: 200,
                  child: RatingChart(
                    ratingHistory: player.statistics.last10MatchesRating,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}
// lib/screens/statistics/widgets/recent_form_display.dart

import 'package:flutter/material.dart';
import 'package:padeltrax_app/models/match/match_result.dart';

class RecentFormDisplay extends StatelessWidget {
  final List<MatchResult> recentResults;

  const RecentFormDisplay({
    Key? key,
    required this.recentResults,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Recent Form',
          style: TextStyle(
            color: Colors.grey[600],
            fontSize: 14,
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 8),
        Row(
          children: recentResults.take(5).map((result) {
            return Padding(
              padding: const EdgeInsets.only(right: 4),
              child: Container(
                width: 32,
                height: 32,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: result.isWin
                      ? Colors.green
                      : result.isDraw
                          ? Colors.orange
                          : Colors.red,
                ),
                child: Center(
                  child: Text(
                    result.isWin
                        ? 'W'
                        : result.isDraw
                            ? 'D'
                            : 'L',
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }
}
// lib/screens/statistics/widgets/stats_card.dart

import 'package:flutter/material.dart';

class StatsCard extends StatelessWidget {
  final String title;
  final String value;
  final int? trend;
  final bool isPositive;

  const StatsCard({
    Key? key,
    required this.title,
    required this.value,
    this.trend,
    this.isPositive = true,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 2,
            offset: const Offset(0, 1),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: TextStyle(
              color: Colors.grey[600],
              fontSize: 12,
            ),
          ),
          const SizedBox(height: 4),
          Row(
            children: [
              Text(
                value,
                style: const TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              if (trend != null) ...[
                const SizedBox(width: 4),
                Icon(
                  isPositive ? Icons.trending_up : Icons.trending_down,
                  size: 16,
                  color: isPositive ? Colors.green : Colors.red,
                ),
                Text(
                  trend.toString(),
                  style: TextStyle(
                    fontSize: 12,
                    color: isPositive ? Colors.green : Colors.red,
                  ),
                ),
              ],
            ],
          ),
        ],
      ),
    );
  }
}
// lib/screens/statistics/widgets/rating_chart.dart

import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';

class RatingChart extends StatelessWidget {
  final List<double> ratingHistory;

  const RatingChart({
    Key? key,
    required this.ratingHistory,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return LineChart(
      LineChartData(
        gridData: FlGridData(show: true),
        titlesData: FlTitlesData(show: true),
        borderData: FlBorderData(show: true),
        lineBarsData: [
          LineChartBarData(
            spots: ratingHistory.asMap().entries.map((entry) {
              return FlSpot(entry.key.toDouble(), entry.value);
            }).toList(),
            isCurved: true,
            color: Colors.blue,
            barWidth: 3,
            dotData: FlDotData(show: false),
          ),
        ],
      ),
    );
  }
}
// lib/screens/statistics/widgets/stats_achievements_tab.dart

import 'package:flutter/material.dart';
import 'package:padeltrax_app/models/player.dart';
import 'package:padeltrax_app/models/match/achievement.dart';

class StatsAchievementsTab extends StatelessWidget {
  final List<Player> players;

  const StatsAchievementsTab({
    Key? key,
    required this.players,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: players.length,
      itemBuilder: (context, playerIndex) {
        final player = players[playerIndex];
        return Card(
          margin: const EdgeInsets.only(bottom: 16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Player Header
              ListTile(
                leading: player.avatar(size: 48),
                title: Text(
                  player.name,
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
              ),

              // Achievements Grid
              GridView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                padding: const EdgeInsets.all(16),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 2,
                  childAspectRatio: 1.5,
                  crossAxisSpacing: 12,
                  mainAxisSpacing: 12,
                ),
                itemCount: player.statistics.achievements.length,
                itemBuilder: (context, index) {
                  final achievement = player.statistics.achievements[index];
                  return _buildAchievementCard(achievement);
                },
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildAchievementCard(Achievement achievement) {
    return Card(
      elevation: 2,
      child: InkWell(
        onTap: () {}, // Could show achievement details
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: achievement.rarity.color.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Icon(
                      _getAchievementIcon(achievement.type),
                      color: achievement.rarity.color,
                      size: 20,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      achievement.title,
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 14,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                achievement.description,
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[600],
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              const Spacer(),
              Text(
                'Earned ${_formatDate(achievement.dateEarned)}',
                style: TextStyle(
                  fontSize: 10,
                  color: Colors.grey[500],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  IconData _getAchievementIcon(AchievementType type) {
    switch (type) {
      case AchievementType.winStreak:
        return Icons.bolt;
      case AchievementType.perfectSet:
        return Icons.star;
      case AchievementType.comeback:
        return Icons.trending_up;
      case AchievementType.tournament:
        return Icons.emoji_events;
      default:
        return Icons.emoji_events;
    }
  }

  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }
}
import 'package:flutter/material.dart';
import '../../../models/player.dart';

class PlayerStatisticsView extends StatelessWidget {
  final List<Player> players;

  const PlayerStatisticsView({
    Key? key,
    required this.players,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: players.length,
      itemBuilder: (context, index) {
        final player = players[index];
        return Card(
          margin: const EdgeInsets.only(bottom: 16),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                ListTile(
                  contentPadding: EdgeInsets.zero,
                  leading: player.avatar(size: 50),
                  title: Text(
                    player.name,
                    style: const TextStyle(
                        fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  subtitle: Text(
                    'Rating: ${player.statistics.rating.toStringAsFixed(1)}',
                  ),
                ),
                const Divider(),
                _buildStatsRow(
                  'Matches',
                  '${player.statistics.totalMatches}',
                  'Win Rate',
                  '${player.statistics.winRate.toStringAsFixed(1)}%',
                ),
                _buildStatsRow(
                  'Wins',
                  player.statistics.wins.toString(),
                  'Losses',
                  player.statistics.losses.toString(),
                ),
                _buildStatsRow(
                  'Sets Won',
                  player.statistics.setsWon.toString(),
                  'Sets Lost',
                  player.statistics.setsLost.toString(),
                ),
                _buildStatsRow(
                  'Games Won',
                  player.statistics.gamesWon.toString(),
                  'Games Lost',
                  player.statistics.gamesLost.toString(),
                ),
                const SizedBox(height: 8),
                const Text(
                  'Recent Form:',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                Row(
                  children: player.statistics.recentMatches.map((result) {
                    return Container(
                      width: 30,
                      height: 30,
                      margin: const EdgeInsets.only(right: 8),
                      decoration: BoxDecoration(
                        color: _getResultColor(result),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Center(
                        child: Text(
                          result,
                          style: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildStatsRow(
      String label1, String value1, String label2, String value2) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Expanded(
            child: _buildStatItem(label1, value1),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: _buildStatItem(label2, value2),
          ),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey[600],
          ),
        ),
        const SizedBox(height: 2),
        Text(
          value,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }

  Color _getResultColor(String result) {
    switch (result) {
      case 'W':
        return Colors.green;
      case 'D':
        return Colors.orange;
      case 'L':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }
}
import 'package:flutter/material.dart';
import '../../../models/match/achievement.dart';

class AchievementDisplay extends StatelessWidget {
  final List<Achievement> achievements;
  final bool showProgress;

  const AchievementDisplay({
    Key? key,
    required this.achievements,
    this.showProgress = true,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    if (achievements.isEmpty) {
      return _buildEmptyState();
    }

    return GridView.builder(
      padding: const EdgeInsets.all(16),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        childAspectRatio: 1.5,
        crossAxisSpacing: 12,
        mainAxisSpacing: 12,
      ),
      itemCount: achievements.length,
      itemBuilder: (context, index) => _AchievementCard(
        achievement: achievements[index],
        showProgress: showProgress,
        onTap: () => _showAchievementDetails(context, achievements[index]),
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.emoji_events_outlined,
            size: 64,
            color: Colors.grey[400],
          ),
          const SizedBox(height: 16),
          Text(
            'No achievements yet',
            style: TextStyle(
              fontSize: 18,
              color: Colors.grey[600],
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Keep playing to unlock achievements!',
            style: TextStyle(
              color: Colors.grey[500],
            ),
          ),
        ],
      ),
    );
  }

  void _showAchievementDetails(BuildContext context, Achievement achievement) {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (context) => _AchievementDetailsSheet(achievement: achievement),
    );
  }
}

class _AchievementCard extends StatelessWidget {
  final Achievement achievement;
  final bool showProgress;
  final VoidCallback onTap;

  const _AchievementCard({
    required this.achievement,
    required this.showProgress,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                achievement.rarity.color.withOpacity(0.1),
                achievement.rarity.color.withOpacity(0.05),
              ],
            ),
          ),
          child: Stack(
            children: [
              if (achievement.isRecent)
                Positioned(
                  right: -20,
                  top: -20,
                  child: Container(
                    padding: const EdgeInsets.all(30),
                    decoration: BoxDecoration(
                      color: Colors.green.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(30),
                    ),
                    child: const Text(
                      'NEW',
                      style: TextStyle(
                        color: Colors.green,
                        fontWeight: FontWeight.bold,
                        fontSize: 10,
                      ),
                    ),
                  ),
                ),
              Padding(
                padding: const EdgeInsets.all(12),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(
                          achievement.getIconData(),
                          color: achievement.rarity.color,
                          size: 24,
                        ),
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 2,
                          ),
                          decoration: BoxDecoration(
                            color: achievement.rarity.color.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(
                              color: achievement.rarity.color.withOpacity(0.5),
                            ),
                          ),
                          child: Text(
                            achievement.rarity.label,
                            style: TextStyle(
                              color: achievement.rarity.color,
                              fontSize: 10,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 8),
                    Text(
                      achievement.title,
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 14,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      achievement.description,
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey[600],
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    if (showProgress &&
                        achievement.progress != null &&
                        achievement.target != null)
                      Expanded(
                        child: Align(
                          alignment: Alignment.bottomCenter,
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              LinearProgressIndicator(
                                value: achievement.progressPercentage,
                                backgroundColor: Colors.grey[200],
                                valueColor: AlwaysStoppedAnimation<Color>(
                                  achievement.rarity.color,
                                ),
                              ),
                              const SizedBox(height: 4),
                              Text(
                                '${achievement.progress}/${achievement.target}',
                                style: TextStyle(
                                  fontSize: 10,
                                  color: Colors.grey[600],
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _AchievementDetailsSheet extends StatelessWidget {
  final Achievement achievement;

  const _AchievementDetailsSheet({
    required this.achievement,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.all(16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 40,
            height: 4,
            margin: const EdgeInsets.only(bottom: 16),
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          Row(
            children: [
              CircleAvatar(
                backgroundColor: achievement.rarity.color.withOpacity(0.1),
                child: Icon(
                  achievement.getIconData(),
                  color: achievement.rarity.color,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      achievement.title,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 2,
                      ),
                      decoration: BoxDecoration(
                        color: achievement.rarity.color.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        achievement.rarity.label,
                        style: TextStyle(
                          color: achievement.rarity.color,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          const Divider(),
          const SizedBox(height: 16),
          Text(
            achievement.description,
            style: TextStyle(
              fontSize: 16,
              color: Colors.grey[700],
            ),
          ),
          if (achievement.progress != null && achievement.target != null) ...[
            const SizedBox(height: 24),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Progress: ${achievement.progress}/${achievement.target}',
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                LinearProgressIndicator(
                  value: achievement.progressPercentage,
                  backgroundColor: Colors.grey[200],
                  valueColor: AlwaysStoppedAnimation<Color>(
                    achievement.rarity.color,
                  ),
                ),
              ],
            ),
          ],
          const SizedBox(height: 24),
          Row(
            children: [
              Icon(Icons.calendar_today, size: 16, color: Colors.grey[600]),
              const SizedBox(width: 8),
              Text(
                'Earned on ${achievement.formattedDate}',
                style: TextStyle(
                  color: Colors.grey[600],
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}
// match_header.dart
import 'package:flutter/material.dart';
import '../../../models/match.dart';

class MatchHeader extends StatelessWidget {
  final MatchStatus status;
  final String time;

  const MatchHeader({
    Key? key,
    required this.status,
    required this.time,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Row(
          children: [
            Container(
              width: 8,
              height: 8,
              decoration: BoxDecoration(
                color: _getStatusColor(status),
                shape: BoxShape.circle,
              ),
            ),
            const SizedBox(width: 8),
            Text(
              _getStatusText(status),
              style: TextStyle(
                color: _getStatusColor(status),
                fontWeight: FontWeight.w600,
                fontSize: 14,
              ),
            ),
          ],
        ),
        Text(
          time,
          style: const TextStyle(
            color: Colors.grey,
            fontSize: 14,
          ),
        ),
      ],
    );
  }

  Color _getStatusColor(MatchStatus status) {
    switch (status) {
      case MatchStatus.scheduled:
        return Colors.blue;
      case MatchStatus.inProgress:
        return Colors.orange;
      case MatchStatus.completed:
        return Colors.green;
      case MatchStatus.cancelled:
        return Colors.red;
    }
  }

  String _getStatusText(MatchStatus status) {
    switch (status) {
      case MatchStatus.scheduled:
        return 'Scheduled';
      case MatchStatus.inProgress:
        return 'In Progress';
      case MatchStatus.completed:
        return 'Completed';
      case MatchStatus.cancelled:
        return 'Cancelled';
    }
  }
}
// lib/screens/match/components/score_board.dart

import 'package:flutter/material.dart';
import '../../../models/match_scoring.dart';

class ScoreBoard extends StatelessWidget {
  final MatchScoring scoring;
  final Function(String team, int gameIndex) onScoreUpdate;
  final bool isMatchComplete;

  const ScoreBoard({
    Key? key,
    required this.scoring,
    required this.onScoreUpdate,
    this.isMatchComplete = false,
  }) : super(key: key);

  Widget _buildScoreBox(int score, Color color, {VoidCallback? onTap}) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 24,
        height: 24,
        alignment: Alignment.center,
        decoration: BoxDecoration(
          color: color,
          borderRadius: BorderRadius.circular(4),
        ),
        child: Text(
          score.toString(),
          style: TextStyle(
            color: color == Colors.grey.shade300 ? Colors.black : Colors.white,
            fontWeight: FontWeight.bold,
            fontSize: 12,
          ),
        ),
      ),
    );
  }

  Widget _buildTeamScore(String team) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        // Sets score
        _buildScoreBox(
          scoring.teamScores[team]!.sets,
          Colors.blue.shade700,
        ),
        const SizedBox(width: 8),
        // Games scores
        ...List.generate(
            3,
            (index) => Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 2),
                  child: _buildScoreBox(
                    index < scoring.teamScores[team]!.games.length
                        ? scoring.teamScores[team]!.games[index]
                        : 0,
                    Colors.grey.shade300,
                    onTap: isMatchComplete
                        ? null
                        : () => onScoreUpdate(team, index),
                  ),
                )),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _buildTeamScore('team1'),
        const SizedBox(height: 8),
        _buildTeamScore('team2'),
      ],
    );
  }
}

// Optional: Create a model class for individual score boxes
class ScoreBoxConfig {
  final int score;
  final Color color;
  final VoidCallback? onTap;

  const ScoreBoxConfig({
    required this.score,
    required this.color,
    this.onTap,
  });
}

// Optional: Enums for team identification
enum Team { team1, team2 }

// Optional: Score Box Types for better type safety
enum ScoreBoxType { set, game }
// lib/screens/match/components/match_status.dart

import 'package:flutter/material.dart';

class MatchStatus extends StatelessWidget {
  final bool isComplete;
  final String? winner;
  final String? matchTime;

  const MatchStatus({
    Key? key,
    required this.isComplete,
    this.winner,
    this.matchTime,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        if (matchTime != null) _buildTimeRow(),
        if (isComplete) _buildWinnerStatus(),
      ],
    );
  }

  Widget _buildTimeRow() {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          const Icon(
            Icons.access_time,
            size: 16,
            color: Colors.grey,
          ),
          const SizedBox(width: 4),
          Text(
            matchTime!,
            style: const TextStyle(
              color: Colors.grey,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildWinnerStatus() {
    return Container(
      margin: const EdgeInsets.only(top: 16),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.green.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.green),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(
            Icons.emoji_events,
            color: Colors.green,
            size: 20,
          ),
          const SizedBox(width: 8),
          Text(
            '${winner ?? "Team"} Wins!',
            style: const TextStyle(
              color: Colors.green,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }

  // Static method to determine winner display name
  static String getWinnerDisplay(String winner) {
    return winner == 'team1' ? 'Team 1' : 'Team 2';
  }
}

// Optional: enum for match states
enum MatchState {
  scheduled,
  inProgress,
  completed,
  cancelled;

  Color get color {
    switch (this) {
      case MatchState.scheduled:
        return Colors.blue;
      case MatchState.inProgress:
        return Colors.orange;
      case MatchState.completed:
        return Colors.green;
      case MatchState.cancelled:
        return Colors.red;
    }
  }

  String get label {
    switch (this) {
      case MatchState.scheduled:
        return 'Scheduled';
      case MatchState.inProgress:
        return 'In Progress';
      case MatchState.completed:
        return 'Completed';
      case MatchState.cancelled:
        return 'Cancelled';
    }
  }
}
// lib/screens/match/components/save_indicator.dart

import 'package:flutter/material.dart';

class SaveIndicator extends StatelessWidget {
  final bool isVisible;
  final String? message;
  final Color? color;

  const SaveIndicator({
    Key? key,
    required this.isVisible,
    this.message = 'Saving...',
    this.color = Colors.orange,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AnimatedOpacity(
      opacity: isVisible ? 1.0 : 0.0,
      duration: const Duration(milliseconds: 200),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: color!.withOpacity(0.1),
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: color!),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: 12,
              height: 12,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(color!),
              ),
            ),
            const SizedBox(width: 8),
            Text(
              message!,
              style: TextStyle(
                color: color,
                fontSize: 12,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Optional: SaveState enum for different saving states
enum SaveState {
  idle,
  saving,
  success,
  error;

  Color get color {
    switch (this) {
      case SaveState.saving:
        return Colors.orange;
      case SaveState.success:
        return Colors.green;
      case SaveState.error:
        return Colors.red;
      case SaveState.idle:
        return Colors.grey;
    }
  }

  String get message {
    switch (this) {
      case SaveState.saving:
        return 'Saving...';
      case SaveState.success:
        return 'Saved!';
      case SaveState.error:
        return 'Error saving';
      case SaveState.idle:
        return '';
    }
  }
}

// Optional: Extended version with more features
class SaveIndicatorExtended extends StatelessWidget {
  final SaveState state;
  final String? customMessage;
  final VoidCallback? onRetry;

  const SaveIndicatorExtended({
    Key? key,
    required this.state,
    this.customMessage,
    this.onRetry,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AnimatedOpacity(
      opacity: state == SaveState.idle ? 0.0 : 1.0,
      duration: const Duration(milliseconds: 200),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: state.color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: state.color),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (state == SaveState.saving)
              SizedBox(
                width: 12,
                height: 12,
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                  valueColor: AlwaysStoppedAnimation<Color>(state.color),
                ),
              )
            else
              Icon(
                _getStateIcon(),
                size: 12,
                color: state.color,
              ),
            const SizedBox(width: 8),
            Text(
              customMessage ?? state.message,
              style: TextStyle(
                color: state.color,
                fontSize: 12,
              ),
            ),
            if (state == SaveState.error && onRetry != null) ...[
              const SizedBox(width: 8),
              GestureDetector(
                onTap: onRetry,
                child: Icon(
                  Icons.refresh,
                  size: 14,
                  color: state.color,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  IconData _getStateIcon() {
    switch (state) {
      case SaveState.success:
        return Icons.check_circle_outline;
      case SaveState.error:
        return Icons.error_outline;
      default:
        return Icons.info_outline;
    }
  }
}
import 'package:flutter/material.dart';

class ErrorView extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;

  const ErrorView({
    Key? key,
    required this.message,
    this.onRetry,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              color: Colors.red[300],
              size: 60,
            ),
            const SizedBox(height: 16),
            Text(
              message,
              textAlign: TextAlign.center,
              style: const TextStyle(
                fontSize: 16,
                color: Colors.grey,
              ),
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: const Text('Try Again'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 24,
                    vertical: 12,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
// lib/screens/match/components/undo_redo_buttons.dart

import 'package:flutter/services.dart';
import 'package:flutter/material.dart';

class UndoRedoButtons extends StatelessWidget {
  final bool canUndo;
  final bool canRedo;
  final VoidCallback? onUndo;
  final VoidCallback? onRedo;
  final bool showTooltips;
  final Color? activeColor;
  final Color? inactiveColor;

  const UndoRedoButtons({
    Key? key,
    required this.canUndo,
    required this.canRedo,
    this.onUndo,
    this.onRedo,
    this.showTooltips = true,
    this.activeColor = Colors.blue,
    this.inactiveColor = Colors.grey,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        _buildActionButton(
          icon: Icons.undo,
          enabled: canUndo,
          onPressed: onUndo,
          tooltip: 'Undo last action',
        ),
        _buildActionButton(
          icon: Icons.redo,
          enabled: canRedo,
          onPressed: onRedo,
          tooltip: 'Redo last action',
        ),
      ],
    );
  }

  Widget _buildActionButton({
    required IconData icon,
    required bool enabled,
    VoidCallback? onPressed,
    required String tooltip,
  }) {
    final button = IconButton(
      icon: Icon(
        icon,
        color: enabled ? activeColor : inactiveColor,
        size: 20,
      ),
      onPressed: enabled ? onPressed : null,
      padding: const EdgeInsets.all(8),
      constraints: const BoxConstraints(
        minWidth: 32,
        minHeight: 32,
      ),
      splashRadius: 20,
    );

    return showTooltips
        ? Tooltip(
            message: tooltip,
            child: button,
          )
        : button;
  }
}

// Optional: Extended version with animations and badges
class UndoRedoButtonsExtended extends StatelessWidget {
  final bool canUndo;
  final bool canRedo;
  final VoidCallback? onUndo;
  final VoidCallback? onRedo;
  final int undoCount;
  final int redoCount;
  final bool showCounts;
  final Color? activeColor;
  final Color? inactiveColor;

  const UndoRedoButtonsExtended({
    Key? key,
    required this.canUndo,
    required this.canRedo,
    this.onUndo,
    this.onRedo,
    this.undoCount = 0,
    this.redoCount = 0,
    this.showCounts = false,
    this.activeColor = Colors.blue,
    this.inactiveColor = Colors.grey,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        _buildAnimatedButton(
          icon: Icons.undo,
          enabled: canUndo,
          onPressed: onUndo,
          tooltip: 'Undo last action',
          count: undoCount,
        ),
        _buildAnimatedButton(
          icon: Icons.redo,
          enabled: canRedo,
          onPressed: onRedo,
          tooltip: 'Redo last action',
          count: redoCount,
        ),
      ],
    );
  }

  Widget _buildAnimatedButton({
    required IconData icon,
    required bool enabled,
    VoidCallback? onPressed,
    required String tooltip,
    required int count,
  }) {
    return Stack(
      clipBehavior: Clip.none,
      children: [
        Tooltip(
          message: tooltip,
          child: Material(
            color: Colors.transparent,
            child: InkWell(
              onTap: enabled ? onPressed : null,
              borderRadius: BorderRadius.circular(20),
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 200),
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: enabled
                      ? activeColor?.withOpacity(0.1)
                      : Colors.transparent,
                  borderRadius: BorderRadius.circular(20),
                ),
                child: Icon(
                  icon,
                  color: enabled ? activeColor : inactiveColor,
                  size: 20,
                ),
              ),
            ),
          ),
        ),
        if (showCounts && count > 0)
          Positioned(
            right: -4,
            top: -4,
            child: Container(
              padding: const EdgeInsets.all(4),
              decoration: BoxDecoration(
                color: activeColor,
                shape: BoxShape.circle,
              ),
              constraints: const BoxConstraints(
                minWidth: 16,
                minHeight: 16,
              ),
              child: Text(
                count.toString(),
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ),
      ],
    );
  }
}

// Optional: Keyboard shortcuts handler
class UndoRedoShortcuts extends StatelessWidget {
  final Widget child;
  final VoidCallback? onUndo;
  final VoidCallback? onRedo;
  final bool enabled;

  const UndoRedoShortcuts({
    Key? key,
    required this.child,
    this.onUndo,
    this.onRedo,
    this.enabled = true,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Shortcuts(
      shortcuts: enabled
          ? <ShortcutActivator, Intent>{
              LogicalKeySet(
                LogicalKeyboardKey.control,
                LogicalKeyboardKey.keyZ,
              ): const UndoIntent(),
              LogicalKeySet(
                LogicalKeyboardKey.control,
                LogicalKeyboardKey.keyY,
              ): const RedoIntent(),
              LogicalKeySet(
                LogicalKeyboardKey.control,
                LogicalKeyboardKey.shift,
                LogicalKeyboardKey.keyZ,
              ): const RedoIntent(),
            }
          : {},
      child: Actions(
        actions: <Type, Action<Intent>>{
          UndoIntent: CallbackAction<UndoIntent>(
            onInvoke: (UndoIntent intent) => onUndo?.call(),
          ),
          RedoIntent: CallbackAction<RedoIntent>(
            onInvoke: (RedoIntent intent) => onRedo?.call(),
          ),
        },
        child: child,
      ),
    );
  }
}

// Intents for keyboard shortcuts
class UndoIntent extends Intent {
  const UndoIntent();
}

class RedoIntent extends Intent {
  const RedoIntent();
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'dart:async';

import '../../../models/match.dart' as match_model;
import '../../../models/match_scoring.dart';
import '../../../models/player.dart';
import '../../../providers/app_state.dart';

import './score_board.dart';
import './save_indicator.dart';
import './undo_redo_buttons.dart';

class MatchCard extends StatefulWidget {
  final match_model.Match match;
  final bool isHistory;
  final String? timeslot;

  const MatchCard({
    Key? key,
    required this.match,
    this.isHistory = false,
    this.timeslot,
  }) : super(key: key);

  @override
  State<MatchCard> createState() => _MatchCardState();
}

class _MatchCardState extends State<MatchCard> {
  late MatchScoring _scoring;
  bool _hasUnsavedChanges = false;
  Timer? _saveTimer;
  final List<Map<String, SetScore>> _undoStack = [];
  final List<Map<String, SetScore>> _redoStack = [];

  @override
  void initState() {
    super.initState();
    _scoring = MatchScoring();
    _initializeScores();
  }

  @override
  void dispose() {
    _saveTimer?.cancel();
    super.dispose();
  }

  void _initializeScores() {
    if (widget.match.score['team1']?.games != null) {
      _scoring.teamScores['team1']!.games =
          List<int>.from(widget.match.score['team1']!.games);
      _scoring.teamScores['team1']!.sets = widget.match.score['team1']!.sets;
    }
    if (widget.match.score['team2']?.games != null) {
      _scoring.teamScores['team2']!.games =
          List<int>.from(widget.match.score['team2']!.games);
      _scoring.teamScores['team2']!.sets = widget.match.score['team2']!.sets;
    }
  }

  void _saveState() {
    _undoStack.add({
      'team1': SetScore()
        ..sets = _scoring.teamScores['team1']!.sets
        ..games = List<int>.from(_scoring.teamScores['team1']!.games),
      'team2': SetScore()
        ..sets = _scoring.teamScores['team2']!.sets
        ..games = List<int>.from(_scoring.teamScores['team2']!.games),
    });
    _redoStack.clear();
  }

  void _debounceSave() {
    _saveTimer?.cancel();
    _saveTimer = Timer(const Duration(seconds: 2), () {
      if (mounted) {
        _saveMatchScore();
      }
    });
  }

  Future<void> _saveMatchScore() async {
    if (!_hasUnsavedChanges) return;

    try {
      final appState = context.read<AppState>();

      // Update scores for both teams
      await appState.updateMatchScore(
        widget.match.id,
        'team1',
        'sets',
        _scoring.teamScores['team1']!.sets,
      );
      await appState.updateMatchScore(
        widget.match.id,
        'team2',
        'sets',
        _scoring.teamScores['team2']!.sets,
      );

      // Update match status if complete
      if (_scoring.isMatchComplete) {
        await appState.updateMatchStatus(
          widget.match.id,
          match_model.MatchStatus.completed,
        );
      }

      if (mounted) {
        setState(() => _hasUnsavedChanges = false);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error saving match score: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  void _updateScore(String team, int gameIndex) {
    if (_scoring.isMatchComplete) return;

    _saveState();
    setState(() {
      final currentTeam = _scoring.teamScores[team]!;
      final opposingTeam =
          _scoring.teamScores[team == 'team1' ? 'team2' : 'team1']!;

      while (currentTeam.games.length <= gameIndex) {
        currentTeam.games.add(0);
        opposingTeam.games.add(0);
      }

      currentTeam.games[gameIndex]++;

      if (_isSetWon(
          currentTeam.games[gameIndex], opposingTeam.games[gameIndex])) {
        currentTeam.sets++;

        if (currentTeam.sets == 2) {
          _scoring.isMatchComplete = true;
          _scoring.winner = team;
        } else if (currentTeam.games.length < 3) {
          currentTeam.games.add(0);
          opposingTeam.games.add(0);
        }
      } else if (!_isValidGameScore(
          currentTeam.games[gameIndex], opposingTeam.games[gameIndex])) {
        currentTeam.games[gameIndex]--;
      }

      _hasUnsavedChanges = true;
    });
    _debounceSave();
  }

  bool _isSetWon(int currentTeamGames, int opposingTeamGames) {
    return (currentTeamGames == 6 && opposingTeamGames <= 4) ||
        (currentTeamGames == 7 &&
            (opposingTeamGames == 5 || opposingTeamGames == 6));
  }

  bool _isValidGameScore(int currentTeamGames, int opposingTeamGames) {
    if (currentTeamGames > 7) return false;
    if (currentTeamGames == 7 && opposingTeamGames < 5) return false;
    if (currentTeamGames == 6 && opposingTeamGames > 6) return false;
    return true;
  }

  void _undo() {
    if (_undoStack.isEmpty) return;

    setState(() {
      // Save current state to redo stack
      _redoStack.add({
        'team1': SetScore()
          ..sets = _scoring.teamScores['team1']!.sets
          ..games = List<int>.from(_scoring.teamScores['team1']!.games),
        'team2': SetScore()
          ..sets = _scoring.teamScores['team2']!.sets
          ..games = List<int>.from(_scoring.teamScores['team2']!.games),
      });

      // Restore previous state
      final previousState = _undoStack.removeLast();
      _scoring.teamScores['team1']!.sets = previousState['team1']!.sets;
      _scoring.teamScores['team1']!.games =
          List<int>.from(previousState['team1']!.games);
      _scoring.teamScores['team2']!.sets = previousState['team2']!.sets;
      _scoring.teamScores['team2']!.games =
          List<int>.from(previousState['team2']!.games);

      _hasUnsavedChanges = true;
    });
    _debounceSave();
  }

  void _redo() {
    if (_redoStack.isEmpty) return;

    setState(() {
      // Save current state to undo stack
      _undoStack.add({
        'team1': SetScore()
          ..sets = _scoring.teamScores['team1']!.sets
          ..games = List<int>.from(_scoring.teamScores['team1']!.games),
        'team2': SetScore()
          ..sets = _scoring.teamScores['team2']!.sets
          ..games = List<int>.from(_scoring.teamScores['team2']!.games),
      });

      // Restore next state
      final nextState = _redoStack.removeLast();
      _scoring.teamScores['team1']!.sets = nextState['team1']!.sets;
      _scoring.teamScores['team1']!.games =
          List<int>.from(nextState['team1']!.games);
      _scoring.teamScores['team2']!.sets = nextState['team2']!.sets;
      _scoring.teamScores['team2']!.games =
          List<int>.from(nextState['team2']!.games);

      _hasUnsavedChanges = true;
    });
    _debounceSave();
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Scheduled',
                  style: TextStyle(
                      color: Colors.blue, fontWeight: FontWeight.w600),
                ),
                Text(
                  widget.match.time,
                  style: const TextStyle(color: Colors.grey, fontSize: 14),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Expanded(child: _buildTeamColumn('team1')),
                const SizedBox(width: 16),
                ScoreBoard(
                  scoring: _scoring,
                  onScoreUpdate: _updateScore,
                  isMatchComplete: _scoring.isMatchComplete,
                ),
                const SizedBox(width: 16),
                Expanded(child: _buildTeamColumn('team2')),
              ],
            ),
            if (_hasUnsavedChanges) ...[
              const SizedBox(height: 8),
              const SaveIndicator(isVisible: true),
            ],
            const SizedBox(height: 8),
            UndoRedoButtons(
              canUndo: _undoStack.isNotEmpty,
              canRedo: _redoStack.isNotEmpty,
              onUndo: _undoStack.isEmpty ? null : _undo,
              onRedo: _redoStack.isEmpty ? null : _redo,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTeamColumn(String team) {
    final player1 = widget.match.players['${team}_player1'];
    final player2 = widget.match.players['${team}_player2'];

    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        _buildPlayerRow(player1),
        const SizedBox(height: 8),
        _buildPlayerRow(player2),
      ],
    );
  }

  Widget _buildPlayerRow(Player? player) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        CircleAvatar(
          radius: 20,
          backgroundColor: Colors.grey[200],
          backgroundImage: player?.profileImage != null
              ? AssetImage(player!.profileImage)
              : null,
          child: player?.profileImage == null
              ? const Icon(Icons.person, color: Colors.grey)
              : null,
        ),
        const SizedBox(width: 8),
        Text(
          player?.name ?? 'Available Slot',
          style: const TextStyle(fontSize: 14),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import '../../../models/player.dart';

class PlayerInfo extends StatelessWidget {
  final Player player;
  final bool showRating;
  final Alignment alignment;
  final double avatarSize;
  final TextStyle? nameStyle;

  const PlayerInfo({
    Key? key,
    required this.player,
    this.showRating = false,
    this.alignment = Alignment.centerLeft,
    this.avatarSize = 32,
    this.nameStyle,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      constraints: const BoxConstraints(maxWidth: 200),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        textDirection: alignment == Alignment.centerRight
            ? TextDirection.rtl
            : TextDirection.ltr,
        children: [
          _buildAvatar(),
          const SizedBox(width: 8),
          Flexible(child: _buildPlayerDetails()),
        ],
      ),
    );
  }

  Widget _buildAvatar() {
    return CircleAvatar(
      radius: avatarSize / 2,
      backgroundImage: player.profileImage.isNotEmpty
          ? NetworkImage(player.profileImage) // User-uploaded image
          : const AssetImage('assets/images/profile.png')
              as ImageProvider, // Default image
      backgroundColor: Colors.grey[200],
      onBackgroundImageError: (exception, stackTrace) {
        debugPrint('Error loading player image: $exception');
      },
      child: player.profileImage.isEmpty
          ? _buildAvatarFallback() // Optional: Show initials if no image
          : null,
    );
  }

  Widget? _buildAvatarFallback() {
    return player.name.isNotEmpty
        ? Text(
            player.name[0].toUpperCase(),
            style: TextStyle(
              fontSize: avatarSize * 0.5,
              fontWeight: FontWeight.bold,
              color: Colors.grey[800],
            ),
          )
        : const Icon(Icons.person, size: 16, color: Colors.grey);
  }

  Widget _buildPlayerDetails() {
    return Column(
      crossAxisAlignment: alignment == Alignment.centerRight
          ? CrossAxisAlignment.end
          : CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          player.name,
          style: nameStyle ??
              const TextStyle(
                color: Colors.black87,
                fontSize: 14,
                fontWeight: FontWeight.w500,
              ),
          overflow: TextOverflow.ellipsis,
        ),
        if (showRating) _buildRatingBadge(),
      ],
    );
  }

  Widget _buildRatingBadge() {
    return Container(
      margin: const EdgeInsets.only(top: 2),
      padding: const EdgeInsets.symmetric(
        horizontal: 6,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: _getRatingColor().withOpacity(0.1),
        borderRadius: BorderRadius.circular(4),
        border: Border.all(
          color: _getRatingColor(),
          width: 1,
        ),
      ),
      child: Text(
        'Rating: ${player.rating.toStringAsFixed(1)}',
        style: TextStyle(
          fontSize: 11,
          fontWeight: FontWeight.w500,
          color: _getRatingColor(),
        ),
      ),
    );
  }

  Color _getRatingColor() {
    if (player.rating >= 4.5) return Colors.green;
    if (player.rating >= 4.0) return Colors.blue;
    if (player.rating >= 3.0) return Colors.orange;
    return Colors.red;
  }
}

// Optional: TeamPlayerInfo widget for showing multiple players
class TeamPlayerInfo extends StatelessWidget {
  final List<Player> players;
  final String teamName;
  final Alignment alignment;
  final bool showRating;

  const TeamPlayerInfo({
    Key? key,
    required this.players,
    required this.teamName,
    this.alignment = Alignment.centerLeft,
    this.showRating = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: alignment == Alignment.centerRight
          ? CrossAxisAlignment.end
          : CrossAxisAlignment.start,
      children: [
        Text(
          teamName,
          style: const TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.bold,
            color: Colors.grey,
          ),
        ),
        const SizedBox(height: 4),
        ...players.map((player) => Padding(
              padding: const EdgeInsets.symmetric(vertical: 2),
              child: PlayerInfo(
                player: player,
                alignment: alignment,
                showRating: showRating,
                avatarSize: 28,
              ),
            )),
      ],
    );
  }
}

// Optional: Compact version for tight spaces
class CompactPlayerInfo extends StatelessWidget {
  final Player player;
  final bool showRating;

  const CompactPlayerInfo({
    Key? key,
    required this.player,
    this.showRating = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        CircleAvatar(
          radius: 12,
          backgroundImage: player.profileImage.isNotEmpty
              ? NetworkImage(player.profileImage)
              : const AssetImage('assets/images/profile.png') as ImageProvider,
          backgroundColor: Colors.grey[200],
        ),
        const SizedBox(width: 4),
        Flexible(
          child: Text(
            player.name,
            style: const TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.w500,
            ),
            overflow: TextOverflow.ellipsis,
          ),
        ),
        if (showRating) ...[
          const SizedBox(width: 4),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
            decoration: BoxDecoration(
              color: Colors.grey[200],
              borderRadius: BorderRadius.circular(4),
            ),
            child: Text(
              player.rating.toStringAsFixed(1),
              style: const TextStyle(
                fontSize: 10,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ],
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/app_state.dart';
import '../../services/match_maker.dart';
import 'tabs/current_matches_tab.dart';
import 'tabs/match_history_tab.dart';

class MatchView extends StatelessWidget {
  const MatchView({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 2,
      child: Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
          backgroundColor: Colors.blue,
          title: const Text('Match Day'),
          actions: [
            IconButton(
              icon: const Icon(Icons.autorenew),
              onPressed: () => _createAutomaticMatches(context),
            ),
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () {
                context.read<AppState>().refreshMatches();
              },
            ),
          ],
          bottom: const TabBar(
            tabs: [
              Tab(text: 'Today\'s Matches'),
              Tab(text: 'Match History'),
            ],
          ),
        ),
        body: const TabBarView(
          children: [
            CurrentMatchesTab(),
            MatchHistoryTab(),
          ],
        ),
      ),
    );
  }

  Future<void> _createAutomaticMatches(BuildContext context) async {
    final appState = context.read<AppState>();
    final weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
    final today = weekdays[DateTime.now().weekday - 1];

    try {
      debugPrint('Creating automatic matches for $today');

      // Create matches for the early timeslot
      final earlyMatches = await MatchMaker.createMatchesFromBookings(
        appState.bookings[today] ?? [],
        appState.players,
        'Early Timeslot',
        today,
      );

      // Create matches for the later timeslot
      final laterMatches = await MatchMaker.createMatchesFromBookings(
        appState.bookings[today] ?? [],
        appState.players,
        'Later Timeslot',
        today,
      );

      // Refresh matches in AppState to reflect the new matches
      await appState.refreshMatches();

      if (!context.mounted) return;

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
              'Created ${earlyMatches.length + laterMatches.length} matches successfully'),
          backgroundColor: Colors.green,
        ),
      );
    } catch (e) {
      debugPrint('Error creating automatic matches: $e');

      if (!context.mounted) return;

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error creating matches: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../models/match.dart';
import '../../../models/player.dart';
import '../../../providers/app_state.dart';
import '../components/match_card.dart'; // Import from components folder

class CurrentMatchesTab extends StatelessWidget {
  const CurrentMatchesTab({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 5,
      child: Scaffold(
        appBar: AppBar(
          backgroundColor: Colors.white,
          title:
              const Text('Match Days', style: TextStyle(color: Colors.black)),
          bottom: const TabBar(
            labelColor: Colors.blue,
            unselectedLabelColor: Colors.grey,
            tabs: [
              Tab(text: 'Monday'),
              Tab(text: 'Tuesday'),
              Tab(text: 'Wednesday'),
              Tab(text: 'Thursday'),
              Tab(text: 'Friday'),
            ],
          ),
        ),
        body: const TabBarView(
          children: [
            DayMatchesView(day: 'Monday'),
            DayMatchesView(day: 'Tuesday'),
            DayMatchesView(day: 'Wednesday'),
            DayMatchesView(day: 'Thursday'),
            DayMatchesView(day: 'Friday'),
          ],
        ),
      ),
    );
  }
}

class DayMatchesView extends StatelessWidget {
  final String day;

  const DayMatchesView({Key? key, required this.day}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer<AppState>(
      builder: (context, appState, child) {
        final bookings = appState.bookings[day] ?? [];

        return SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildTimeslotSection(
                'Early Timeslot',
                bookings
                    .where((b) =>
                        b['timeslot'] == 'Early Timeslot' ||
                        b['timeslot'] == 'Play Either')
                    .toList(),
                appState,
              ),
              const SizedBox(height: 24),
              _buildTimeslotSection(
                'Later Timeslot',
                bookings
                    .where((b) =>
                        b['timeslot'] == 'Later Timeslot' ||
                        b['timeslot'] == 'Play Either')
                    .toList(),
                appState,
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildTimeslotSection(
    String timeslot,
    List<Map<String, dynamic>> bookings,
    AppState appState,
  ) {
    final matches =
        _createMatchesFromBookings(bookings, appState.players, timeslot);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          timeslot,
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: Colors.blue,
          ),
        ),
        const SizedBox(height: 16),
        ...matches.map((match) => Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: MatchCard(
                match: match,
                timeslot: timeslot,
              ),
            )),
        if (matches.isEmpty)
          const Card(
            child: Padding(
              padding: EdgeInsets.all(16),
              child: Text(
                'Waiting for players to join...',
                style: TextStyle(color: Colors.grey),
              ),
            ),
          ),
      ],
    );
  }

  List<Match> _createMatchesFromBookings(
    List<Map<String, dynamic>> bookings,
    List<Player> allPlayers,
    String timeslot,
  ) {
    if (bookings.isEmpty) return [];

    final bookedPlayers = allPlayers
        .where((player) =>
            bookings.any((booking) => booking['playerId'] == player.id))
        .toList();

    bookedPlayers.sort((a, b) => a.rank.compareTo(b.rank));

    List<Match> matches = [];
    for (var i = 0; i < bookedPlayers.length; i += 4) {
      final matchPlayers = <Player>[];
      for (var j = 0; j < 4; j++) {
        if (i + j < bookedPlayers.length) {
          matchPlayers.add(bookedPlayers[i + j]);
        } else {
          matchPlayers.add(Player(
            id: 'placeholder${matchPlayers.length + 1}',
            name: 'Available Slot',
            rating: 0,
            rank: 999,
            profileImage: 'assets/images/profile.png',
            createdAt: DateTime.now(),
          ));
        }
      }

      // Use the new match ID format
      final matchId =
          'match_${DateTime.now().toIso8601String().split("T")[0]}_${timeslot.replaceAll(" ", "_")}_${(i ~/ 4) + 1}';

      matches.add(Match(
        id: matchId,
        date: DateTime.now(),
        time: timeslot,
        status: MatchStatus.scheduled,
        players: {
          'team1_player1': matchPlayers[0],
          'team1_player2': matchPlayers[3],
          'team2_player1': matchPlayers[1],
          'team2_player2': matchPlayers[2],
        },
        score: {
          'team1': Score(sets: 0, games: []),
          'team2': Score(sets: 0, games: []),
        },
        createdAt: DateTime.now(),
      ));
    }

    return matches;
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../providers/app_state.dart';
import '../../../models/match.dart';
import '../components/match_card.dart';

class MatchHistoryTab extends StatelessWidget {
  const MatchHistoryTab({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer<AppState>(
      builder: (context, appState, child) {
        final completedMatches = appState.matches
            .where((match) => match.status == MatchStatus.completed)
            .toList();

        if (completedMatches.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.history, size: 64, color: Colors.grey[400]),
                const SizedBox(height: 16),
                Text(
                  'No completed matches yet',
                  style: TextStyle(
                    color: Colors.grey[600],
                    fontSize: 16,
                  ),
                ),
              ],
            ),
          );
        }

        return ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: completedMatches.length,
          itemBuilder: (context, index) {
            return MatchCard(
              match: completedMatches[index],
              isHistory: true,
            );
          },
        );
      },
    );
  }
}
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../main_dashboard/main_dashboard.dart';
import 'registration_screen.dart'; // Add this import

class LoginScreen extends StatefulWidget {
  const LoginScreen({Key? key}) : super(key: key);

  @override
  State<LoginScreen> createState() => LoginScreenState();
}

class LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _auth = FirebaseAuth.instance;
  bool _isLoading = false;
  String? _error;

  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      debugPrint('Attempting login with email: ${_emailController.text}');

      final userCredential = await _auth.signInWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );

      if (!mounted) return;

      if (userCredential.user != null) {
        debugPrint('Login successful for user: ${userCredential.user!.uid}');
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => const MainDashboard()),
        );
      }
    } on FirebaseAuthException catch (e) {
      debugPrint('Firebase Auth Error: ${e.code} - ${e.message}');
      setState(() {
        _error = _getErrorMessage(e.code);
      });
    } catch (e) {
      debugPrint('General Error: $e');
      setState(() {
        _error = 'An unexpected error occurred';
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  String _getErrorMessage(String code) {
    switch (code) {
      case 'user-not-found':
        return 'No user found with this email';
      case 'wrong-password':
        return 'Invalid password';
      case 'invalid-email':
        return 'Please enter a valid email address';
      case 'user-disabled':
        return 'This account has been disabled';
      default:
        return 'Login failed: $code';
    }
  }

  void _navigateToRegistration() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const RegistrationScreen()),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text(
                  'Welcome Back',
                  style: TextStyle(
                    fontSize: 28,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 40),
                TextFormField(
                  controller: _emailController,
                  decoration: InputDecoration(
                    labelText: 'Email',
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    prefixIcon: const Icon(Icons.email),
                  ),
                  keyboardType: TextInputType.emailAddress,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your email';
                    }
                    if (!value.contains('@')) {
                      return 'Please enter a valid email address';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: _passwordController,
                  decoration: InputDecoration(
                    labelText: 'Password',
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    prefixIcon: const Icon(Icons.lock),
                  ),
                  obscureText: true,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your password';
                    }
                    return null;
                  },
                ),
                if (_error != null) ...[
                  const SizedBox(height: 16),
                  Text(
                    _error!,
                    style: const TextStyle(color: Colors.red),
                    textAlign: TextAlign.center,
                  ),
                ],
                const SizedBox(height: 24),
                SizedBox(
                  width: double.infinity,
                  height: 50,
                  child: ElevatedButton(
                    onPressed: _isLoading ? null : _handleLogin,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.blue,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: _isLoading
                        ? const SizedBox(
                            width: 20,
                            height: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor:
                                  AlwaysStoppedAnimation<Color>(Colors.white),
                            ),
                          )
                        : const Text(
                            'Login',
                            style: TextStyle(fontSize: 16),
                          ),
                  ),
                ),
                const SizedBox(height: 16),
                TextButton(
                  onPressed: _navigateToRegistration, // Use the new method
                  child: const Text('Need an account? Register'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }
}
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:typed_data';
import '../../models/user_model.dart';
import '../main_dashboard/main_dashboard.dart';

class RegistrationScreen extends StatefulWidget {
  const RegistrationScreen({Key? key}) : super(key: key);

  @override
  State<RegistrationScreen> createState() => _RegistrationScreenState();
}

class _RegistrationScreenState extends State<RegistrationScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _nameController = TextEditingController();
  final _levelController = TextEditingController();
  final _nationalityController = TextEditingController();
  final ImagePicker _imagePicker = ImagePicker();
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  final String _preferredSide = 'Left';
  bool _isLoading = false;
  Uint8List? _selectedImageBytes;
  String? _error;

  Future<void> _pickImage() async {
    if (!mounted) return;
    try {
      final XFile? result =
          await _imagePicker.pickImage(source: ImageSource.gallery);
      if (result != null && mounted) {
        final bytes = await result.readAsBytes();
        setState(() {
          _selectedImageBytes = bytes;
        });
      }
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error picking image: $e')),
      );
    }
  }

  Future<void> _createUserAndPlayerRecords(String userId) async {
    try {
      // 1. Create User document
      final userModel = UserModel(
        id: userId,
        email: _emailController.text.trim(),
        name: _nameController.text.trim(),
        level: double.parse(_levelController.text.trim()),
        nationality: _nationalityController.text.trim(),
        preferredSide: _preferredSide,
        profileImageUrl: null,
        createdAt: DateTime.now(),
      );

      await _firestore.collection('users').doc(userId).set(userModel.toMap());
      debugPrint('User document created successfully');

      // 2. Create Player document
      final playerData = {
        'id': userId,
        'name': _nameController.text.trim(),
        'rating': double.parse(_levelController.text.trim()),
        'rank': 0, // Default rank
        'profileImage': 'assets/images/profile.png',
        'createdAt': FieldValue.serverTimestamp(),
        'signedTimeslots': {},
        'wins': 0,
        'losses': 0,
        'draws': 0
      };

      await _firestore.collection('players').doc(userId).set(playerData);
      debugPrint('Player document created successfully');
    } catch (e) {
      debugPrint('Error creating documents: $e');
      rethrow; // Preserves original stack trace
    }
  }

  Future<void> _handleRegistration() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      // 1. Create Authentication User
      debugPrint('Creating authentication user...');
      final userCredential =
          await FirebaseAuth.instance.createUserWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text.trim(),
      );

      if (userCredential.user == null) {
        throw Exception('Failed to create user account');
      }

      // 2. Create User and Player records
      debugPrint('Creating user and player records...');
      await _createUserAndPlayerRecords(userCredential.user!.uid);

      if (!mounted) return;

      // 3. Show success message
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Registration successful!'),
          backgroundColor: Colors.green,
        ),
      );

      // 4. Navigate to Dashboard
      Navigator.pushAndRemoveUntil(
        context,
        MaterialPageRoute(builder: (context) => const MainDashboard()),
        (route) => false,
      );
    } catch (e) {
      debugPrint('Registration error: $e');
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Registration failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Create Account'),
        backgroundColor: Colors.blue,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              GestureDetector(
                onTap: _pickImage,
                child: CircleAvatar(
                  radius: 50,
                  backgroundColor: Colors.grey[200],
                  backgroundImage: _selectedImageBytes != null
                      ? MemoryImage(_selectedImageBytes!)
                      : null,
                  child: _selectedImageBytes == null
                      ? const Icon(Icons.camera_alt,
                          size: 40, color: Colors.grey)
                      : null,
                ),
              ),
              const SizedBox(height: 24),
              // Other form fields remain the same
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _nameController.dispose();
    _levelController.dispose();
    _nationalityController.dispose();
    super.dispose();
  }
}
import 'package:flutter/material.dart';
import 'dart:typed_data';

class RegistrationForm extends StatelessWidget {
  final GlobalKey<FormState> formKey;
  final TextEditingController emailController;
  final TextEditingController passwordController;
  final TextEditingController nameController;
  final TextEditingController levelController;
  final TextEditingController nationalityController;
  final String preferredSide;
  final Function(String?) onSideChanged;
  final VoidCallback onImagePick;
  final Uint8List? selectedImageBytes;
  final String? error;

  const RegistrationForm({
    Key? key,
    required this.formKey,
    required this.emailController,
    required this.passwordController,
    required this.nameController,
    required this.levelController,
    required this.nationalityController,
    required this.preferredSide,
    required this.onSideChanged,
    required this.onImagePick,
    this.selectedImageBytes,
    this.error,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Form(
      key: formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          GestureDetector(
            onTap: onImagePick,
            child: CircleAvatar(
              radius: 50,
              backgroundColor: Colors.grey[200],
              backgroundImage: selectedImageBytes != null
                  ? MemoryImage(selectedImageBytes!)
                  : null,
              child: selectedImageBytes == null
                  ? const Icon(Icons.camera_alt, size: 40, color: Colors.grey)
                  : null,
            ),
          ),
          const SizedBox(height: 24),
          TextFormField(
            controller: nameController,
            decoration: const InputDecoration(
              labelText: 'Full Name',
              border: OutlineInputBorder(),
              prefixIcon: Icon(Icons.person),
            ),
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter your name';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          TextFormField(
            controller: emailController,
            decoration: const InputDecoration(
              labelText: 'Email',
              border: OutlineInputBorder(),
              prefixIcon: Icon(Icons.email),
            ),
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter your email';
              }
              if (!value.contains('@')) {
                return 'Please enter a valid email';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          TextFormField(
            controller: passwordController,
            decoration: const InputDecoration(
              labelText: 'Password',
              border: OutlineInputBorder(),
              prefixIcon: Icon(Icons.lock),
            ),
            obscureText: true,
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter a password';
              }
              if (value.length < 6) {
                return 'Password must be at least 6 characters';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          TextFormField(
            controller: levelController,
            decoration: const InputDecoration(
              labelText: 'Current Level (1-5)',
              border: OutlineInputBorder(),
              prefixIcon: Icon(Icons.stars),
            ),
            keyboardType: TextInputType.number,
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter your current level';
              }
              final level = double.tryParse(value);
              if (level == null || level < 1 || level > 5) {
                return 'Please enter a valid level between 1 and 5';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          TextFormField(
            controller: nationalityController,
            decoration: const InputDecoration(
              labelText: 'Nationality',
              border: OutlineInputBorder(),
              prefixIcon: Icon(Icons.flag),
            ),
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter your nationality';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          DropdownButtonFormField<String>(
            value: preferredSide,
            decoration: const InputDecoration(
              labelText: 'Preferred Side',
              border: OutlineInputBorder(),
              prefixIcon: Icon(Icons.sports_tennis),
            ),
            items: const [
              DropdownMenuItem(value: 'Left', child: Text('Left')),
              DropdownMenuItem(value: 'Right', child: Text('Right')),
              DropdownMenuItem(value: 'Both', child: Text('Both')),
            ],
            onChanged: onSideChanged,
          ),
          if (error != null) ...[
            const SizedBox(height: 24),
            Text(
              error!,
              style: const TextStyle(color: Colors.red),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/app_state.dart';
import 'form_view.dart';
import '../../models/player.dart';

class TableTabs extends StatelessWidget {
  const TableTabs({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 2,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Table'),
          bottom: const TabBar(
            tabs: [
              Tab(text: 'Form'),
              Tab(text: 'Match Results'),
            ],
          ),
        ),
        body: Consumer<AppState>(
          builder: (context, appState, child) {
            return TabBarView(
              children: [
                FormView(players: appState.players),
                EnhancedMatchResultsView(players: appState.players),
              ],
            );
          },
        ),
      ),
    );
  }
}

class EnhancedMatchResultsView extends StatelessWidget {
  final List<Player> players;

  const EnhancedMatchResultsView({
    Key? key,
    required this.players,
  }) : super(key: key);

  Color getRankColor(int rank) {
    if (rank >= 1 && rank <= 15) return Colors.blue.shade900;
    if (rank >= 16 && rank <= 30) return Colors.blue.shade300;
    if (rank >= 31 && rank <= 50) return Colors.amber;
    if (rank >= 51 && rank <= 70) return Colors.green;
    if (rank >= 71 && rank <= 90) return Colors.orange;
    return Colors.red;
  }

  @override
  Widget build(BuildContext context) {
    final sortedPlayers = List<Player>.from(players)
      ..sort((a, b) => b.statistics.rating.compareTo(a.statistics.rating));

    return Column(
      children: [
        // Header
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          color: Colors.grey.shade100,
          child: const Row(
            children: [
              Expanded(
                flex: 4,
                child: Text(
                  'Player',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
              ),
              Expanded(
                flex: 6,
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    SizedBox(
                        width: 40,
                        child: Text('PTS',
                            textAlign: TextAlign.center,
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(
                        width: 40,
                        child: Text('PLY',
                            textAlign: TextAlign.center,
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(
                        width: 40,
                        child: Text('W',
                            textAlign: TextAlign.center,
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(
                        width: 40,
                        child: Text('D',
                            textAlign: TextAlign.center,
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(
                        width: 40,
                        child: Text('L',
                            textAlign: TextAlign.center,
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(
                        width: 40,
                        child: Text('SW',
                            textAlign: TextAlign.center,
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(
                        width: 40,
                        child: Text('SL',
                            textAlign: TextAlign.center,
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(
                        width: 40,
                        child: Text('W%',
                            textAlign: TextAlign.center,
                            style: TextStyle(fontWeight: FontWeight.bold))),
                  ],
                ),
              ),
            ],
          ),
        ),

        // Player List
        Expanded(
          child: ListView.builder(
            itemCount: sortedPlayers.length,
            itemBuilder: (context, index) {
              final player = sortedPlayers[index];
              final rank = index + 1;

              return Container(
                decoration: BoxDecoration(
                  border:
                      Border(bottom: BorderSide(color: Colors.grey.shade200)),
                  color: Colors.white,
                ),
                child: Material(
                  color: Colors.transparent,
                  child: InkWell(
                    onTap: () => _showPlayerDetails(context, player),
                    child: Padding(
                      padding: const EdgeInsets.all(12),
                      child: Row(
                        children: [
                          // Player Info Section
                          Expanded(
                            flex: 4,
                            child: Row(
                              children: [
                                // Rank Circle
                                Container(
                                  width: 32,
                                  height: 32,
                                  alignment: Alignment.center,
                                  decoration: BoxDecoration(
                                    shape: BoxShape.circle,
                                    color: getRankColor(rank),
                                  ),
                                  child: Text(
                                    rank.toString(),
                                    style: const TextStyle(
                                      color: Colors.white,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ),
                                const SizedBox(width: 12),
                                // Player Avatar and Name
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Row(
                                        children: [
                                          CircleAvatar(
                                            radius: 16,
                                            backgroundImage:
                                                player.profileImage.isNotEmpty
                                                    ? NetworkImage(
                                                        player.profileImage)
                                                    : null,
                                            child: player.profileImage.isEmpty
                                                ? const Icon(Icons.person)
                                                : null,
                                          ),
                                          const SizedBox(width: 8),
                                          Expanded(
                                            child: Text(
                                              player.name,
                                              style: const TextStyle(
                                                  fontWeight: FontWeight.bold),
                                              overflow: TextOverflow.ellipsis,
                                            ),
                                          ),
                                        ],
                                      ),
                                      const SizedBox(height: 4),
                                      // Recent Results
                                      Row(
                                        children: player
                                            .statistics.recentMatches
                                            .take(7)
                                            .map((result) =>
                                                _buildResultBadge(result))
                                            .toList(),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),

                          // Stats Section
                          Expanded(
                            flex: 6,
                            child: Row(
                              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                              children: [
                                SizedBox(
                                    width: 40,
                                    child: Text(
                                        player.statistics.rating
                                            .toStringAsFixed(0),
                                        textAlign: TextAlign.center)),
                                SizedBox(
                                    width: 40,
                                    child: Text(
                                        player.statistics.totalMatches
                                            .toString(),
                                        textAlign: TextAlign.center)),
                                SizedBox(
                                    width: 40,
                                    child: Text(
                                        player.statistics.wins.toString(),
                                        textAlign: TextAlign.center)),
                                SizedBox(
                                    width: 40,
                                    child: Text(
                                        player.statistics.draws.toString(),
                                        textAlign: TextAlign.center)),
                                SizedBox(
                                    width: 40,
                                    child: Text(
                                        player.statistics.losses.toString(),
                                        textAlign: TextAlign.center)),
                                SizedBox(
                                    width: 40,
                                    child: Text(
                                        player.statistics.setsWon.toString(),
                                        textAlign: TextAlign.center)),
                                SizedBox(
                                    width: 40,
                                    child: Text(
                                        player.statistics.setsLost.toString(),
                                        textAlign: TextAlign.center)),
                                SizedBox(
                                    width: 40,
                                    child: Text(
                                        '${player.statistics.winRate.toStringAsFixed(1)}%',
                                        textAlign: TextAlign.center)),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildResultBadge(String result) {
    Color backgroundColor;
    Color textColor;

    switch (result) {
      case 'W':
        backgroundColor = Colors.green.shade100;
        textColor = Colors.green.shade800;
        break;
      case 'D':
        backgroundColor = Colors.orange.shade100;
        textColor = Colors.orange.shade800;
        break;
      default:
        backgroundColor = Colors.red.shade100;
        textColor = Colors.red.shade800;
    }

    return Container(
      margin: const EdgeInsets.only(right: 4),
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        result,
        style: TextStyle(
          color: textColor,
          fontSize: 10,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  void _showPlayerDetails(BuildContext context, Player player) {
    showModalBottomSheet(
      context: context,
      builder: (context) => _PlayerDetailsSheet(player: player),
    );
  }
}

class _PlayerDetailsSheet extends StatelessWidget {
  final Player player;

  const _PlayerDetailsSheet({
    Key? key,
    required this.player,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              CircleAvatar(
                radius: 24,
                backgroundImage: player.profileImage.isNotEmpty
                    ? NetworkImage(player.profileImage)
                    : null,
                child: player.profileImage.isEmpty
                    ? const Icon(Icons.person)
                    : null,
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      player.name,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      'Rating: ${player.statistics.rating.toStringAsFixed(1)}',
                      style: TextStyle(
                        color: Colors.blue.shade700,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const Divider(height: 32),
          Wrap(
            spacing: 16,
            runSpacing: 16,
            children: [
              _buildStatItem(
                  'Total Matches', player.statistics.totalMatches.toString()),
              _buildStatItem('Wins', player.statistics.wins.toString()),
              _buildStatItem('Win Rate',
                  '${player.statistics.winRate.toStringAsFixed(1)}%'),
              _buildStatItem('Sets Won', player.statistics.setsWon.toString()),
              _buildStatItem(
                  'Sets Lost', player.statistics.setsLost.toString()),
              _buildStatItem('Current Streak',
                  _formatStreak(player.statistics.currentStreak)),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            label,
            style: TextStyle(
              color: Colors.grey.shade600,
              fontSize: 12,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            value,
            style: const TextStyle(
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }

  String _formatStreak(int streak) {
    if (streak == 0) return '0';
    if (streak > 0) return '+$streak';
    return streak.toString();
  }
}
import 'package:flutter/material.dart';
import '../../models/player.dart';

class FormView extends StatelessWidget {
  final List<Player> players;

  const FormView({Key? key, required this.players}) : super(key: key);

  Color getRankColor(int rank) {
    if (rank >= 1 && rank <= 15) return Colors.blue.shade900;
    if (rank >= 16 && rank <= 30) return Colors.blue.shade300;
    if (rank >= 31 && rank <= 50) return Colors.amber;
    if (rank >= 51 && rank <= 70) return Colors.green;
    if (rank >= 71 && rank <= 90) return Colors.orange;
    return Colors.red;
  }

  @override
  Widget build(BuildContext context) {
    final sortedPlayers = List<Player>.from(players)
      ..sort((a, b) => a.statistics.rating.compareTo(b.statistics.rating));

    return Column(
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          color: Colors.grey.shade100,
          child: const Row(
            children: [
              Expanded(
                child: Text(
                  'Padeltrax S League',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
              ),
              SizedBox(
                  width: 80,
                  child: Text('Rating',
                      style: TextStyle(fontWeight: FontWeight.bold))),
              SizedBox(
                  width: 120,
                  child: Text('Form',
                      style: TextStyle(fontWeight: FontWeight.bold))),
            ],
          ),
        ),
        Expanded(
          child: ListView.builder(
            itemCount: sortedPlayers.length,
            itemBuilder: (context, index) {
              final player = sortedPlayers[index];
              return InkWell(
                onTap: () => _showPlayerStats(context, player),
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    border:
                        Border(bottom: BorderSide(color: Colors.grey.shade200)),
                  ),
                  child: Row(
                    children: [
                      _buildRankBadge(index + 1),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Row(
                          children: [
                            player.avatar(size: 32),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    player.name,
                                    style: const TextStyle(
                                        fontWeight: FontWeight.bold),
                                  ),
                                  Text(
                                    '${player.statistics.wins}W ${player.statistics.draws}D ${player.statistics.losses}L',
                                    style: TextStyle(
                                      fontSize: 12,
                                      color: Colors.grey.shade600,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                      SizedBox(
                        width: 80,
                        child: Text(
                          player.statistics.rating.toStringAsFixed(2),
                          style: const TextStyle(fontWeight: FontWeight.bold),
                        ),
                      ),
                      SizedBox(
                        width: 120,
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children:
                              player.statistics.recentMatches.map((result) {
                            return Container(
                              width: 22,
                              height: 22,
                              margin: const EdgeInsets.only(left: 2),
                              alignment: Alignment.center,
                              decoration: BoxDecoration(
                                color: _getResultColor(result),
                                borderRadius: BorderRadius.circular(4),
                              ),
                              child: Text(
                                result,
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontWeight: FontWeight.bold,
                                  fontSize: 12,
                                ),
                              ),
                            );
                          }).toList(),
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildRankBadge(int rank) {
    return Container(
      width: 32,
      height: 32,
      alignment: Alignment.center,
      decoration: BoxDecoration(
        color: getRankColor(rank),
        shape: BoxShape.circle,
      ),
      child: Text(
        rank.toString(),
        style: const TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  Color _getResultColor(String result) {
    switch (result) {
      case 'W':
        return Colors.green;
      case 'D':
        return Colors.orange;
      case 'L':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }

  void _showPlayerStats(BuildContext context, Player player) {
    showModalBottomSheet(
      context: context,
      builder: (context) => _PlayerStatsSheet(player: player),
    );
  }
}

class _PlayerStatsSheet extends StatelessWidget {
  final Player player;

  const _PlayerStatsSheet({Key? key, required this.player}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              player.avatar(size: 48),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(player.name,
                        style: const TextStyle(
                            fontSize: 18, fontWeight: FontWeight.bold)),
                    Text(
                        'Rating: ${player.statistics.rating.toStringAsFixed(2)}',
                        style: TextStyle(color: Colors.blue.shade700)),
                  ],
                ),
              ),
            ],
          ),
          const Divider(height: 32),
          Wrap(
            spacing: 16,
            runSpacing: 16,
            children: [
              _buildStatItem(
                  'Matches', player.statistics.totalMatches.toString()),
              _buildStatItem('Wins', player.statistics.wins.toString()),
              _buildStatItem('Win Rate',
                  '${player.statistics.winRate.toStringAsFixed(1)}%'),
              _buildStatItem('Current Streak',
                  _formatStreak(player.statistics.currentStreak)),
              _buildStatItem('Sets Won', player.statistics.setsWon.toString()),
              _buildStatItem(
                  'Games Won', player.statistics.gamesWon.toString()),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(label,
              style: TextStyle(color: Colors.grey.shade600, fontSize: 12)),
          const SizedBox(height: 4),
          Text(value, style: const TextStyle(fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }

  String _formatStreak(int streak) {
    if (streak == 0) return '0';
    if (streak > 0) return '+$streak';
    return streak.toString();
  }
}
import 'package:flutter/material.dart';
import '../../models/player.dart';

class EnhancedMatchResultsView extends StatelessWidget {
  final List<Player> players;

  const EnhancedMatchResultsView({
    Key? key,
    required this.players,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final sortedPlayers = List<Player>.from(players)
      ..sort((a, b) => b.statistics.rating.compareTo(a.statistics.rating));

    return Column(
      children: [
        // Stats Header
        _StatsHeader(),
        // Player List
        Expanded(
          child: ListView.builder(
            itemCount: sortedPlayers.length,
            itemBuilder: (context, index) {
              final player = sortedPlayers[index];
              return _PlayerRow(
                player: player,
                rank: index + 1,
                isEven: index.isEven,
              );
            },
          ),
        ),
      ],
    );
  }
}

class _PlayerRow extends StatelessWidget {
  final Player player;
  final int rank;
  final bool isEven;

  const _PlayerRow({
    Key? key,
    required this.player,
    required this.rank,
    required this.isEven,
  }) : super(key: key);

  Color _getRankColor() {
    if (rank <= 3) return Colors.blue.shade700;
    if (rank <= 10) return Colors.green.shade700;
    return Colors.grey.shade600;
  }

  Widget _buildResultBadge(String result) {
    Color color;
    switch (result) {
      case 'W':
        color = Colors.green.shade700;
        break;
      case 'D':
        color = Colors.orange.shade800;
        break;
      default:
        color = Colors.red.shade700;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      margin: const EdgeInsets.only(right: 4),
      decoration: BoxDecoration(
        color: color,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        result,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;

    return Container(
      decoration: BoxDecoration(
        color: isEven ? Colors.grey.shade50 : Colors.white,
        border: Border(
          bottom: BorderSide(color: Colors.grey.shade200),
        ),
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () => _showPlayerDetails(context),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 4.0),
            child: Row(
              children: [
                // Player info section
                SizedBox(
                  width: screenWidth * 0.4,
                  child: Row(
                    children: [
                      // Rank circle
                      Container(
                        width: 24,
                        height: 24,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: _getRankColor(),
                        ),
                        child: Center(
                          child: Text(
                            rank.toString(),
                            style: const TextStyle(
                              color: Colors.white,
                              fontWeight: FontWeight.bold,
                              fontSize: 12,
                            ),
                          ),
                        ),
                      ),
                      const SizedBox(width: 4),
                      // Player avatar and name
                      Expanded(
                        child: Row(
                          children: [
                            CircleAvatar(
                              radius: 12,
                              backgroundImage: player.profileImage.isNotEmpty
                                  ? NetworkImage(player.profileImage)
                                  : null,
                              child: player.profileImage.isEmpty
                                  ? const Icon(Icons.person, size: 12)
                                  : null,
                            ),
                            const SizedBox(width: 4),
                            Expanded(
                              child: Text(
                                player.name,
                                style: const TextStyle(
                                  fontWeight: FontWeight.w500,
                                  fontSize: 12,
                                ),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),

                // Stats section
                Expanded(
                  child: Row(
                    children: [
                      _buildStatColumn(
                          'PTS', player.statistics.rating.toStringAsFixed(0)),
                      _buildVerticalDivider(),
                      _buildStatColumn(
                          'PLY', player.statistics.totalMatches.toString()),
                      _buildVerticalDivider(),
                      _buildStatColumn(
                        'W',
                        player.statistics.wins.toString(),
                        textColor: player.statistics.wins > 0
                            ? Colors.green.shade700
                            : null,
                      ),
                      _buildVerticalDivider(),
                      _buildStatColumn('D', player.statistics.draws.toString()),
                      _buildVerticalDivider(),
                      _buildStatColumn(
                        'L',
                        player.statistics.losses.toString(),
                        textColor: player.statistics.losses > 0
                            ? Colors.red.shade700
                            : null,
                      ),
                      _buildVerticalDivider(),
                      _buildStatColumn(
                          'SW', player.statistics.setsWon.toString()),
                      _buildVerticalDivider(),
                      _buildStatColumn(
                          'SL', player.statistics.setsLost.toString()),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildVerticalDivider() {
    return Container(
      width: 1,
      height: double.infinity,
      color: Colors.grey.shade300,
    );
  }

  Widget _buildStatColumn(String label, String value, {Color? textColor}) {
    return Expanded(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            value,
            style: TextStyle(
              fontSize: 13,
              fontWeight: FontWeight.bold,
              color: textColor ?? Colors.grey.shade800,
            ),
          ),
          Text(
            label,
            style: TextStyle(
              fontSize: 10,
              color: Colors.grey.shade600,
            ),
          ),
        ],
      ),
    );
  }

  void _showPlayerDetails(BuildContext context) {
    // Placeholder for showing details
  }
}

class _StatsHeader extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;

    return Container(
      height: 40,
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        border: Border(
          bottom: BorderSide(color: Colors.grey.shade300),
        ),
      ),
      child: Row(
        children: [
          // Player header
          SizedBox(
            width: screenWidth * 0.4,
            child: const Padding(
              padding: EdgeInsets.only(left: 8.0),
              child: Text(
                'Player',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 13,
                ),
              ),
            ),
          ),

          // Stats headers
          Expanded(
            child: Row(
              children: [
                _buildHeaderColumn('PTS'),
                _buildVerticalDivider(),
                _buildHeaderColumn('PLY'),
                _buildVerticalDivider(),
                _buildHeaderColumn('W'),
                _buildVerticalDivider(),
                _buildHeaderColumn('D'),
                _buildVerticalDivider(),
                _buildHeaderColumn('L'),
                _buildVerticalDivider(),
                _buildHeaderColumn('SW'),
                _buildVerticalDivider(),
                _buildHeaderColumn('SL'),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHeaderColumn(String label) {
    return Expanded(
      child: Center(
        child: Text(
          label,
          style: const TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 12,
          ),
        ),
      ),
    );
  }

  Widget _buildVerticalDivider() {
    return Container(
      width: 1,
      height: double.infinity,
      color: Colors.grey.shade300,
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/app_state.dart';
import '../../models/player.dart';
import '../../theme/theme.dart';
import 'booking_details_page.dart';

class BookingsPage extends StatelessWidget {
  const BookingsPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer<AppState>(
      builder: (context, appState, child) {
        if (appState.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }

        if (appState.players.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.person_off, size: 64, color: Colors.grey),
                const SizedBox(height: 16),
                const Text(
                  'No players available',
                  style: TextStyle(color: Colors.grey),
                ),
                const SizedBox(height: 24),
                ElevatedButton.icon(
                  onPressed: () {
                    appState
                        .initializeStreams(); // No `await` since it's a void function
                  },
                  icon: const Icon(Icons.refresh),
                  label: const Text('Refresh'),
                ),
              ],
            ),
          );
        }

        return Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [AppTheme.primaryColor, AppTheme.secondaryColor],
            ),
          ),
          child: RefreshIndicator(
            onRefresh: () async {
              appState
                  .initializeStreams(); // Ensure this function returns a Future
            },
            child: ListView.builder(
              padding: const EdgeInsets.only(top: 8),
              itemCount: appState.players.length,
              itemBuilder: (context, index) {
                Player player = appState.players[index];
                return buildPlayerCard(context, player);
              },
            ),
          ),
        );
      },
    );
  }

  Widget buildPlayerCard(BuildContext context, Player player) {
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      elevation: 4,
      color: Colors.grey[200], // Soft gray color for the card
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        onTap: () => _navigateToBookingDetails(context, player),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(12.0),
          child: Row(
            children: [
              buildPlayerAvatar(player),
              const SizedBox(width: 16),
              Expanded(
                child: buildPlayerInfo(context, player),
              ),
              buildNavigationIcon(),
            ],
          ),
        ),
      ),
    );
  }

  Widget buildPlayerAvatar(Player player) {
    return CircleAvatar(
      radius: 30,
      backgroundImage: player.profileImage.isNotEmpty
          ? NetworkImage(player.profileImage)
          : const AssetImage('assets/images/profile.png')
              as ImageProvider<Object>?,
      backgroundColor: Colors.grey[300],
      onBackgroundImageError: (_, __) {
        debugPrint('Error loading profile image for ${player.name}');
      },
    );
  }

  Widget buildPlayerInfo(BuildContext context, Player player) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          player.name,
          style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
        ),
        const SizedBox(height: 4),
        Row(
          children: [
            Icon(Icons.sports_tennis, size: 16, color: Colors.grey[600]),
            const SizedBox(width: 4),
            Text(
              'Rank: ${player.rank}',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ],
        ),
        if (player.signedTimeslots.isNotEmpty) ...[
          const SizedBox(height: 8),
          buildBookingTags(context, player),
        ],
      ],
    );
  }

  Widget buildBookingTags(BuildContext context, Player player) {
    return Wrap(
      spacing: 4,
      runSpacing: 4,
      children: player.signedTimeslots.entries.map((entry) {
        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: Colors.green.withOpacity(0.1),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.green),
          ),
          child: Text(
            '${entry.key}: ${entry.value}',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Colors.green[700],
                  fontWeight: FontWeight.w500,
                ),
          ),
        );
      }).toList(),
    );
  }

  Widget buildNavigationIcon() {
    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Colors.grey.withOpacity(0.1),
        shape: BoxShape.circle,
      ),
      child: Icon(
        Icons.chevron_right,
        color: Colors.grey[400],
      ),
    );
  }

  Future<void> _navigateToBookingDetails(
      BuildContext context, Player player) async {
    try {
      final updatedPlayer = await Navigator.push<Player?>(
        context,
        MaterialPageRoute(
          builder: (context) => BookingDetailsPage(player: player),
        ),
      );

      if (updatedPlayer != null && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Bookings updated successfully'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating bookings: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/player.dart';
import '../../providers/app_state.dart';
import '../../theme/theme.dart';

class BookingDetailsPage extends StatefulWidget {
  final Player player;

  const BookingDetailsPage({Key? key, required this.player}) : super(key: key);

  @override
  State<BookingDetailsPage> createState() => _BookingDetailsPageState();
}

class _BookingDetailsPageState extends State<BookingDetailsPage> {
  final Map<String, String> _selectedTimeslots = {};
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    _selectedTimeslots.addAll(widget.player.signedTimeslots);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: AppTheme.primaryColor,
        title: Text(
          'Bookings - ${widget.player.name}',
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        centerTitle: true,
        elevation: 2,
      ),
      body: Stack(
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildPlayerHeader(context),
              const SizedBox(height: 12),
              Expanded(
                child: _buildTimeslotSelector(),
              ),
              const SizedBox(height: 8),
              _buildActionButtons(context),
            ],
          ),
          if (_isSaving)
            Container(
              color: Colors.black.withOpacity(0.3),
              child: const Center(
                child: CircularProgressIndicator(),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildPlayerHeader(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16.0),
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          colors: [AppTheme.primaryColor, AppTheme.secondaryColor],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.vertical(bottom: Radius.circular(16)),
      ),
      child: Row(
        children: [
          CircleAvatar(
            radius: 45,
            backgroundImage: widget.player.profileImage.isNotEmpty
                ? NetworkImage(widget.player.profileImage)
                : const AssetImage('assets/images/profile.png')
                    as ImageProvider,
            backgroundColor: Colors.grey[300],
          ),
          const SizedBox(width: 16),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                widget.player.name,
                style: const TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                'Rating: ${widget.player.rating.toStringAsFixed(1)}',
                style: const TextStyle(
                  fontSize: 16,
                  color: Colors.white70,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTimeslotSelector() {
    final days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
    final timeslots = ['Early Timeslot', 'Later Timeslot'];

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      child: ListView.separated(
        itemCount: days.length,
        separatorBuilder: (_, __) => const Divider(thickness: 1),
        itemBuilder: (context, index) {
          final day = days[index];
          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                day,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                  color: AppTheme.primaryColor,
                ),
              ),
              const SizedBox(height: 8),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: timeslots.map((timeslot) {
                  final isSelected = _selectedTimeslots[day] == timeslot;
                  return GestureDetector(
                    onTap: () {
                      setState(() {
                        if (isSelected) {
                          _selectedTimeslots.remove(day);
                        } else {
                          _selectedTimeslots[day] = timeslot;
                        }
                      });
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 16,
                        vertical: 12,
                      ),
                      decoration: BoxDecoration(
                        color: isSelected
                            ? AppTheme.primaryColor
                            : Colors.grey[200],
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(
                          color: isSelected ? Colors.white : Colors.grey,
                          width: 1,
                        ),
                      ),
                      child: Text(
                        timeslot == 'Early Timeslot' ? 'Early' : 'Late',
                        style: TextStyle(
                          color: isSelected ? Colors.white : Colors.black87,
                          fontWeight:
                              isSelected ? FontWeight.bold : FontWeight.normal,
                        ),
                      ),
                    ),
                  );
                }).toList(),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildActionButtons(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Row(
        children: [
          Expanded(
            child: OutlinedButton(
              onPressed: _isSaving
                  ? null
                  : () {
                      Navigator.pop(context);
                    },
              style: OutlinedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 14),
                side: const BorderSide(color: AppTheme.primaryColor),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: const Text(
                'Cancel',
                style: TextStyle(
                  color: AppTheme.primaryColor,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: ElevatedButton(
              onPressed: _isSaving ? null : _handleSave,
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 14),
                backgroundColor: AppTheme.primaryColor,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: _isSaving
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                      ),
                    )
                  : const Text(
                      'Save',
                      style: TextStyle(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _handleSave() async {
    if (_isSaving) return;

    setState(() {
      _isSaving = true;
    });

    try {
      final appState = context.read<AppState>();

      // Delete existing bookings first
      await appState.deletePlayerBookings(widget.player.id);

      // Create new bookings
      for (final entry in _selectedTimeslots.entries) {
        await appState.createBooking(
          widget.player.id,
          entry.key,
          entry.value,
        );
      }

      // Update local player state
      widget.player.signedTimeslots.clear();
      widget.player.signedTimeslots.addAll(_selectedTimeslots);

      if (!mounted) return;

      // Show success message
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Bookings saved successfully'),
          backgroundColor: Colors.green,
        ),
      );

      Navigator.pop(context, widget.player);
    } catch (e) {
      debugPrint('Error saving bookings: $e');
      if (!mounted) return;

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error saving bookings: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSaving = false;
        });
      }
    }
  }
}
import 'package:flutter/material.dart';
import 'main_dashboard/main_dashboard.dart';

class StartingPage extends StatelessWidget {
  const StartingPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Theme.of(context)
          .scaffoldBackgroundColor, // Use theme background color
      body: SafeArea(
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Logo
              Image.asset(
                'assets/images/padeltrax_logo.png',
                width: 200,
                height: 200,
              ),
              const SizedBox(height: 20),
              Text(
                'Welcome to Padeltrax',
                style:
                    Theme.of(context).textTheme.displayLarge, // Use theme style
              ),
              const SizedBox(height: 40),
              ElevatedButton(
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => const MainDashboard(),
                    ),
                  );
                },
                child: Text(
                  'Start Playing',
                  style: Theme.of(context)
                      .textTheme
                      .labelLarge, // Use labelLarge from theme
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/app_state.dart';
import '../../models/player.dart';

class SchedulePage extends StatefulWidget {
  const SchedulePage({Key? key}) : super(key: key);

  @override
  SchedulePageState createState() => SchedulePageState();
}

class SchedulePageState extends State<SchedulePage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final List<String> _days = [
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday'
  ];

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 5, vsync: this);

    // Initial load of all days' bookings
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadAllBookings();
    });

    // Listen for tab changes
    _tabController.addListener(() {
      if (_tabController.indexIsChanging) {
        _loadBookingsForCurrentDay();
      }
    });
  }

  void _loadAllBookings() {
    if (!mounted) return;

    final appState = context.read<AppState>();
    for (final day in _days) {
      appState.loadBookingsForDay(day);
    }
  }

  void _loadBookingsForCurrentDay() {
    if (!mounted) return;

    final currentDay = _days[_tabController.index];
    context.read<AppState>().loadBookingsForDay(currentDay);
  }

  Widget buildTimeSlotColumn(
    String title,
    List<Map<String, dynamic>> bookings,
    List<Player> players,
    String timeslot,
  ) {
    // Filter bookings for this timeslot
    final timeSlotBookings = bookings.where((b) {
      final bookingTimeslot = b['timeslot'] as String?;
      return bookingTimeslot == timeslot || bookingTimeslot == 'Play Either';
    }).toList();

    return Expanded(
      child: Card(
        elevation: 2,
        margin: const EdgeInsets.all(8),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header with title
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.blue.shade700,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(4),
                  topRight: Radius.circular(4),
                ),
              ),
              child: Text(
                title,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
            ),
            // Display bookings or a message if empty
            if (timeSlotBookings.isEmpty)
              const Padding(
                padding: EdgeInsets.all(16),
                child: Text(
                  'No players signed up for this timeslot.',
                  style: TextStyle(
                    color: Colors.grey,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              )
            else
              Expanded(
                child: ListView.builder(
                  itemCount: timeSlotBookings.length,
                  itemBuilder: (context, index) {
                    final booking = timeSlotBookings[index];
                    final player = players.firstWhere(
                      (p) => p.id == booking['playerId'],
                      orElse: () => Player(
                        id: 'unknown',
                        name: 'Unknown Player',
                        rating: 0,
                        rank: 0,
                        profileImage: 'assets/images/profile.png',
                        createdAt: DateTime.now(),
                      ),
                    );

                    return ListTile(
                      leading: player.avatar(size: 40),
                      title: Text(player.name),
                      subtitle: Text(
                        booking['timeslot'] == 'Play Either'
                            ? 'Available for both timeslots'
                            : 'Rating: ${player.rating}',
                      ),
                    );
                  },
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget buildDaySchedule(String day, AppState appState) {
    final dayBookings = appState.bookings[day] ?? [];

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                buildTimeSlotColumn(
                  'Early Timeslot',
                  dayBookings,
                  appState.players,
                  'Early Timeslot',
                ),
                buildTimeSlotColumn(
                  'Later Timeslot',
                  dayBookings,
                  appState.players,
                  'Later Timeslot',
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Schedule'),
        bottom: TabBar(
          controller: _tabController,
          tabs: _days.map((day) => Tab(text: day)).toList(),
          isScrollable: true,
        ),
        actions: [
          // Add refresh button
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadAllBookings,
          ),
        ],
      ),
      body: Consumer<AppState>(
        builder: (context, appState, child) {
          if (appState.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }

          return TabBarView(
            controller: _tabController,
            children: _days.map((day) {
              final bookings = appState.bookings[day] ?? [];
              return buildDaySchedule(day, appState);
            }).toList(),
          );
        },
      ),
    );
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../booking/bookings_page.dart';
import '../table/table_tabs.dart';
import '../schedule/schedule_page.dart';
import '../match/match_view.dart';
import '../../services/auth_service.dart';
import '../auth/login_screen.dart';
import '../../providers/app_state.dart';

class MainDashboard extends StatefulWidget {
  const MainDashboard({Key? key}) : super(key: key);

  @override
  State<MainDashboard> createState() => _MainDashboardState();
}

class _MainDashboardState extends State<MainDashboard> {
  int _selectedIndex = 0;
  final AuthService _authService = AuthService();
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    // Initialize AppState streams when dashboard is created
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<AppState>().initializeStreams();
    });
  }

  @override
  Widget build(BuildContext context) {
    final appState = context.watch<AppState>();

    // Define the main screens
    final List<Widget> screens = [
      const BookingsPage(),
      const TableTabs(),
      const SchedulePage(),
      const MatchView(),
    ];

    return Scaffold(
      body: Stack(
        children: [
          screens[_selectedIndex], // Display the selected screen
          if (appState.isLoading || _isLoading)
            Container(
              color: Colors.black54,
              child: const Center(
                child: CircularProgressIndicator(),
              ),
            ),
        ],
      ),
      bottomNavigationBar: BottomNavigationBar(
        items: const <BottomNavigationBarItem>[
          BottomNavigationBarItem(
            icon: Icon(Icons.calendar_today),
            label: 'Bookings',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.table_chart),
            label: 'Table',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.schedule),
            label: 'Schedule',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.sports_tennis),
            label: 'Match Day',
          ),
        ],
        currentIndex: _selectedIndex,
        selectedItemColor: Colors.blue,
        unselectedItemColor: Colors.grey,
        showUnselectedLabels: true,
        type: BottomNavigationBarType.fixed,
        onTap: _handleNavigation,
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: appState.initializeStreams,
        tooltip: 'Refresh',
        child: const Icon(Icons.refresh),
      ),
    );
  }

  void _handleNavigation(int index) {
    setState(() {
      _selectedIndex = index;
    });

    final appState = context.read<AppState>();
    switch (index) {
      case 0: // Bookings
        appState.initializeStreams();
        break;
      case 1: // Table
        appState.initializeStreams();
        break;
      case 2: // Schedule
        final weekdays = [
          'Monday',
          'Tuesday',
          'Wednesday',
          'Thursday',
          'Friday'
        ];
        for (var day in weekdays) {
          appState.loadBookingsForDay(day);
        }
        break;
      case 3: // Match Day
        appState.refreshMatches();
        break;
    }
  }

  Future<void> _handleLogout() async {
    try {
      setState(() => _isLoading = true);

      await FirebaseAuth.instance.signOut();
      await _authService.signOut();

      if (!mounted) return;

      Navigator.of(context).pushAndRemoveUntil(
        MaterialPageRoute(builder: (context) => const LoginScreen()),
        (Route<dynamic> route) => false,
      );
    } catch (e) {
      if (!mounted) return;

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error logging out: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';

class UserModel {
  final String id;
  final String email;
  final String name;
  final double level;
  final String nationality;
  final String preferredSide;
  final String? profileImageUrl;
  final bool isAdmin;
  final bool isLevelVerified;
  final DateTime createdAt;
  final DateTime? lastLoginAt;

  UserModel({
    required this.id,
    required this.email,
    required this.name,
    required this.level,
    required this.nationality,
    required this.preferredSide,
    this.profileImageUrl,
    this.isAdmin = false,
    this.isLevelVerified = false,
    required this.createdAt,
    this.lastLoginAt,
  });

  factory UserModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;

    return UserModel(
      id: doc.id,
      email: data['email'] as String? ?? '',
      name: data['name'] as String? ?? '',
      level: (data['level'] as num?)?.toDouble() ?? 0.0,
      nationality: data['nationality'] as String? ?? '',
      preferredSide: data['preferredSide'] as String? ?? 'Right',
      profileImageUrl: data['profileImageUrl'] as String?,
      isAdmin: data['isAdmin'] as bool? ?? false,
      isLevelVerified: data['isLevelVerified'] as bool? ?? false,
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      lastLoginAt: (data['lastLoginAt'] as Timestamp?)?.toDate(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'email': email,
      'name': name,
      'level': level,
      'nationality': nationality,
      'preferredSide': preferredSide,
      'profileImageUrl': profileImageUrl,
      'isAdmin': isAdmin,
      'isLevelVerified': isLevelVerified,
      'createdAt': Timestamp.fromDate(createdAt),
      'lastLoginAt':
          lastLoginAt != null ? Timestamp.fromDate(lastLoginAt!) : null,
    };
  }

  UserModel copyWith({
    String? email,
    String? name,
    double? level,
    String? nationality,
    String? preferredSide,
    String? profileImageUrl,
    bool? isAdmin,
    bool? isLevelVerified,
    DateTime? lastLoginAt,
  }) {
    return UserModel(
      id: id,
      email: email ?? this.email,
      name: name ?? this.name,
      level: level ?? this.level,
      nationality: nationality ?? this.nationality,
      preferredSide: preferredSide ?? this.preferredSide,
      profileImageUrl: profileImageUrl ?? this.profileImageUrl,
      isAdmin: isAdmin ?? this.isAdmin,
      isLevelVerified: isLevelVerified ?? this.isLevelVerified,
      createdAt: createdAt,
      lastLoginAt: lastLoginAt ?? this.lastLoginAt,
    );
  }
}
import '../match/match_result.dart';
import '../match/achievement.dart';

class PlayerStatistics {
  int wins;
  int losses;
  int draws;
  int setsWon;
  int setsLost;
  int gamesWon;
  int gamesLost;
  List<String> recentMatches;
  List<MatchResult> recentResults;
  double winRate;
  double rating;
  int currentStreak;
  List<double> last10MatchesRating;
  Map<String, int> partnershipMatches;
  Map<String, double> partnershipWinRate;
  List<Achievement> achievements;
  DateTime? lastMatchDate;

  PlayerStatistics({
    this.wins = 0,
    this.losses = 0,
    this.draws = 0,
    this.setsWon = 0,
    this.setsLost = 0,
    this.gamesWon = 0,
    this.gamesLost = 0,
    List<String>? recentMatches,
    List<MatchResult>? recentResults,
    this.winRate = 0.0,
    this.rating = 0.0,
    this.currentStreak = 0,
    List<double>? last10MatchesRating,
    Map<String, int>? partnershipMatches,
    Map<String, double>? partnershipWinRate,
    List<Achievement>? achievements,
    this.lastMatchDate,
  })  : recentMatches = recentMatches ?? [],
        recentResults = recentResults ?? [],
        last10MatchesRating = last10MatchesRating ?? [],
        partnershipMatches = partnershipMatches ?? {},
        partnershipWinRate = partnershipWinRate ?? {},
        achievements = achievements ?? [];

  factory PlayerStatistics.fromMap(Map<String, dynamic>? map) {
    if (map == null) return PlayerStatistics();

    return PlayerStatistics(
      wins: (map['wins'] as num?)?.toInt() ?? 0,
      losses: (map['losses'] as num?)?.toInt() ?? 0,
      draws: (map['draws'] as num?)?.toInt() ?? 0,
      setsWon: (map['setsWon'] as num?)?.toInt() ?? 0,
      setsLost: (map['setsLost'] as num?)?.toInt() ?? 0,
      gamesWon: (map['gamesWon'] as num?)?.toInt() ?? 0,
      gamesLost: (map['gamesLost'] as num?)?.toInt() ?? 0,
      recentMatches: (map['recentMatches'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          [],
      recentResults: (map['recentResults'] as List<dynamic>?)
              ?.map((e) => MatchResult.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      winRate: (map['winRate'] as num?)?.toDouble() ?? 0.0,
      rating: (map['rating'] as num?)?.toDouble() ?? 0.0,
      currentStreak: (map['currentStreak'] as num?)?.toInt() ?? 0,
      last10MatchesRating: (map['last10MatchesRating'] as List<dynamic>?)
              ?.map((e) => (e as num).toDouble())
              .toList() ??
          [],
      partnershipMatches: (map['partnershipMatches'] as Map<String, dynamic>?)
              ?.map((key, value) => MapEntry(key, (value as num).toInt())) ??
          {},
      partnershipWinRate: (map['partnershipWinRate'] as Map<String, dynamic>?)
              ?.map((key, value) => MapEntry(key, (value as num).toDouble())) ??
          {},
      achievements: (map['achievements'] as List<dynamic>?)
              ?.map((e) => Achievement.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      lastMatchDate: map['lastMatchDate'] != null
          ? DateTime.parse(map['lastMatchDate'] as String)
          : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'wins': wins,
      'losses': losses,
      'draws': draws,
      'setsWon': setsWon,
      'setsLost': setsLost,
      'gamesWon': gamesWon,
      'gamesLost': gamesLost,
      'recentMatches': recentMatches,
      'recentResults': recentResults.map((r) => r.toMap()).toList(),
      'winRate': winRate,
      'rating': rating,
      'currentStreak': currentStreak,
      'last10MatchesRating': last10MatchesRating,
      'partnershipMatches': partnershipMatches,
      'partnershipWinRate': partnershipWinRate,
      'achievements': achievements.map((a) => a.toMap()).toList(),
      'lastMatchDate': lastMatchDate?.toIso8601String(),
    };
  }

  void updateStats(MatchResult result) {
    if (result.isWin) {
      wins++;
      currentStreak = currentStreak > 0 ? currentStreak + 1 : 1;
    } else if (result.isDraw) {
      draws++;
      currentStreak = 0;
    } else {
      losses++;
      currentStreak = currentStreak < 0 ? currentStreak - 1 : -1;
    }

    setsWon += result.setsWon;
    setsLost += result.setsLost;
    gamesWon += result.gamesWon;
    gamesLost += result.gamesLost;

    winRate = totalMatches > 0 ? (wins / totalMatches) * 100 : 0;
    rating += result.ratingChange;

    recentResults.insert(0, result);
    if (recentResults.length > 10) {
      recentResults = recentResults.sublist(0, 10);
    }

    recentMatches.insert(0, result.isWin ? 'W' : (result.isDraw ? 'D' : 'L'));
    if (recentMatches.length > 10) {
      recentMatches = recentMatches.sublist(0, 10);
    }

    last10MatchesRating.insert(0, rating);
    if (last10MatchesRating.length > 10) {
      last10MatchesRating = last10MatchesRating.sublist(0, 10);
    }

    lastMatchDate = DateTime.now();
    _checkAchievements(result);
  }

  void _checkAchievements(MatchResult result) {
    if (currentStreak >= 5) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.winStreak,
        value: currentStreak,
      ));
    }

    if (wins == 1) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.firstWin,
      ));
    }

    if (result.hasPerfectSet) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.perfectSet,
      ));
    }
  }

  void updatePartnershipStats(String partnerName, bool isWin) {
    partnershipMatches.update(
      partnerName,
      (value) => value + 1,
      ifAbsent: () => 1,
    );

    final currentWins = partnershipWinRate[partnerName] ?? 0;
    final totalMatches = partnershipMatches[partnerName] ?? 0;

    if (isWin) {
      partnershipWinRate[partnerName] =
          ((currentWins * totalMatches) + 100) / (totalMatches + 1);
    } else {
      partnershipWinRate[partnerName] =
          (currentWins * totalMatches) / (totalMatches + 1);
    }
  }

  int get totalMatches => wins + losses + draws;
}
import 'package:cloud_firestore/cloud_firestore.dart';

enum MatchOutcome {
  win,
  loss,
  draw;

  bool get isWin => this == MatchOutcome.win;
  bool get isLoss => this == MatchOutcome.loss;
  bool get isDraw => this == MatchOutcome.draw;

  String toDisplayString() {
    switch (this) {
      case MatchOutcome.win:
        return 'Win';
      case MatchOutcome.loss:
        return 'Loss';
      case MatchOutcome.draw:
        return 'Draw';
    }
  }
}

class MatchResult {
  final String matchId;
  final DateTime date;
  final MatchOutcome outcome;
  final int setsWon;
  final int setsLost;
  final int gamesWon;
  final int gamesLost;
  final bool hasPerfectSet;
  final String opponent;
  final double ratingChange;

  const MatchResult({
    required this.matchId,
    required this.date,
    required this.outcome,
    required this.setsWon,
    required this.setsLost,
    required this.gamesWon,
    required this.gamesLost,
    this.hasPerfectSet = false,
    required this.opponent,
    this.ratingChange = 0.0,
  });

  bool get isWin => outcome == MatchOutcome.win;
  bool get isLoss => outcome == MatchOutcome.loss;
  bool get isDraw => outcome == MatchOutcome.draw;

  int get totalGames => gamesWon + gamesLost;
  int get gamesDifference => gamesWon - gamesLost;
  int get setsDifference => setsWon - setsLost;

  double get winPercentage {
    if (totalGames == 0) return 0;
    return (gamesWon / totalGames) * 100;
  }

  Map<String, dynamic> toMap() {
    return {
      'matchId': matchId,
      'date': Timestamp.fromDate(date),
      'outcome': outcome.toString(),
      'setsWon': setsWon,
      'setsLost': setsLost,
      'gamesWon': gamesWon,
      'gamesLost': gamesLost,
      'hasPerfectSet': hasPerfectSet,
      'opponent': opponent,
      'ratingChange': ratingChange,
    };
  }

  factory MatchResult.fromMap(Map<String, dynamic> map) {
    return MatchResult(
      matchId: map['matchId'] as String,
      date: (map['date'] as Timestamp).toDate(),
      outcome: MatchOutcome.values.firstWhere(
        (e) => e.toString() == map['outcome'],
        orElse: () => MatchOutcome.loss,
      ),
      setsWon: (map['setsWon'] as num).toInt(),
      setsLost: (map['setsLost'] as num).toInt(),
      gamesWon: (map['gamesWon'] as num).toInt(),
      gamesLost: (map['gamesLost'] as num).toInt(),
      hasPerfectSet: map['hasPerfectSet'] as bool? ?? false,
      opponent: map['opponent'] as String,
      ratingChange: (map['ratingChange'] as num?)?.toDouble() ?? 0.0,
    );
  }

  static MatchResult createFromScore({
    required String matchId,
    required int team1Sets,
    required int team2Sets,
    required List<int> team1Games,
    required List<int> team2Games,
    required String opponent,
    double ratingChange = 0.0,
  }) {
    final now = DateTime.now();
    final setsWon = team1Sets;
    final setsLost = team2Sets;
    final gamesWon = team1Games.fold<int>(0, (total, game) => total + game);
    final gamesLost = team2Games.fold<int>(0, (total, game) => total + game);

    MatchOutcome outcome;
    if (team1Sets > team2Sets) {
      outcome = MatchOutcome.win;
    } else if (team1Sets < team2Sets) {
      outcome = MatchOutcome.loss;
    } else {
      outcome = MatchOutcome.draw;
    }

    final hasPerfectSet = team1Games.contains(6) && team2Games.contains(0);

    return MatchResult(
      matchId: matchId,
      date: now,
      outcome: outcome,
      setsWon: setsWon,
      setsLost: setsLost,
      gamesWon: gamesWon,
      gamesLost: gamesLost,
      hasPerfectSet: hasPerfectSet,
      opponent: opponent,
      ratingChange: ratingChange,
    );
  }
}
import 'package:flutter/material.dart';

enum AchievementType {
  winStreak, // Win streak achievement
  firstWin, // First victory
  perfectSet, // Won a set 6-0
  comeback, // Won after losing first set
  tournament, // Tournament victory
  undefeatedStreak, // Maintained undefeated streak
  cleanSweep, // Won all matches in tournament
  giantKiller, // Beat a higher ranked player
  rapidRiser, // Quick improvement in ranking
  ironMan, // Many matches in short time
  popularPlayer, // Played with different partners
  clutchPlayer, // Won close matches
  dominantDisplay, // Big score differences
  seasonChampion, // Top of the league
  monthlyMVP, // Best player of the month
  rookieOfTheYear, // Best new player
  improvedRating, // Rating milestone
  consistentPlayer // Regular player
}

enum AchievementRarity {
  common,
  uncommon,
  rare,
  epic,
  legendary;

  Color get color {
    switch (this) {
      case AchievementRarity.common:
        return Colors.grey;
      case AchievementRarity.uncommon:
        return Colors.green;
      case AchievementRarity.rare:
        return Colors.blue;
      case AchievementRarity.epic:
        return Colors.purple;
      case AchievementRarity.legendary:
        return Colors.orange;
    }
  }

  String get label {
    switch (this) {
      case AchievementRarity.common:
        return 'Common';
      case AchievementRarity.uncommon:
        return 'Uncommon';
      case AchievementRarity.rare:
        return 'Rare';
      case AchievementRarity.epic:
        return 'Epic';
      case AchievementRarity.legendary:
        return 'Legendary';
    }
  }
}

class Achievement {
  final String id;
  final String title;
  final String description;
  final AchievementType type;
  final AchievementRarity rarity;
  final DateTime dateEarned;
  final int? progress;
  final int? target;
  final String? icon;

  const Achievement({
    required this.id,
    required this.title,
    required this.description,
    required this.type,
    required this.rarity,
    required this.dateEarned,
    this.progress,
    this.target,
    this.icon,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'type': type.toString(),
      'rarity': rarity.toString(),
      'dateEarned': dateEarned.toIso8601String(),
      'progress': progress,
      'target': target,
      'icon': icon,
    };
  }

  factory Achievement.fromMap(Map<String, dynamic> map) {
    return Achievement(
      id: map['id'] as String,
      title: map['title'] as String,
      description: map['description'] as String,
      type: AchievementType.values.firstWhere(
        (e) => e.toString() == map['type'],
        orElse: () => AchievementType.firstWin,
      ),
      rarity: AchievementRarity.values.firstWhere(
        (e) => e.toString() == map['rarity'],
        orElse: () => AchievementRarity.common,
      ),
      dateEarned: DateTime.parse(map['dateEarned'] as String),
      progress: map['progress'] as int?,
      target: map['target'] as int?,
      icon: map['icon'] as String?,
    );
  }

  static Achievement createAchievement({
    required AchievementType type,
    int? value,
    int? target,
  }) {
    final achievementData = _getAchievementData(type, value, target);
    return Achievement(
      id: '${type.toString()}_${DateTime.now().millisecondsSinceEpoch}',
      title: achievementData.title,
      description: achievementData.description,
      type: type,
      rarity: achievementData.rarity,
      dateEarned: DateTime.now(),
      progress: value,
      target: target,
      icon: achievementData.icon,
    );
  }

  static AchievementData _getAchievementData(
    AchievementType type,
    int? value,
    int? target,
  ) {
    switch (type) {
      case AchievementType.winStreak:
        return AchievementData(
          title: '${value ?? 5} Win Streak!',
          description: 'Won ${value ?? 5} matches in a row',
          rarity: value != null && value >= 10
              ? AchievementRarity.legendary
              : AchievementRarity.rare,
          icon: 'trophy',
        );

      case AchievementType.firstWin:
        return const AchievementData(
          title: 'First Victory',
          description: 'Won your first match',
          rarity: AchievementRarity.common,
          icon: 'star',
        );

      case AchievementType.perfectSet:
        return const AchievementData(
          title: 'Perfect Set',
          description: 'Won a set 6-0',
          rarity: AchievementRarity.rare,
          icon: 'crown',
        );

      case AchievementType.tournament:
        return const AchievementData(
          title: 'Tournament Champion',
          description: 'Won a tournament',
          rarity: AchievementRarity.legendary,
          icon: 'trophy',
        );

      case AchievementType.consistentPlayer:
        return AchievementData(
          title: 'Consistent Player',
          description: 'Played ${value ?? 10} matches in a month',
          rarity: AchievementRarity.uncommon,
          icon: 'calendar',
        );

      case AchievementType.monthlyMVP:
        return const AchievementData(
          title: 'Monthly MVP',
          description: 'Best performing player of the month',
          rarity: AchievementRarity.epic,
          icon: 'medal',
        );

      default:
        return AchievementData(
          title: type.toString().split('.').last,
          description: 'Achievement unlocked!',
          rarity: AchievementRarity.common,
          icon: 'star',
        );
    }
  }

  bool get isCompleted =>
      progress != null && target != null && progress! >= target!;

  double get progressPercentage {
    if (progress == null || target == null) return 1.0;
    return progress! / target!;
  }

  String get formattedDate {
    return '${dateEarned.day}/${dateEarned.month}/${dateEarned.year}';
  }

  bool get isRecent {
    final now = DateTime.now();
    return dateEarned.isAfter(now.subtract(const Duration(days: 7)));
  }

  IconData getIconData() {
    switch (icon) {
      case 'trophy':
        return Icons.emoji_events;
      case 'star':
        return Icons.star;
      case 'crown':
        return Icons.workspace_premium;
      case 'medal':
        return Icons.military_tech;
      case 'calendar':
        return Icons.calendar_today;
      default:
        return Icons.emoji_events;
    }
  }
}

class AchievementData {
  final String title;
  final String description;
  final AchievementRarity rarity;
  final String icon;

  const AchievementData({
    required this.title,
    required this.description,
    required this.rarity,
    required this.icon,
  });
}

// Example usage:
class AchievementService {
  static bool checkForAchievements(
    int wins,
    int streak,
    int matchesThisMonth,
    double rating,
    bool wonTournament,
  ) {
    List<Achievement> newAchievements = [];

    // Check win streak
    if (streak >= 5) {
      newAchievements.add(Achievement.createAchievement(
        type: AchievementType.winStreak,
        value: streak,
      ));
    }

    // Check first win
    if (wins == 1) {
      newAchievements.add(Achievement.createAchievement(
        type: AchievementType.firstWin,
      ));
    }

    // Check consistent player
    if (matchesThisMonth >= 10) {
      newAchievements.add(Achievement.createAchievement(
        type: AchievementType.consistentPlayer,
        value: matchesThisMonth,
      ));
    }

    // Check tournament win
    if (wonTournament) {
      newAchievements.add(Achievement.createAchievement(
        type: AchievementType.tournament,
      ));
    }

    return newAchievements.isNotEmpty;
  }
}
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'statistics/player_statistics.dart';
import 'player_avatar.dart';
import 'match/match_result.dart';

class Player {
  final String id;
  final String name;
  final double rating;
  final int rank;
  final String profileImage;
  final DateTime createdAt;
  Map<String, String> signedTimeslots;
  final PlayerStatistics statistics;

  Player({
    required this.id,
    required this.name,
    required this.rating,
    required this.rank,
    required this.profileImage,
    required this.createdAt,
    Map<String, String>? signedTimeslots,
    PlayerStatistics? statistics,
  })  : signedTimeslots = signedTimeslots ?? {},
        statistics = statistics ?? PlayerStatistics();

  // Add the unknown factory constructor
  factory Player.unknown() {
    return Player(
      id: 'unknown',
      name: 'Unknown Player',
      rating: 0,
      rank: 0,
      profileImage: 'assets/images/profile.png',
      createdAt: DateTime.now(),
      signedTimeslots: {},
      statistics: PlayerStatistics(),
    );
  }

  factory Player.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;

    // Safely extract Timestamp
    DateTime createdAtDate;
    try {
      createdAtDate =
          (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now();
    } catch (e) {
      debugPrint('Error converting timestamp: $e');
      createdAtDate = DateTime.now();
    }

    // Safely extract signedTimeslots
    Map<String, String> timeslots = {};
    try {
      if (data['signedTimeslots'] != null) {
        final slots = data['signedTimeslots'] as Map<dynamic, dynamic>;
        timeslots = Map<String, String>.from(slots.map(
          (key, value) => MapEntry(key.toString(), value.toString()),
        ));
      }
    } catch (e) {
      debugPrint('Error converting signedTimeslots: $e');
    }

    // Extract statistics
    PlayerStatistics stats;
    try {
      stats =
          PlayerStatistics.fromMap(data['statistics'] as Map<String, dynamic>?);
    } catch (e) {
      debugPrint('Error converting statistics: $e');
      stats = PlayerStatistics();
    }

    return Player(
      id: doc.id,
      name: data['name']?.toString() ?? 'Unknown Player',
      rating: (data['rating'] as num?)?.toDouble() ?? 0.0,
      rank: (data['rank'] as num?)?.toInt() ?? 0,
      profileImage:
          data['profileImage']?.toString() ?? 'assets/images/profile.png',
      createdAt: createdAtDate,
      signedTimeslots: timeslots,
      statistics: stats,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'rating': rating,
      'rank': rank,
      'profileImage': profileImage,
      'createdAt': Timestamp.fromDate(createdAt),
      'signedTimeslots': signedTimeslots,
      'statistics': statistics.toMap(),
    };
  }

  void updateMatchStats(MatchResult result) {
    statistics.updateStats(result);
  }

  void signForTimeslot(String day, String timeslot) {
    debugPrint('Signing $name for $timeslot on $day');
    signedTimeslots[day] = timeslot;
  }

  bool isPlayEither(String day) {
    return signedTimeslots[day] == 'Play Either';
  }

  Widget avatar({double size = 60}) {
    return PlayerAvatar(player: this, size: size);
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';
import 'player.dart';
import 'package:flutter/foundation.dart';

enum MatchStatus { scheduled, inProgress, completed, cancelled }

class Score {
  int sets;
  List<int> games;

  Score({
    this.sets = 0,
    List<int>? games,
  }) : games = games ?? [];

  Map<String, dynamic> toMap() {
    return {
      'sets': sets,
      'games': games,
    };
  }

  factory Score.fromMap(Map<String, dynamic> map) {
    return Score(
      sets: (map['sets'] as num?)?.toInt() ?? 0,
      games: (map['games'] as List<dynamic>?)
              ?.map((e) => (e as num).toInt())
              .toList() ??
          [],
    );
  }

  Score copyWith({
    int? sets,
    List<int>? games,
  }) {
    return Score(
      sets: sets ?? this.sets,
      games: games ?? List<int>.from(this.games),
    );
  }
}

class Match {
  final String id;
  final DateTime date;
  final String time;
  final MatchStatus status;
  final Map<String, Player> players;
  final Map<String, Score> score;
  final DateTime createdAt;

  Match({
    required this.id,
    required this.date,
    required this.time,
    required this.status,
    required this.players,
    required this.score,
    required this.createdAt,
  });

  // Getters for team players and scores
  Player? get team1Player1 => players['team1_player1'];
  Player? get team1Player2 => players['team1_player2'];
  Player? get team2Player1 => players['team2_player1'];
  Player? get team2Player2 => players['team2_player2'];

  Score? get team1Score => score['team1'];
  Score? get team2Score => score['team2'];

  bool get isComplete => status == MatchStatus.completed;

  String? get winner {
    if (!isComplete) return null;
    final team1Sets = team1Score?.sets ?? 0;
    final team2Sets = team2Score?.sets ?? 0;
    if (team1Sets > team2Sets) return 'team1';
    if (team2Sets > team1Sets) return 'team2';
    return null;
  }

  factory Match.fromFirestore(DocumentSnapshot doc, List<Player> allPlayers) {
    final data = doc.data() as Map<String, dynamic>;
    Map<String, Player> matchPlayers = {};

    try {
      final playersData = data['players'] as Map<String, dynamic>;

      // Process team1
      final team1Data = playersData['team1'] as Map<String, dynamic>;
      final player1Ref = team1Data['player1'] as DocumentReference;
      final player2Ref = team1Data['player2'] as DocumentReference;

      // Process team2
      final team2Data = playersData['team2'] as Map<String, dynamic>;
      final player3Ref = team2Data['player1'] as DocumentReference;
      final player4Ref = team2Data['player2'] as DocumentReference;

      // Find players from references
      matchPlayers['team1_player1'] = allPlayers.firstWhere(
        (p) => p.id == player1Ref.id,
        orElse: () => Player.unknown(),
      );
      matchPlayers['team1_player2'] = allPlayers.firstWhere(
        (p) => p.id == player2Ref.id,
        orElse: () => Player.unknown(),
      );
      matchPlayers['team2_player1'] = allPlayers.firstWhere(
        (p) => p.id == player3Ref.id,
        orElse: () => Player.unknown(),
      );
      matchPlayers['team2_player2'] = allPlayers.firstWhere(
        (p) => p.id == player4Ref.id,
        orElse: () => Player.unknown(),
      );
    } catch (e) {
      debugPrint('Error processing players in Match.fromFirestore: $e');
    }

    return Match(
      id: data['id'] as String? ?? doc.id,
      date: (data['date'] as Timestamp?)?.toDate() ?? DateTime.now(),
      time: data['time'] as String? ?? 'Later Timeslot',
      status: MatchStatus.values.firstWhere(
        (e) => e.toString().split('.').last == data['status'],
        orElse: () => MatchStatus.scheduled,
      ),
      players: matchPlayers,
      score: {
        'team1': Score.fromMap(data['score']['team1'] as Map<String, dynamic>),
        'team2': Score.fromMap(data['score']['team2'] as Map<String, dynamic>),
      },
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id, // Ensure correct ID format is retained
      'date': Timestamp.fromDate(date),
      'time': time,
      'status': status.toString().split('.').last,
      'players': {
        'team1': {
          'player1': FirebaseFirestore.instance
              .doc('players/${players['team1_player1']!.id}'),
          'player2': FirebaseFirestore.instance
              .doc('players/${players['team1_player2']!.id}'),
        },
        'team2': {
          'player1': FirebaseFirestore.instance
              .doc('players/${players['team2_player1']!.id}'),
          'player2': FirebaseFirestore.instance
              .doc('players/${players['team2_player2']!.id}'),
        },
      },
      'score': {
        'team1': score['team1']!.toMap(),
        'team2': score['team2']!.toMap(),
      },
      'createdAt': Timestamp.fromDate(createdAt),
    };
  }

  Match copyWith({
    String? id,
    DateTime? date,
    String? time,
    MatchStatus? status,
    Map<String, Player>? players,
    Map<String, Score>? score,
    DateTime? createdAt,
  }) {
    return Match(
      id: id ?? this.id,
      date: date ?? this.date,
      time: time ?? this.time,
      status: status ?? this.status,
      players: players ?? Map<String, Player>.from(this.players),
      score: score ?? Map<String, Score>.from(this.score),
      createdAt: createdAt ?? this.createdAt,
    );
  }
}
// lib/models/game_state.dart

import 'package:flutter/foundation.dart';
import 'player.dart';
import 'match/match_result.dart';

class GameState extends ChangeNotifier {
  List<Player> players = [];
  List<Map<String, dynamic>> matches = [];

  // Update match score
  void updateMatchScore(
    String matchId,
    String playerKey,
    String scoreType,
    int value,
  ) {
    final matchIndex = int.tryParse(matchId);
    if (matchIndex == null || matchIndex >= matches.length) return;

    var match = matches[matchIndex];
    var scores = match['score'] as Map<String, dynamic>?;
    if (scores == null) return;

    var playerScore = scores[playerKey] as Map<String, dynamic>?;
    if (playerScore == null) return;

    if (playerScore[scoreType] != null) {
      playerScore[scoreType] = value;
      _updatePlayerStats(match, playerKey);
      notifyListeners();
    }
  }

  // Update player stats after a match
  void _updatePlayerStats(Map<String, dynamic> match, String playerKey) {
    try {
      // Safely get player data
      final playerData = match[playerKey] as Map<String, dynamic>?;
      final playerName = playerData?['name'] as String?;
      if (playerName == null) return;

      // Find player
      final player = players.firstWhere(
        (p) => p.name == playerName,
        orElse: () => throw Exception('Player not found'),
      );

      // Safely extract scores
      final scores = match['score'] as Map<String, dynamic>?;
      final playerScore = scores?[playerKey] as Map<String, dynamic>?;
      final opponentKey = playerKey == 'team1' ? 'team2' : 'team1';
      final opponentScore = scores?[opponentKey] as Map<String, dynamic>?;

      if (playerScore == null || opponentScore == null) return;

      // Calculate stats
      final setsWon = playerScore['sets'] as int? ?? 0;
      final setsLost = opponentScore['sets'] as int? ?? 0;
      final playerGames = playerScore['games'] as List<dynamic>? ?? [];
      final opponentGames = opponentScore['games'] as List<dynamic>? ?? [];
      final totalGamesWon =
          playerGames.fold<int>(0, (sum, game) => sum + (game as int? ?? 0));
      final totalGamesLost =
          opponentGames.fold<int>(0, (sum, game) => sum + (game as int? ?? 0));

      // Determine match outcome
      final outcome = setsWon > setsLost
          ? MatchOutcome.win
          : setsWon < setsLost
              ? MatchOutcome.loss
              : MatchOutcome.draw;

      // Check for perfect set
      final hasPerfectSet =
          playerGames.contains(6) && opponentGames.contains(0);

      // Get opponent name
      final opponentData = match[opponentKey] as Map<String, dynamic>?;
      final opponentName = opponentData?['name'] as String? ?? 'Unknown';

      // Create match result
      final result = MatchResult(
        matchId: match['id']?.toString() ?? DateTime.now().toString(),
        date: DateTime.now(),
        outcome: outcome,
        setsWon: setsWon,
        setsLost: setsLost,
        gamesWon: totalGamesWon,
        gamesLost: totalGamesLost,
        hasPerfectSet: hasPerfectSet,
        opponent: opponentName,
      );

      // Update player stats
      player.updateMatchStats(result);
      notifyListeners();
    } catch (e) {
      debugPrint('Error updating player stats: $e');
    }
  }

  // Get matches for a specific player
  List<Map<String, dynamic>> getMatchesForPlayer(String playerId) {
    return matches.where((match) {
      // Safely convert team1Players and team2Players to List<String>
      final team1Players = (match['team1Players'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          [];
      final team2Players = (match['team2Players'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          [];
      return team1Players.contains(playerId) || team2Players.contains(playerId);
    }).toList();
  }

  // Get player's team key in a match
  String? _getPlayerTeamKey(Map<String, dynamic> match, String playerId) {
    final team1Players = (match['team1Players'] as List<dynamic>?)
            ?.map((e) => e.toString())
            .toList() ??
        [];
    if (team1Players.contains(playerId)) return 'team1';

    final team2Players = (match['team2Players'] as List<dynamic>?)
            ?.map((e) => e.toString())
            .toList() ??
        [];
    if (team2Players.contains(playerId)) return 'team2';

    return null;
  }

  // Get recent matches for a player
  List<Map<String, dynamic>> getRecentMatches(String playerId,
      {int limit = 5}) {
    final playerMatches = getMatchesForPlayer(playerId);
    playerMatches.sort((a, b) {
      final dateA =
          DateTime.tryParse(a['date']?.toString() ?? '') ?? DateTime.now();
      final dateB =
          DateTime.tryParse(b['date']?.toString() ?? '') ?? DateTime.now();
      return dateB.compareTo(dateA);
    });
    return playerMatches.take(limit).toList();
  }

  // Additional utility methods
  void addMatch(Map<String, dynamic> match) {
    matches.add(match);
    notifyListeners();
  }

  Map<String, dynamic>? getMatch(int index) {
    if (index >= 0 && index < matches.length) {
      return matches[index];
    }
    return null;
  }

  void clearMatches() {
    matches.clear();
    notifyListeners();
  }

  void addPlayer(Player player) {
    if (!players.any((p) => p.id == player.id)) {
      players.add(player);
      notifyListeners();
    }
  }

  void removePlayer(String playerId) {
    players.removeWhere((p) => p.id == playerId);
    notifyListeners();
  }

  Player? getPlayerById(String id) {
    try {
      return players.firstWhere((p) => p.id == id);
    } catch (_) {
      return null;
    }
  }

  void updatePlayer(Player updatedPlayer) {
    final index = players.indexWhere((p) => p.id == updatedPlayer.id);
    if (index != -1) {
      players[index] = updatedPlayer;
      notifyListeners();
    }
  }

  List<Player> getPlayersByRank() {
    final sortedPlayers = List<Player>.from(players);
    sortedPlayers.sort((a, b) => b.rating.compareTo(a.rating));
    return sortedPlayers;
  }

  double getPlayerWinRate(String playerId) {
    final playerMatches = getMatchesForPlayer(playerId);
    if (playerMatches.isEmpty) return 0.0;

    final wins = playerMatches.where((match) {
      final playerKey = _getPlayerTeamKey(match, playerId);
      if (playerKey == null) return false;

      final scores = match['score'] as Map<String, dynamic>?;
      if (scores == null) return false;

      final playerScore = scores[playerKey]['sets'] as int? ?? 0;
      final opponentScore =
          scores[playerKey == 'team1' ? 'team2' : 'team1']['sets'] as int? ?? 0;
      return playerScore > opponentScore;
    }).length;

    return (wins / playerMatches.length) * 100;
  }
}
import 'package:flutter/material.dart';
import 'player.dart';

class PlayerAvatar extends StatelessWidget {
  final Player player;
  final double size;

  const PlayerAvatar({
    Key? key,
    required this.player,
    this.size = 60,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(
          color: _getBorderColor(),
          width: size / 30,
        ),
      ),
      child: ClipOval(
        child: Image.asset(
          player.profileImage,
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) {
            debugPrint('Error loading player image: $error');
            return Container(
              color: Colors.grey[200],
              child: Icon(
                Icons.person,
                size: size * 0.6,
                color: Colors.grey[400],
              ),
            );
          },
        ),
      ),
    );
  }

  Color _getBorderColor() {
    if (player.rank >= 0 && player.rank < 15) {
      return Colors.blue[900]!;
    } else if (player.rank >= 15 && player.rank < 30) {
      return Colors.blue[300]!;
    } else if (player.rank >= 30 && player.rank < 50) {
      return Colors.yellow;
    } else if (player.rank >= 50 && player.rank < 70) {
      return Colors.green;
    } else if (player.rank >= 70 && player.rank < 90) {
      return Colors.orange;
    } else {
      return Colors.red;
    }
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'match/match_result.dart';
import 'match/achievement.dart';

class MatchStatistics {
  int wins;
  int losses;
  int draws;
  int setsWon;
  int setsLost;
  int gamesWon;
  int gamesLost;
  List<String> recentMatches;
  List<MatchResult> recentResults;
  double winRate;
  double rating;
  int currentStreak;
  List<double> last10MatchesRating;
  Map<String, int> partnershipMatches;
  Map<String, double> partnershipWinRate;
  List<Achievement> achievements;
  DateTime lastMatchDate;

  // Getters
  int get totalMatches => wins + losses + draws;
  double get gamesWinRate => gamesWon + gamesLost > 0
      ? (gamesWon / (gamesWon + gamesLost)) * 100
      : 0.0;
  double get setsWinRate =>
      setsWon + setsLost > 0 ? (setsWon / (setsWon + setsLost)) * 100 : 0.0;
  bool get hasPlayed => totalMatches > 0;

  MatchStatistics({
    this.wins = 0,
    this.losses = 0,
    this.draws = 0,
    this.setsWon = 0,
    this.setsLost = 0,
    this.gamesWon = 0,
    this.gamesLost = 0,
    List<String>? recentMatches,
    List<MatchResult>? recentResults,
    this.winRate = 0.0,
    this.rating = 0.0,
    this.currentStreak = 0,
    List<double>? last10MatchesRating,
    Map<String, int>? partnershipMatches,
    Map<String, double>? partnershipWinRate,
    List<Achievement>? achievements,
    DateTime? lastMatchDate,
  })  : recentMatches = recentMatches ?? [],
        recentResults = recentResults ?? [],
        last10MatchesRating = last10MatchesRating ?? [],
        partnershipMatches = partnershipMatches ?? {},
        partnershipWinRate = partnershipWinRate ?? {},
        achievements = achievements ?? [],
        lastMatchDate = lastMatchDate ?? DateTime.now();

  Map<String, dynamic> toMap() {
    try {
      return {
        'wins': wins,
        'losses': losses,
        'draws': draws,
        'setsWon': setsWon,
        'setsLost': setsLost,
        'gamesWon': gamesWon,
        'gamesLost': gamesLost,
        'recentMatches': recentMatches,
        'recentResults': recentResults.map((r) => r.toMap()).toList(),
        'winRate': winRate,
        'rating': rating,
        'currentStreak': currentStreak,
        'last10MatchesRating': last10MatchesRating,
        'partnershipMatches': partnershipMatches,
        'partnershipWinRate': partnershipWinRate,
        'achievements': achievements.map((a) => a.toMap()).toList(),
        'lastMatchDate': Timestamp.fromDate(lastMatchDate),
      };
    } catch (e) {
      debugPrint('Error converting MatchStatistics to map: $e');
      rethrow;
    }
  }

  factory MatchStatistics.fromMap(Map<String, dynamic>? map) {
    if (map == null) return MatchStatistics();

    try {
      // Handle recent matches
      List<String> recentMatchesList = [];
      if (map['recentMatches'] != null) {
        recentMatchesList =
            List<String>.from(map['recentMatches'] as List<dynamic>);
      }

      // Handle recent results
      List<MatchResult> recentResultsList = [];
      if (map['recentResults'] != null) {
        recentResultsList = (map['recentResults'] as List<dynamic>)
            .map((e) => MatchResult.fromMap(e as Map<String, dynamic>))
            .toList();
      }

      // Handle ratings history
      List<double> ratingHistory = [];
      if (map['last10MatchesRating'] != null) {
        ratingHistory = (map['last10MatchesRating'] as List<dynamic>)
            .map((e) => (e as num).toDouble())
            .toList();
      }

      // Handle partnership matches
      Map<String, int> partnershipMatchesMap = {};
      if (map['partnershipMatches'] != null) {
        partnershipMatchesMap =
            (map['partnershipMatches'] as Map<String, dynamic>).map(
          (key, value) => MapEntry(key, (value as num).toInt()),
        );
      }

      // Handle partnership win rates
      Map<String, double> partnershipWinRateMap = {};
      if (map['partnershipWinRate'] != null) {
        partnershipWinRateMap =
            (map['partnershipWinRate'] as Map<String, dynamic>).map(
          (key, value) => MapEntry(key, (value as num).toDouble()),
        );
      }

      // Handle achievements
      List<Achievement> achievementsList = [];
      if (map['achievements'] != null) {
        achievementsList = (map['achievements'] as List<dynamic>)
            .map((e) => Achievement.fromMap(e as Map<String, dynamic>))
            .toList();
      }

      return MatchStatistics(
        wins: (map['wins'] as num?)?.toInt() ?? 0,
        losses: (map['losses'] as num?)?.toInt() ?? 0,
        draws: (map['draws'] as num?)?.toInt() ?? 0,
        setsWon: (map['setsWon'] as num?)?.toInt() ?? 0,
        setsLost: (map['setsLost'] as num?)?.toInt() ?? 0,
        gamesWon: (map['gamesWon'] as num?)?.toInt() ?? 0,
        gamesLost: (map['gamesLost'] as num?)?.toInt() ?? 0,
        recentMatches: recentMatchesList,
        recentResults: recentResultsList,
        winRate: (map['winRate'] as num?)?.toDouble() ?? 0.0,
        rating: (map['rating'] as num?)?.toDouble() ?? 0.0,
        currentStreak: (map['currentStreak'] as num?)?.toInt() ?? 0,
        last10MatchesRating: ratingHistory,
        partnershipMatches: partnershipMatchesMap,
        partnershipWinRate: partnershipWinRateMap,
        achievements: achievementsList,
        lastMatchDate:
            (map['lastMatchDate'] as Timestamp?)?.toDate() ?? DateTime.now(),
      );
    } catch (e) {
      debugPrint('Error creating MatchStatistics from map: $e');
      return MatchStatistics(); // Return default statistics on error
    }
  }

  void updateStats(MatchResult result) {
    try {
      // Update wins/losses/draws
      if (result.isWin) {
        wins++;
        currentStreak = currentStreak > 0 ? currentStreak + 1 : 1;
        recentMatches.insert(0, 'W');
      } else if (result.isDraw) {
        draws++;
        currentStreak = 0;
        recentMatches.insert(0, 'D');
      } else {
        losses++;
        currentStreak = currentStreak < 0 ? currentStreak - 1 : -1;
        recentMatches.insert(0, 'L');
      }

      // Keep only last 5 recent matches
      if (recentMatches.length > 5) {
        recentMatches = recentMatches.sublist(0, 5);
      }

      // Update match stats
      setsWon += result.setsWon;
      setsLost += result.setsLost;
      gamesWon += result.gamesWon;
      gamesLost += result.gamesLost;

      // Update win rate
      winRate = totalMatches > 0 ? (wins / totalMatches) * 100 : 0;

      // Update rating with change
      rating += result.ratingChange;

      // Add to recent results
      recentResults.insert(0, result);
      if (recentResults.length > 10) {
        recentResults = recentResults.sublist(0, 10);
      }

      // Update last match date
      lastMatchDate = DateTime.now();

      // Track rating history
      last10MatchesRating.insert(0, rating);
      if (last10MatchesRating.length > 10) {
        last10MatchesRating = last10MatchesRating.sublist(0, 10);
      }

      // Check for achievements
      _checkForAchievements(result);
    } catch (e) {
      debugPrint('Error updating statistics: $e');
      rethrow;
    }
  }

  void updatePartnershipStats(String partnerName, bool isWin) {
    try {
      partnershipMatches.update(
        partnerName,
        (value) => value + 1,
        ifAbsent: () => 1,
      );

      final wins = partnershipWinRate[partnerName] ?? 0;
      final total = partnershipMatches[partnerName] ?? 0;

      if (isWin) {
        partnershipWinRate[partnerName] = ((wins * total) + 100) / (total + 1);
      } else {
        partnershipWinRate[partnerName] = (wins * total) / (total + 1);
      }

      // Check for partnership achievements
      _checkPartnershipAchievements(partnerName);
    } catch (e) {
      debugPrint('Error updating partnership stats: $e');
      rethrow;
    }
  }

  void _checkForAchievements(MatchResult result) {
    // Win streak achievements
    if (currentStreak >= 5) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.winStreak,
        value: currentStreak,
      ));
    }

    // First win achievement
    if (wins == 1) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.firstWin,
      ));
    }

    // Perfect set achievement
    if (result.hasPerfectSet) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.perfectSet,
      ));
    }
  }

  void _checkPartnershipAchievements(String partnerName) {
    final matchesWithPartner = partnershipMatches[partnerName] ?? 0;
    final winRateWithPartner = partnershipWinRate[partnerName] ?? 0.0;

    // Add partnership-based achievements here
    if (matchesWithPartner >= 10 && winRateWithPartner >= 70) {
      achievements.add(Achievement.createAchievement(
        type: AchievementType.popularPlayer,
      ));
    }
  }

  // Helper method to get form string
  String getFormString() {
    return recentMatches.join('-');
  }

  // Helper method to get rating trend
  double getRatingTrend() {
    if (last10MatchesRating.length < 2) return 0;
    return last10MatchesRating.first - last10MatchesRating.last;
  }
}
// lib/models/match_scoring.dart

class MatchScoring {
  final Map<String, SetScore> teamScores = {
    'team1': SetScore(),
    'team2': SetScore(),
  };

  bool isMatchComplete = false;
  String? winner;
}

class SetScore {
  int sets;
  List<int> games;

  SetScore({
    this.sets = 0,
    this.games = const [],
  });

  bool isValidSet(int team1Games, int team2Games) {
    // One team must have at least 6 games
    if (team1Games < 6 && team2Games < 6) return false;

    // Regular set win (6-0 to 6-4)
    if (team1Games == 6 && team2Games <= 4) return true;
    if (team2Games == 6 && team1Games <= 4) return true;

    // 7-5 win
    if (team1Games == 7 && team2Games == 5) return true;
    if (team2Games == 7 && team1Games == 5) return true;

    // 7-6 tiebreak win
    if (team1Games == 7 && team2Games == 6) return true;
    if (team2Games == 7 && team1Games == 6) return true;

    return false;
  }
}
import 'dart:typed_data'; // For handling byte data
import 'package:flutter/foundation.dart'; // For kIsWeb detection
import 'package:image_picker/image_picker.dart'; // Cross-platform Image Picker

class ImagePickerService {
  final ImagePicker _picker = ImagePicker();

  /// Picks an image from the gallery
  Future<Uint8List?> pickImage() async {
    try {
      // Web-specific implementation
      if (kIsWeb) {
        final XFile? image =
            await _picker.pickImage(source: ImageSource.gallery);
        if (image != null) {
          return await image.readAsBytes(); // Returns image as bytes
        }
      } else {
        // Mobile-specific implementation
        final XFile? image = await _picker.pickImage(
          source: ImageSource.gallery,
          maxWidth: 512, // Resize to max width
          maxHeight: 512, // Resize to max height
          imageQuality: 75, // Compress image quality
        );
        if (image != null) {
          return await image.readAsBytes(); // Returns image as bytes
        }
      }
      return null; // No image selected
    } catch (e) {
      debugPrint('Error picking image: $e'); // Log the error
      return null;
    }
  }

  /// Takes a photo using the camera
  Future<Uint8List?> takePhoto() async {
    try {
      // Web-specific implementation (not supported)
      if (kIsWeb) {
        debugPrint('Camera is not supported on the web.'); // Log the message
        return null;
      } else {
        // Mobile-specific implementation
        final XFile? photo = await _picker.pickImage(
          source: ImageSource.camera,
          maxWidth: 512, // Resize to max width
          maxHeight: 512, // Resize to max height
          imageQuality: 75, // Compress image quality
        );
        if (photo != null) {
          return await photo.readAsBytes(); // Returns photo as bytes
        }
      }
      return null; // No photo taken
    } catch (e) {
      debugPrint('Error taking photo: $e'); // Log the error
      return null;
    }
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import '../models/player.dart';
import '../models/match.dart';
import 'data_service_interface.dart';

class FirestoreService implements DataServiceInterface {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  @override
  Stream<List<Player>> getPlayersStream() {
    try {
      debugPrint('Fetching players stream from Firestore');
      return _firestore.collection('players').snapshots().map((snapshot) {
        return snapshot.docs.map((doc) => Player.fromFirestore(doc)).toList();
      });
    } catch (e) {
      debugPrint('Error fetching players stream: $e');
      rethrow;
    }
  }

  @override
  Future<void> createBooking(
      String playerId, String day, String timeslot) async {
    try {
      debugPrint('Creating booking for $playerId on $day at $timeslot');

      final existing = await _firestore
          .collection('bookings')
          .where('playerId', isEqualTo: playerId)
          .where('day', isEqualTo: day)
          .get();

      if (existing.docs.isNotEmpty) {
        await _firestore
            .collection('bookings')
            .doc(existing.docs.first.id)
            .delete();
        debugPrint('Deleted existing booking for player: $playerId');
      }

      await _firestore.collection('bookings').add({
        'playerId': playerId,
        'day': day,
        'timeslot': timeslot,
        'createdAt': FieldValue.serverTimestamp(),
      });

      debugPrint('Booking successfully created for player: $playerId');
    } catch (e) {
      debugPrint('Error creating booking: $e');
      rethrow;
    }
  }

  @override
  Stream<List<Map<String, dynamic>>> getBookingsForDay(String day) {
    debugPrint('Fetching bookings for day: $day');
    return _firestore
        .collection('bookings')
        .where('day', isEqualTo: day)
        .snapshots()
        .map((snapshot) {
      final bookings =
          snapshot.docs.map((doc) => {'id': doc.id, ...doc.data()}).toList();
      debugPrint('Found ${bookings.length} bookings for $day');
      return bookings;
    });
  }

  @override
  Future<void> loadBookingsForPlayer(String playerId) async {
    try {
      debugPrint('Loading bookings for player: $playerId');
      final querySnapshot = await _firestore
          .collection('bookings')
          .where('playerId', isEqualTo: playerId)
          .get();

      if (querySnapshot.docs.isEmpty) {
        debugPrint('No bookings found for player: $playerId');
      } else {
        debugPrint(
            'Found ${querySnapshot.docs.length} bookings for player: $playerId');
        for (var doc in querySnapshot.docs) {
          debugPrint('Booking: ${doc.data()}');
        }
      }
    } catch (e) {
      debugPrint('Error loading bookings for player: $e');
      rethrow;
    }
  }

  @override
  Future<void> deletePlayerBookings(String playerId) async {
    try {
      debugPrint('Deleting all bookings for player: $playerId');
      final snapshot = await _firestore
          .collection('bookings')
          .where('playerId', isEqualTo: playerId)
          .get();

      final batch = _firestore.batch();
      for (var doc in snapshot.docs) {
        batch.delete(doc.reference);
      }
      await batch.commit();
      debugPrint('Deleted all bookings for player: $playerId');
    } catch (e) {
      debugPrint('Error deleting bookings: $e');
      rethrow;
    }
  }

  @override
  Future<List<Player>> getAllPlayers() async {
    try {
      debugPrint('Fetching all players');
      final snapshot = await _firestore.collection('players').get();
      return snapshot.docs.map((doc) => Player.fromFirestore(doc)).toList();
    } catch (e) {
      debugPrint('Error fetching all players: $e');
      rethrow;
    }
  }

  @override
  Future<void> createMatch({
    required DateTime date,
    required String time,
    required List<String> team1PlayerIds,
    required List<String> team2PlayerIds,
  }) async {
    try {
      debugPrint('Creating match');

      final formattedDate = date.toIso8601String().split('T')[0];
      final matchId = 'match_${formattedDate}_${time.replaceAll(' ', '_')}';

      final matchData = {
        'id': matchId,
        'createdAt': FieldValue.serverTimestamp(),
        'date': Timestamp.fromDate(date),
        'time': time,
        'status': 'scheduled',
        'players': {
          'team1': {
            'player1': _firestore.doc('players/${team1PlayerIds[0]}'),
            'player2': _firestore.doc('players/${team1PlayerIds[1]}'),
          },
          'team2': {
            'player1': _firestore.doc('players/${team2PlayerIds[0]}'),
            'player2': _firestore.doc('players/${team2PlayerIds[1]}'),
          },
        },
        'score': {
          'team1': {'sets': 0, 'games': []},
          'team2': {'sets': 0, 'games': []},
        },
      };

      await _firestore.collection('matches').doc(matchId).set(matchData);
      debugPrint('Match successfully created with ID: $matchId');
    } catch (e) {
      debugPrint('Error creating match: $e');
      rethrow;
    }
  }

  @override
  Stream<List<Match>> getMatchesStream() {
    try {
      debugPrint('Fetching matches stream');
      return _firestore
          .collection('matches')
          .snapshots()
          .asyncMap((snapshot) async {
        final players = await getAllPlayers();
        return snapshot.docs
            .map((doc) => Match.fromFirestore(doc, players))
            .toList();
      });
    } catch (e) {
      debugPrint('Error fetching matches stream: $e');
      rethrow;
    }
  }

  @override
  Future<List<Match>> getAllMatches() async {
    try {
      debugPrint('Fetching all matches');
      final snapshot = await _firestore.collection('matches').get();
      final players = await getAllPlayers();
      return snapshot.docs
          .map((doc) => Match.fromFirestore(doc, players))
          .toList();
    } catch (e) {
      debugPrint('Error fetching all matches: $e');
      rethrow;
    }
  }

  @override
  Future<void> updateMatchScore(
      String matchId, String team, String type, dynamic value) async {
    try {
      debugPrint('Updating score for match $matchId: $team.$type = $value');

      final matchRef = _firestore.collection('matches').doc(matchId);
      final matchDoc = await matchRef.get();

      if (!matchDoc.exists) {
        debugPrint('Match not found with ID: $matchId');
        throw Exception('Match not found');
      }

      await matchRef.update({'score.$team.$type': value});
      debugPrint('Score successfully updated for match: $matchId');
    } catch (e) {
      debugPrint('Error updating match score: $e');
      rethrow;
    }
  }

  @override
  Future<void> updateMatchStatus(String matchId, MatchStatus status) async {
    try {
      debugPrint('Updating status for match $matchId to ${status.toString()}');
      await _firestore.collection('matches').doc(matchId).update({
        'status': status.toString().split('.').last,
      });
      debugPrint('Status successfully updated for match: $matchId');
    } catch (e) {
      debugPrint('Error updating match status: $e');
      rethrow;
    }
  }
}
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/match.dart';
import 'package:flutter/foundation.dart';

class StatisticsService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Updates match statistics for all players in the match
  Future<void> updateMatchStatistics(Match match) async {
    if (match.status != MatchStatus.completed) return;

    try {
      debugPrint('Updating statistics for match: ${match.id}');

      // Create a batch for atomic updates
      final batch = _firestore.batch();

      if (match.team1Player1 != null) {
        await _updatePlayerStatsInBatch(
            batch, match.team1Player1!.id, match, 'team1');
      }
      if (match.team1Player2 != null) {
        await _updatePlayerStatsInBatch(
            batch, match.team1Player2!.id, match, 'team1');
      }
      if (match.team2Player1 != null) {
        await _updatePlayerStatsInBatch(
            batch, match.team2Player1!.id, match, 'team2');
      }
      if (match.team2Player2 != null) {
        await _updatePlayerStatsInBatch(
            batch, match.team2Player2!.id, match, 'team2');
      }

      // Commit all updates in the batch
      await batch.commit();
      debugPrint('Successfully updated statistics for match: ${match.id}');
    } catch (e) {
      debugPrint('Error updating match statistics: $e');
      // Check for permission issues
      if (e.toString().contains('permission-denied')) {
        debugPrint('Permission denied: Check Firestore security rules.');
      }
      rethrow;
    }
  }

  /// Updates player statistics within a batch
  Future<void> _updatePlayerStatsInBatch(
    WriteBatch batch,
    String playerId,
    Match match,
    String team,
  ) async {
    final playerRef = _firestore.collection('players').doc(playerId);
    final playerDoc = await playerRef.get();

    if (!playerDoc.exists) {
      debugPrint('Player document not found: $playerId');
      return;
    }

    Map<String, dynamic> data = playerDoc.data() ?? {};
    Map<String, dynamic> stats =
        (data['statistics'] as Map<String, dynamic>?) ?? {};
    final String opposingTeam = team == 'team1' ? 'team2' : 'team1';

    // Calculate game totals
    List<int> playerGames = List<int>.from(match.score[team]?.games ?? []);
    List<int> opponentGames =
        List<int>.from(match.score[opposingTeam]?.games ?? []);

    int gamesWonTotal = playerGames.fold(0, (sum, game) => sum + game);
    int gamesLostTotal = opponentGames.fold(0, (sum, game) => sum + game);

    // Update basic stats
    String? matchWinner = match.winner;
    bool isWinner = matchWinner == team;

    stats['wins'] = (stats['wins'] as int? ?? 0) + (isWinner ? 1 : 0);
    stats['losses'] = (stats['losses'] as int? ?? 0) + (isWinner ? 0 : 1);
    stats['setsWon'] =
        (stats['setsWon'] as int? ?? 0) + (match.score[team]?.sets ?? 0);
    stats['setsLost'] = (stats['setsLost'] as int? ?? 0) +
        (match.score[opposingTeam]?.sets ?? 0);
    stats['gamesWon'] = (stats['gamesWon'] as int? ?? 0) + gamesWonTotal;
    stats['gamesLost'] = (stats['gamesLost'] as int? ?? 0) + gamesLostTotal;

    // Update recent matches
    List<String> recentMatches =
        List<String>.from(stats['recentMatches'] as List<dynamic>? ?? []);
    recentMatches.insert(0, isWinner ? 'W' : 'L');
    if (recentMatches.length > 5) {
      recentMatches = recentMatches.sublist(0, 5);
    }
    stats['recentMatches'] = recentMatches;

    // Calculate win rate
    int totalMatches =
        (stats['wins'] as int? ?? 0) + (stats['losses'] as int? ?? 0);
    stats['winRate'] = totalMatches > 0
        ? ((stats['wins'] as int? ?? 0) / totalMatches) * 100
        : 0.0;

    // Add the update to the batch
    batch.update(playerRef, {
      'statistics': stats,
      'lastMatchDate': FieldValue.serverTimestamp(),
    });

    debugPrint('Added statistics update to batch for player: $playerId');
  }
}
import '../models/player.dart';
import '../models/match.dart';
import 'data_service_interface.dart';

class MockDataService implements DataServiceInterface {
  final List<Match> _matches = [];
  final List<Player> _players = [
    Player(
      id: "1",
      name: "John Smith",
      rating: 4.5,
      rank: 1,
      profileImage: "assets/images/profile.png",
      createdAt: DateTime.now(),
    ),
    Player(
      id: "2",
      name: "Maria Garcia",
      rating: 4.3,
      rank: 2,
      profileImage: "assets/images/profile.png",
      createdAt: DateTime.now(),
    ),
  ];
  final List<Map<String, dynamic>> _bookings = [];

  @override
  Stream<List<Player>> getPlayersStream() {
    return Stream.value(_players);
  }

  @override
  Future<List<Player>> getAllPlayers() async {
    return _players;
  }

  @override
  Future<void> createBooking(
      String playerId, String day, String timeslot) async {
    _bookings.add({
      'id': DateTime.now().millisecondsSinceEpoch.toString(),
      'playerId': playerId,
      'day': day,
      'timeslot': timeslot,
      'createdAt': DateTime.now().toIso8601String(),
    });
  }

  @override
  Stream<List<Map<String, dynamic>>> getBookingsForDay(String day) {
    return Stream.value(
      _bookings.where((booking) => booking['day'] == day).toList(),
    );
  }

  @override
  Future<void> loadBookingsForPlayer(String playerId) async {
    // In mock service, data is already in memory
    return;
  }

  @override
  Future<void> deletePlayerBookings(String playerId) async {
    _bookings.removeWhere((booking) => booking['playerId'] == playerId);
  }

  @override
  Future<void> createMatch({
    required DateTime date,
    required String time,
    required List<String> team1PlayerIds,
    required List<String> team2PlayerIds,
  }) async {
    final newMatch = Match(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      date: date,
      time: time,
      status: MatchStatus.scheduled,
      players: {
        'team1_player1': _players.firstWhere((p) => p.id == team1PlayerIds[0]),
        'team1_player2': _players.firstWhere((p) => p.id == team1PlayerIds[1]),
        'team2_player1': _players.firstWhere((p) => p.id == team2PlayerIds[0]),
        'team2_player2': _players.firstWhere((p) => p.id == team2PlayerIds[1]),
      },
      score: {
        'team1': Score(sets: 0, games: []),
        'team2': Score(sets: 0, games: []),
      },
      createdAt: DateTime.now(),
    );
    _matches.add(newMatch);
  }

  @override
  Stream<List<Match>> getMatchesStream() {
    return Stream.value(_matches);
  }

  @override
  Future<List<Match>> getAllMatches() async {
    return _matches;
  }

  @override
  Future<void> updateMatchScore(
    String matchId,
    String team,
    String type,
    dynamic value,
  ) async {
    final matchIndex = _matches.indexWhere((m) => m.id == matchId);
    if (matchIndex == -1) return;

    final match = _matches[matchIndex];
    final newScore = Map<String, Score>.from(match.score);

    if (type == 'sets') {
      newScore[team] = newScore[team]!.copyWith(sets: value as int);
    } else if (type == 'games') {
      newScore[team] = newScore[team]!.copyWith(games: value as List<int>);
    }

    _matches[matchIndex] = match.copyWith(score: newScore);

    // Update player statistics
    _updatePlayerStats(match, team);
  }

  void _updatePlayerStats(Match match, String team) {
    final isWinner = match.score[team]!.sets >
        match.score[team == 'team1' ? 'team2' : 'team1']!.sets;

    // Update stats for both players on the team
    final player1 = match.players['${team}_player1'];
    final player2 = match.players['${team}_player2'];

    if (player1 != null) {
      _updateSinglePlayerStats(player1, isWinner, match, team);
    }
    if (player2 != null) {
      _updateSinglePlayerStats(player2, isWinner, match, team);
    }
  }

  void _updateSinglePlayerStats(
      Player player, bool isWinner, Match match, String team) {
    final playerIndex = _players.indexWhere((p) => p.id == player.id);
    if (playerIndex == -1) return;

    final updatedPlayer = _players[playerIndex];
    if (isWinner) {
      updatedPlayer.statistics.wins++;
    } else {
      updatedPlayer.statistics.losses++;
    }

    // Update sets and games
    final teamScore = match.score[team]!;
    final opposingScore = match.score[team == 'team1' ? 'team2' : 'team1']!;

    updatedPlayer.statistics.setsWon += teamScore.sets;
    updatedPlayer.statistics.setsLost += opposingScore.sets;

    updatedPlayer.statistics.gamesWon +=
        teamScore.games.fold(0, (sum, game) => sum + game);
    updatedPlayer.statistics.gamesLost +=
        opposingScore.games.fold(0, (sum, game) => sum + game);

    // Update win rate
    final totalMatches =
        updatedPlayer.statistics.wins + updatedPlayer.statistics.losses;
    if (totalMatches > 0) {
      updatedPlayer.statistics.winRate =
          (updatedPlayer.statistics.wins / totalMatches) * 100;
    }

    _players[playerIndex] = updatedPlayer;
  }

  @override
  Future<void> updateMatchStatus(String matchId, MatchStatus status) async {
    final matchIndex = _matches.indexWhere((m) => m.id == matchId);
    if (matchIndex == -1) return;

    _matches[matchIndex] = _matches[matchIndex].copyWith(status: status);
  }
}
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/player.dart';
import '../models/match.dart';

class MatchMaker {
  /// Create matches based on bookings for a specific timeslot
  static Future<List<Match>> createMatchesFromBookings(
    List<Map<String, dynamic>> bookings,
    List<Player> players,
    String timeSlot,
    String day,
  ) async {
    try {
      debugPrint(
          'Creating matches for $day $timeSlot with ${bookings.length} bookings');

      // Filter booked players for this timeslot
      final bookedPlayers = players.where((player) {
        return bookings.any((booking) =>
            booking['playerId'] == player.id &&
            (booking['timeslot'] == timeSlot ||
                booking['timeslot'] == 'Play Either'));
      }).toList();

      debugPrint('Found ${bookedPlayers.length} players for matches');

      // Sort players by rank
      bookedPlayers.sort((a, b) => a.rank.compareTo(b.rank));
      final matches = <Match>[];

      // Create matches with groups of 4 players
      for (var i = 0; i < bookedPlayers.length; i += 4) {
        if (i + 3 < bookedPlayers.length) {
          final matchPlayers = bookedPlayers.sublist(i, i + 4);

          // Generate match ID using consistent format
          final matchId =
              'match_${DateTime.now().toIso8601String().split('T')[0]}_${timeSlot.replaceAll(' ', '_')}_${(i ~/ 4) + 1}';

          debugPrint('Creating match with ID: $matchId');

          // Prepare match data for Firestore
          final matchData = {
            'id': matchId,
            'date': Timestamp.fromDate(DateTime.now()),
            'time': timeSlot,
            'status': 'scheduled',
            'players': {
              'team1': {
                'player1': FirebaseFirestore.instance
                    .doc('players/${matchPlayers[0].id}'),
                'player2': FirebaseFirestore.instance
                    .doc('players/${matchPlayers[3].id}'),
              },
              'team2': {
                'player1': FirebaseFirestore.instance
                    .doc('players/${matchPlayers[1].id}'),
                'player2': FirebaseFirestore.instance
                    .doc('players/${matchPlayers[2].id}'),
              },
            },
            'score': {
              'team1': {'sets': 0, 'games': []},
              'team2': {'sets': 0, 'games': []},
            },
            'createdAt': FieldValue.serverTimestamp(),
          };

          // Persist to Firestore
          await FirebaseFirestore.instance
              .collection('matches')
              .doc(matchId)
              .set(matchData);

          debugPrint('Successfully persisted match $matchId to Firestore');

          // Create match object for UI
          final match = Match(
            id: matchId,
            date: DateTime.now(),
            time: timeSlot,
            status: MatchStatus.scheduled,
            players: {
              'team1_player1': matchPlayers[0],
              'team1_player2': matchPlayers[3],
              'team2_player1': matchPlayers[1],
              'team2_player2': matchPlayers[2],
            },
            score: {
              'team1': Score(sets: 0, games: []),
              'team2': Score(sets: 0, games: []),
            },
            createdAt: DateTime.now(),
          );

          matches.add(match);
        }
      }

      return matches;
    } catch (e) {
      debugPrint('Error creating matches: $e');
      rethrow;
    }
  }

  /// Gets color based on player rank
  static Color getLevelColor(int rank) {
    if (rank >= 1 && rank <= 15) return Colors.blue[900]!;
    if (rank >= 16 && rank <= 30) return Colors.blue[300]!;
    if (rank >= 31 && rank <= 50) return Colors.yellow;
    if (rank >= 51 && rank <= 70) return Colors.green;
    if (rank >= 71 && rank <= 90) return Colors.orange;
    return Colors.red;
  }
}
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';

class AuthService {
  final bool _useMockAuth = defaultTargetPlatform == TargetPlatform.linux;
  final FirebaseAuth? _auth = defaultTargetPlatform != TargetPlatform.linux
      ? FirebaseAuth.instance
      : null;

  // Mock user storage for Linux development
  static final Map<String, MockUser> _mockUsers = {};

  // Register with email and password
  Future<UserCredential> registerWithEmailAndPassword(
      String email, String password) async {
    try {
      final lowercaseEmail = email.trim().toLowerCase();

      if (_useMockAuth) {
        // Simulate network delay
        await Future.delayed(const Duration(seconds: 1));

        // Create mock user
        final mockUser = MockUser(
          uid: 'mock_${DateTime.now().millisecondsSinceEpoch}',
          email: lowercaseEmail,
        );
        _mockUsers[lowercaseEmail] = mockUser;

        // Return mock credential without cast
        return MockUserCredential(user: mockUser);
      } else {
        // Real Firebase registration
        return await _auth!.createUserWithEmailAndPassword(
          email: lowercaseEmail,
          password: password.trim(),
        );
      }
    } on FirebaseAuthException catch (e) {
      // Handle specific Firebase errors
      switch (e.code) {
        case 'weak-password':
          throw Exception('The password provided is too weak.');
        case 'email-already-in-use':
          throw Exception('This email is already registered.');
        case 'invalid-email':
          throw Exception('The email address is not valid.');
        case 'operation-not-allowed':
          throw Exception(
              'Email/password accounts are not enabled. Please contact support.');
        default:
          throw Exception('Registration failed: ${e.message}');
      }
    } catch (e) {
      throw Exception('Registration failed: $e');
    }
  }

  // Sign in with email and password
  Future<UserCredential> signInWithEmailAndPassword(
      String email, String password) async {
    try {
      final lowercaseEmail = email.trim().toLowerCase();

      debugPrint(
          'Attempting login for email: $lowercaseEmail'); // Debugging statement

      if (_useMockAuth) {
        // Simulate network delay
        await Future.delayed(const Duration(seconds: 1));

        // Retrieve mock user
        final user = _mockUsers[lowercaseEmail];
        if (user != null) {
          debugPrint("Mock login successful for email: $lowercaseEmail");
          return MockUserCredential(user: user);
        }
        throw Exception('No user found for that email.');
      } else {
        // Real Firebase sign-in
        return await _auth!.signInWithEmailAndPassword(
          email: lowercaseEmail,
          password: password.trim(),
        );
      }
    } on FirebaseAuthException catch (e) {
      debugPrint(
          "FirebaseAuthException: ${e.code} - ${e.message}"); // Debugging statement

      // Handle specific Firebase errors
      switch (e.code) {
        case 'user-not-found':
          throw Exception('No user found for that email.');
        case 'wrong-password':
          throw Exception('Wrong password provided.');
        case 'user-disabled':
          throw Exception('This user account has been disabled.');
        case 'invalid-email':
          throw Exception('The email address is not valid.');
        default:
          throw Exception('Login failed: ${e.message}');
      }
    } catch (e) {
      debugPrint("General Exception: $e"); // Debugging statement
      throw Exception('Login failed: $e');
    }
  }

  // Sign out
  Future<void> signOut() async {
    if (_useMockAuth) {
      await Future.delayed(const Duration(milliseconds: 500));
      return;
    }
    await _auth!.signOut();
  }

  // Get current user ID
  String? getCurrentUserId() {
    if (_useMockAuth) {
      return _mockUsers.values.isNotEmpty ? _mockUsers.values.first.uid : null;
    }
    return _auth?.currentUser?.uid;
  }

  User? get currentUser => _auth?.currentUser;

  Stream<User?> get authStateChanges =>
      _auth?.authStateChanges() ?? const Stream.empty();
}

// Mock classes for Linux development
class MockUser implements User {
  @override
  final String uid;
  @override
  final String email;

  MockUser({required this.uid, required this.email});

  // Handle unimplemented methods with `noSuchMethod`
  @override
  dynamic noSuchMethod(Invocation invocation) => super.noSuchMethod(invocation);
}

class MockUserCredential implements UserCredential {
  @override
  final MockUser user;

  MockUserCredential({required this.user});

  // Handle unimplemented methods with `noSuchMethod`
  @override
  dynamic noSuchMethod(Invocation invocation) => super.noSuchMethod(invocation);
}
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/user_model.dart';

class UserService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  Future<void> createUser(UserModel user) async {
    try {
      await _firestore.collection('users').doc(user.id).set(user.toMap());
    } catch (e) {
      throw Exception('Failed to create user: $e');
    }
  }

  Future<UserModel?> getUser(String userId) async {
    try {
      final doc = await _firestore.collection('users').doc(userId).get();
      if (doc.exists) {
        return UserModel.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      throw Exception('Failed to get user: $e');
    }
  }

  Future<void> updateUser(UserModel user) async {
    try {
      await _firestore.collection('users').doc(user.id).update(user.toMap());
    } catch (e) {
      throw Exception('Failed to update user: $e');
    }
  }
}
import '../models/player.dart';
import '../models/match.dart';

abstract class DataServiceInterface {
  Stream<List<Player>> getPlayersStream();
  Future<List<Player>> getAllPlayers();
  Future<void> createBooking(String playerId, String day, String timeslot);
  Stream<List<Map<String, dynamic>>> getBookingsForDay(String day);
  Future<void> loadBookingsForPlayer(String playerId);
  Future<void> deletePlayerBookings(String playerId);
  Future<void> createMatch({
    required DateTime date,
    required String time,
    required List<String> team1PlayerIds,
    required List<String> team2PlayerIds,
  });
  Stream<List<Match>> getMatchesStream();
  Future<List<Match>> getAllMatches();
  Future<void> updateMatchScore(
      String matchId, String team, String type, dynamic value);
  Future<void> updateMatchStatus(String matchId, MatchStatus status);
}
import 'package:flutter/foundation.dart';
import '../models/player.dart';
import '../models/match.dart';
import '../services/data_service_interface.dart';
import '../services/firestore_service.dart';
import '../services/statistics_service.dart';

class AppState extends ChangeNotifier {
  final DataServiceInterface _dataService;
  final FirestoreService _firestoreService;
  final StatisticsService _statisticsService = StatisticsService();

  List<Player> _players = [];
  List<Match> _matches = [];
  final Map<String, List<Map<String, dynamic>>> _bookings = {};
  bool _isLoading = false;
  String? _error;

  AppState(this._dataService, this._firestoreService) {
    initializeStreams();
  }

  // Getters
  List<Player> get players => _players;
  List<Match> get matches => _matches;
  Map<String, List<Map<String, dynamic>>> get bookings => _bookings;
  bool get isLoading => _isLoading;
  String? get error => _error;
  // Initialize streams
  void initializeStreams() {
    try {
      debugPrint('Initializing streams');
      _cleanupSubscriptions();

      _dataService.getPlayersStream().listen((players) {
        _players = players;
        notifyListeners();
      });

      _firestoreService.getMatchesStream().listen((matches) {
        _matches = matches;
        notifyListeners();
      });

      _initializeBookings();
    } catch (e) {
      debugPrint('Error initializing streams: $e');
      setError('Error initializing data streams: $e');
    }
  }

  Future<void> _initializeBookings() async {
    debugPrint('Initializing bookings for all days');
    final days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
    for (final day in days) {
      await _refreshBookingsForDay(day);
    }
  }

  // Player-related methods
  Future<void> fetchPlayers() async {
    try {
      setLoading(true);
      _players = await _dataService.getAllPlayers();
      notifyListeners();
    } catch (e) {
      debugPrint('Error fetching players: $e');
      setError('Error fetching players: $e');
    } finally {
      setLoading(false);
    }
  }

  // Booking-related methods
  Future<void> createBooking(
      String playerId, String day, String timeslot) async {
    try {
      setLoading(true);
      debugPrint('Creating booking for player $playerId on $day at $timeslot');
      await _dataService.createBooking(playerId, day, timeslot);
      await _refreshBookingsForDay(day);
      notifyListeners();
    } catch (e) {
      debugPrint('Error creating booking: $e');
      setError('Error creating booking: $e');
    } finally {
      setLoading(false);
    }
  }

  Future<void> deletePlayerBookings(String playerId) async {
    try {
      setLoading(true);
      debugPrint('Deleting bookings for player $playerId');
      await _firestoreService.deletePlayerBookings(playerId);
      await _refreshAllData();
      notifyListeners();
    } catch (e) {
      debugPrint('Error deleting player bookings: $e');
      setError('Error deleting player bookings: $e');
    } finally {
      setLoading(false);
    }
  }

  Future<void> loadBookingsForDay(String day) async {
    try {
      debugPrint('Loading bookings for $day');
      final bookings = await _dataService.getBookingsForDay(day).first;
      _bookings[day] = bookings;
      notifyListeners();
    } catch (e) {
      debugPrint('Error loading bookings for $day: $e');
      setError('Error loading bookings for $day: $e');
    }
  }

  Future<void> _refreshBookingsForDay(String day) async {
    try {
      debugPrint('Refreshing bookings for $day');
      final bookings = await _dataService.getBookingsForDay(day).first;
      _bookings[day] = bookings;
      notifyListeners();
    } catch (e) {
      debugPrint('Error refreshing bookings for $day: $e');
      setError('Error refreshing bookings for $day: $e');
    }
  }

  // Match-related methods
  Future<void> createMatch({
    required DateTime date,
    required String time,
    required List<String> team1PlayerIds,
    required List<String> team2PlayerIds,
  }) async {
    try {
      setLoading(true);
      await _firestoreService.createMatch(
        date: date,
        time: time,
        team1PlayerIds: team1PlayerIds,
        team2PlayerIds: team2PlayerIds,
      );
      await refreshMatches();
    } catch (e) {
      debugPrint('Error creating match: $e');
      setError('Error creating match: $e');
    } finally {
      setLoading(false);
    }
  }

  Future<void> refreshMatches() async {
    try {
      setLoading(true);
      _matches = await _dataService.getAllMatches();
      notifyListeners();
    } catch (e) {
      debugPrint('Error refreshing matches: $e');
      setError('Error refreshing matches: $e');
    } finally {
      setLoading(false);
    }
  }

  Future<void> updateMatchScore(
    String matchId,
    String team,
    String type,
    dynamic value,
  ) async {
    try {
      await _firestoreService.updateMatchScore(matchId, team, type, value);

      final match = _matches.firstWhere((m) => m.id == matchId);
      if (match.isComplete) {
        await _statisticsService.updateMatchStatistics(match);
      }
      await refreshMatches();
    } catch (e) {
      debugPrint('Error updating match score: $e');
      setError('Error updating match score: $e');
    }
  }

  Future<void> updateMatchStatus(String matchId, MatchStatus status) async {
    try {
      await _firestoreService.updateMatchStatus(matchId, status);

      if (status == MatchStatus.completed) {
        final match = _matches.firstWhere((m) => m.id == matchId);
        await _statisticsService.updateMatchStatistics(match);
        await refreshMatches();
      }
    } catch (e) {
      debugPrint('Error updating match status: $e');
      setError('Error updating match status: $e');
    }
  }

  Future<void> _refreshAllData() async {
    try {
      debugPrint('Refreshing all data');
      final days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

      await Future.wait([
        refreshMatches(),
        ...days.map((day) => _refreshBookingsForDay(day)),
      ]);

      notifyListeners();
    } catch (e) {
      debugPrint('Error refreshing all data: $e');
      setError('Error refreshing data: $e');
    }
  }

  // State management methods
  void setLoading(bool value) {
    _isLoading = value;
    notifyListeners();
  }

  void setError(String? errorMessage) {
    _error = errorMessage;
    notifyListeners();
  }

  void _cleanupSubscriptions() {
    debugPrint('Cleaning up subscriptions');
    _players = [];
    _matches = [];
    _bookings.clear();
    _error = null;
  }

  @override
  void dispose() {
    _cleanupSubscriptions();
    super.dispose();
  }
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/player.dart';

// Provider for players
final playersProvider = StateNotifierProvider<PlayersNotifier, List<Player>>(
  (ref) => PlayersNotifier(),
);

// StateNotifier for managing player list
class PlayersNotifier extends StateNotifier<List<Player>> {
  PlayersNotifier() : super([]);

  void addPlayer(Player player) {
    state = [...state, player];
  }

  void updatePlayer(Player updatedPlayer) {
    state = state
        .map((p) => p.name == updatedPlayer.name ? updatedPlayer : p)
        .toList();
  }

  void removePlayer(String playerName) {
    state = state.where((p) => p.name != playerName).toList();
  }
}
import 'package:flutter/material.dart';

class ErrorView extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;

  const ErrorView({
    Key? key,
    required this.message,
    this.onRetry,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              color: Colors.red[300],
              size: 60,
            ),
            const SizedBox(height: 16),
            Text(
              message,
              textAlign: TextAlign.center,
              style: const TextStyle(
                fontSize: 16,
                color: Colors.grey,
              ),
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: const Text('Try Again'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 24,
                    vertical: 12,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

class LoadingView extends StatelessWidget {
  final String? message;

  const LoadingView({
    Key? key,
    this.message,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(),
          if (message != null) ...[
            const SizedBox(height: 16),
            Text(
              message!,
              style: const TextStyle(
                color: Colors.grey,
                fontSize: 16,
              ),
            ),
          ],
        ],
      ),
    );
  }
}

class AsyncView<T> extends StatelessWidget {
  final Future<T> future;
  final Widget Function(T data) onData;
  final Widget Function(String error)? onError;
  final Widget Function()? onLoading;

  const AsyncView({
    Key? key,
    required this.future,
    required this.onData,
    this.onError,
    this.onLoading,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<T>(
      future: future,
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          return onError?.call(snapshot.error.toString()) ??
              ErrorView(
                message: snapshot.error.toString(),
                onRetry: () {
                  // Rebuild the widget to retry the future
                  (context as Element).markNeedsBuild();
                },
              );
        }

        if (snapshot.hasData) {
          return onData(snapshot.data as T);
        }

        return onLoading?.call() ?? const LoadingView();
      },
    );
  }
}
import 'package:flutter/material.dart';
import 'dart:math';

class ProfileImageWidget extends StatelessWidget {
  final String imageUrl;
  final String name;
  final double size;
  final Color? borderColor;
  final VoidCallback? onTap;
  final bool isEditable;

  const ProfileImageWidget({
    Key? key,
    required this.imageUrl,
    required this.name,
    this.size = 60,
    this.borderColor,
    this.onTap,
    this.isEditable = false,
  }) : super(key: key);

  String _getInitials() {
    final nameParts = name.split(' ');
    if (nameParts.isEmpty) return '';
    if (nameParts.length == 1) {
      return nameParts[0]
          .substring(0, min(2, nameParts[0].length))
          .toUpperCase();
    }
    return (nameParts[0][0] + (nameParts.length > 1 ? nameParts[1][0] : ''))
        .toUpperCase();
  }

  @override
  Widget build(BuildContext context) {
    final bool isAssetImage = imageUrl.startsWith('assets/');

    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: borderColor != null
            ? Border.all(color: borderColor!, width: size / 30)
            : null,
      ),
      child: Stack(
        children: [
          ClipOval(
            child: isAssetImage
                ? Image.asset(
                    imageUrl,
                    fit: BoxFit.cover,
                    errorBuilder: (context, error, stackTrace) =>
                        _buildFallbackWidget(),
                  )
                : Image.network(
                    imageUrl,
                    fit: BoxFit.cover,
                    loadingBuilder: (context, child, loadingProgress) {
                      if (loadingProgress == null) return child;
                      return _buildLoadingWidget();
                    },
                    errorBuilder: (context, error, stackTrace) =>
                        _buildFallbackWidget(),
                  ),
          ),
          if (isEditable)
            Positioned(
              right: 0,
              bottom: 0,
              child: Container(
                padding: const EdgeInsets.all(4),
                decoration: BoxDecoration(
                  color: Colors.blue,
                  shape: BoxShape.circle,
                  border: Border.all(color: Colors.white, width: 2),
                ),
                child: const Icon(Icons.edit, color: Colors.white, size: 16),
              ),
            ),
          if (onTap != null)
            Positioned.fill(
              child: Material(
                color: Colors.transparent,
                child: InkWell(
                  onTap: onTap,
                  customBorder: const CircleBorder(),
                ),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildLoadingWidget() {
    return Container(
      color: Colors.grey[200],
      child: Center(
        child: SizedBox(
          width: size * 0.4,
          height: size * 0.4,
          child: const CircularProgressIndicator(strokeWidth: 2),
        ),
      ),
    );
  }

  Widget _buildFallbackWidget() {
    return Container(
      color: Colors.grey[200],
      child: Center(
        child: Text(
          _getInitials(),
          style: TextStyle(
            color: Colors.grey[800],
            fontWeight: FontWeight.bold,
            fontSize: size * 0.4,
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';

class AppTheme {
  // Primary Colors
  static const Color primaryColor = Color(0xFF1A237E); // Deep Blue
  static const Color secondaryColor = Color(0xFF7E57C2); // Purple
  static const Color lightBackgroundColor = Color(0xFFF5F5F5); // Light Grey
  static const Color darkBackgroundColor = Color(0xFF121212); // Dark Grey

  // Font Family
  static const String fontFamily =
      'Poppins'; // Replace with your font if needed

  // Light Theme
  static ThemeData lightTheme = ThemeData(
    brightness: Brightness.light,
    primaryColor: primaryColor,
    scaffoldBackgroundColor: lightBackgroundColor,
    fontFamily: fontFamily,
    colorScheme: const ColorScheme.light(
      primary: primaryColor,
      secondary: secondaryColor,
      surface: Colors.white,
      error: Colors.red,
    ),
    textTheme: _lightTextTheme,
    elevatedButtonTheme: _elevatedButtonTheme,
    cardTheme: _cardTheme,
    appBarTheme: _appBarTheme,
    bottomNavigationBarTheme: _bottomNavBarTheme.copyWith(
      backgroundColor: primaryColor,
    ),
  );

  // Dark Theme
  static ThemeData darkTheme = ThemeData(
    brightness: Brightness.dark,
    primaryColor: primaryColor,
    scaffoldBackgroundColor: darkBackgroundColor,
    fontFamily: fontFamily,
    colorScheme: ColorScheme.dark(
      primary: primaryColor,
      secondary: secondaryColor,
      surface: Colors.grey.shade800, // Use runtime value instead of const
      error: Colors.red,
    ),
    textTheme: _darkTextTheme,
    elevatedButtonTheme: _elevatedButtonTheme,
    cardTheme: _cardTheme.copyWith(color: Colors.grey[900]),
    appBarTheme: _appBarTheme.copyWith(
      backgroundColor: primaryColor,
    ),
    bottomNavigationBarTheme: _bottomNavBarTheme.copyWith(
      backgroundColor: Colors.grey[900],
    ),
  );

  // Text Themes
  static const TextTheme _lightTextTheme = TextTheme(
    displayLarge: TextStyle(
      fontSize: 24,
      fontWeight: FontWeight.bold,
      color: Colors.black,
    ),
    displayMedium: TextStyle(
      fontSize: 20,
      fontWeight: FontWeight.bold,
      color: Colors.black,
    ),
    bodyLarge: TextStyle(
      fontSize: 16,
      color: Colors.black54,
    ),
    bodyMedium: TextStyle(
      fontSize: 14,
      color: Colors.black54,
    ),
    labelLarge: TextStyle(
      fontSize: 16,
      fontWeight: FontWeight.bold,
      color: Colors.white,
    ),
  );

  static const TextTheme _darkTextTheme = TextTheme(
    displayLarge: TextStyle(
      fontSize: 24,
      fontWeight: FontWeight.bold,
      color: Colors.white,
    ),
    displayMedium: TextStyle(
      fontSize: 20,
      fontWeight: FontWeight.bold,
      color: Colors.white,
    ),
    bodyLarge: TextStyle(
      fontSize: 16,
      color: Colors.grey,
    ),
    bodyMedium: TextStyle(
      fontSize: 14,
      color: Colors.grey,
    ),
    labelLarge: TextStyle(
      fontSize: 16,
      fontWeight: FontWeight.bold,
      color: Colors.white,
    ),
  );

  // Elevated Button Theme
  static final ElevatedButtonThemeData _elevatedButtonTheme =
      ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: primaryColor,
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 24),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
      ),
      textStyle: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.bold,
        color: Colors.white,
      ),
    ),
  );

  // Card Theme
  static final CardTheme _cardTheme = CardTheme(
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(12),
    ),
    elevation: 4,
    margin: const EdgeInsets.all(8),
  );

  // AppBar Theme
  static final AppBarTheme _appBarTheme = AppBarTheme(
    backgroundColor: primaryColor,
    elevation: 0,
    titleTextStyle: _lightTextTheme.displayLarge,
  );

  // Bottom Navigation Bar Theme
  static const BottomNavigationBarThemeData _bottomNavBarTheme =
      BottomNavigationBarThemeData(
    selectedItemColor: Colors.white,
    unselectedItemColor: Colors.white70,
  );
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'providers/app_state.dart';
import 'screens/auth/login_screen.dart';
import 'screens/main_dashboard/main_dashboard.dart';
import 'services/firestore_service.dart';
import 'theme/theme.dart';

Future<void> initializeFirebase() async {
  try {
    final app = await Firebase.initializeApp(
      options: const FirebaseOptions(
        apiKey: "AIzaSyBMpwBZbDi6AFOQEheg1TOzG0aNwg2dfHc",
        authDomain: "padel-trax-killwd.firebaseapp.com",
        projectId: "padel-trax-killwd",
        storageBucket: "padel-trax-killwd.appspot.com",
        messagingSenderId: "1040892024883",
        appId: "1:1040892024883:web:11750f6de0d0ee077c6b46",
      ),
    );

    debugPrint('Firebase App initialized: ${app.name}');

    try {
      // Configure Firestore persistence
      FirebaseFirestore.instance.settings = const Settings(
        persistenceEnabled: true, // Enable persistence
        cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED, // Unlimited cache
      );

      debugPrint('Firestore persistence configured successfully');
    } catch (e) {
      debugPrint('Warning: Firestore persistence configuration failed: $e');
    }

    return;
  } catch (e) {
    if (e is FirebaseException) {
      debugPrint('Firebase initialization error: ${e.code} - ${e.message}');
      if (e.code == 'duplicate-app') {
        debugPrint('Firebase app already initialized');
        return;
      }
    }
    debugPrint('Error initializing Firebase: $e');
    rethrow;
  }
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  try {
    await initializeFirebase();
    runApp(const MyApp());
  } catch (e) {
    debugPrint('Fatal error during initialization: $e');
    runApp(const ErrorApp());
  }
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (_) {
            final firestoreService = FirestoreService();
            final appState = AppState(firestoreService, firestoreService);
            WidgetsBinding.instance.addPostFrameCallback((_) {
              appState.initializeStreams();
            });
            return appState;
          },
        ),
        StreamProvider<User?>(
          create: (_) => FirebaseAuth.instance.authStateChanges(),
          initialData: null,
          catchError: (_, error) {
            debugPrint('Error in auth state stream: $error');
            return null;
          },
        ),
      ],
      child: MaterialApp(
        title: 'Padeltrax',
        debugShowCheckedModeBanner: false,
        theme: AppTheme.lightTheme,
        darkTheme: AppTheme.darkTheme,
        themeMode: ThemeMode.system,
        home: Consumer<User?>(
          builder: (context, user, _) {
            if (user != null) {
              return const MainDashboard();
            }
            return const LoginScreen();
          },
        ),
      ),
    );
  }
}

class ErrorApp extends StatelessWidget {
  const ErrorApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(
                Icons.error_outline,
                color: Colors.red,
                size: 48,
              ),
              const SizedBox(height: 16),
              const Text(
                'Failed to initialize app',
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              ElevatedButton(
                onPressed: () {
                  initializeFirebase().then((_) {
                    runApp(const MyApp());
                  }).catchError((error) {
                    debugPrint('Reinitialization failed: $error');
                  });
                },
                child: const Text('Retry'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:padeltrax_app/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}
